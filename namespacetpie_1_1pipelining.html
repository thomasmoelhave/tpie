<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>tpie::pipelining Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="madalgo-doxygen.css" rel="stylesheet" type="text/css"/>
<link href="printstyle.css" rel="stylesheet" type="text/css" media="print" />
</head>
<body>
<div id="top">
<div id="titlearea">
<h1 id="projectname">TPIE</h1>
<span class="version"><a href="//github.com/thomasmoelhave/tpie/tree/4739728">4739728</a></span>
</div>
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespacetpie_1_1pipelining.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">tpie::pipelining Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="factory__base_8h_source.html">pipelining/factory_base.h</a> Base class of pipelining factories  
<a href="namespacetpie_1_1pipelining.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1pipelining_1_1any__noncopyable.html">any_noncopyable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1pipelining_1_1Args.html">Args</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1pipelining_1_1bad__any__noncopyable__cast.html">bad_any_noncopyable_cast</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1pipelining_1_1bad__any__noncopyable__copy.html">bad_any_noncopyable_copy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1pipelining_1_1call__order__exception.html">call_order_exception</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1pipelining_1_1container.html">container</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtpie_1_1pipelining_1_1container_3_01T_00_01TT_8_8_8_01_4.html">container&lt; T, TT... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtpie_1_1pipelining_1_1destination__kind.html">destination_kind</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1pipelining_1_1empty__pipe__middle.html">empty_pipe_middle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1pipelining_1_1factory.html">factory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1pipelining_1_1factory__base.html">factory_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class of all pipelining factories.  <a href="classtpie_1_1pipelining_1_1factory__base.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1pipelining_1_1factory__init__hook.html">factory_init_hook</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1pipelining_1_1internal__passive__buffer.html">internal_passive_buffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal fifo buffer.  <a href="classtpie_1_1pipelining_1_1internal__passive__buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1pipelining_1_1internal__passive__reverser.html">internal_passive_reverser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A passive reverser stored in internal memory.  <a href="classtpie_1_1pipelining_1_1internal__passive__reverser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1pipelining_1_1join.html">join</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Joins multiple push streams into one.  <a href="classtpie_1_1pipelining_1_1join.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1pipelining_1_1no__initiator__node.html">no_initiator_node</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1pipelining_1_1node.html">node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class of all nodes.  <a href="classtpie_1_1pipelining_1_1node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtpie_1_1pipelining_1_1node__parameters.html">node_parameters</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtpie_1_1pipelining_1_1node__resource__parameters.html">node_resource_parameters</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1pipelining_1_1node__token.html">node_token</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1pipelining_1_1non__authoritative__node__map.html">non_authoritative_node_map</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1pipelining_1_1not__initiator__node.html">not_initiator_node</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1pipelining_1_1passive__buffer.html">passive_buffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plain old <a class="el" href="classtpie_1_1file__stream.html" title="Compressed stream.">file_stream</a> buffer.  <a href="classtpie_1_1pipelining_1_1passive__buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1pipelining_1_1passive__reverser.html">passive_reverser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A passive reverser stored in external memory.  <a href="classtpie_1_1pipelining_1_1passive__reverser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1pipelining_1_1passive__serialization__buffer.html">passive_serialization_buffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Serialization stream buffer.  <a href="classtpie_1_1pipelining_1_1passive__serialization__buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1pipelining_1_1passive__serialization__reverser.html">passive_serialization_reverser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A passive serialization reverser stored in external memory.  <a href="classtpie_1_1pipelining_1_1passive__serialization__reverser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1pipelining_1_1passive__sorter.html">passive_sorter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pipelined sorter with push input and pull output.  <a href="classtpie_1_1pipelining_1_1passive__sorter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1pipelining_1_1pipe__begin.html">pipe_begin</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1pipelining_1_1pipe__end.html">pipe_end</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1pipelining_1_1pipe__middle.html">pipe_middle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1pipelining_1_1pipeline.html">pipeline</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtpie_1_1pipelining_1_1pull__type.html">pull_type</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1pipelining_1_1pullpipe__begin.html">pullpipe_begin</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1pipelining_1_1pullpipe__end.html">pullpipe_end</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1pipelining_1_1pullpipe__middle.html">pullpipe_middle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtpie_1_1pipelining_1_1push__type.html">push_type</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to deduce the item_type of a node of type T.  <a href="structtpie_1_1pipelining_1_1push__type.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1pipelining_1_1serialization__passive__sorter.html">serialization_passive_sorter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pipelined sorter with push input and pull output.  <a href="classtpie_1_1pipelining_1_1serialization__passive__sorter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1pipelining_1_1split.html">split</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split one push streams into multiple.  <a href="classtpie_1_1pipelining_1_1split.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1pipelining_1_1split__factory.html">split_factory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Node factory for split nodes, typically used for phase boundary nodes.  <a href="classtpie_1_1pipelining_1_1split__factory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtpie_1_1pipelining_1_1subpipeline.html">subpipeline</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1pipelining_1_1termfactory.html">termfactory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1pipelining_1_1tfactory.html">tfactory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1pipelining_1_1tfactory_3_01R_00_01Args_3_01TT_8_8_8_01_4_00_01T_8_8_8_01_4.html">tfactory&lt; R, Args&lt; TT... &gt;, T... &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1pipelining_1_1virtual__chunk.html">virtual_chunk</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual chunk that has input and output.  <a href="classtpie_1_1pipelining_1_1virtual__chunk.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1pipelining_1_1virtual__chunk__begin.html">virtual_chunk_begin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual chunk that has no input (that is, virtual producer).  <a href="classtpie_1_1pipelining_1_1virtual__chunk__begin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1pipelining_1_1virtual__chunk__end.html">virtual_chunk_end</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual chunk that has no output (that is, virtual consumer).  <a href="classtpie_1_1pipelining_1_1virtual__chunk__end.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1pipelining_1_1virtual__chunk__missing__begin.html">virtual_chunk_missing_begin</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1pipelining_1_1virtual__chunk__missing__end.html">virtual_chunk_missing_end</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1pipelining_1_1virtual__chunk__missing__middle.html">virtual_chunk_missing_middle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1pipelining_1_1virtual__chunk__not__ready.html">virtual_chunk_not_ready</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1pipelining_1_1virtual__chunk__pull.html">virtual_chunk_pull</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual chunk that has input and output.  <a href="classtpie_1_1pipelining_1_1virtual__chunk__pull.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1pipelining_1_1virtual__chunk__pull__begin.html">virtual_chunk_pull_begin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual chunk that has no output (that is, virtual consumer).  <a href="classtpie_1_1pipelining_1_1virtual__chunk__pull__begin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1pipelining_1_1virtual__chunk__pull__end.html">virtual_chunk_pull_end</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual chunk that has no input (that is, virtual producer).  <a href="classtpie_1_1pipelining_1_1virtual__chunk__pull__end.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1pipelining_1_1virtual__container.html">virtual_container</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual base class for extra data to go with virtual chunks.  <a href="classtpie_1_1pipelining_1_1virtual__container.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a877590b7fc6795fe07d7674323bbf92e"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classtpie_1_1pipelining_1_1pipe__middle.html">pipe_middle</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1split__factory.html">split_factory</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1buffer__input__t.html">bits::buffer_input_t</a>, <a class="el" href="classtpie_1_1pipelining_1_1node.html">node</a>, <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1buffer__output__t.html">bits::buffer_output_t</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetpie_1_1pipelining.html#a877590b7fc6795fe07d7674323bbf92e">buffer</a></td></tr>
<tr class="memdesc:a877590b7fc6795fe07d7674323bbf92e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The buffer node inserts a phase boundary into the pipeline by writing items to disk.  <a href="namespacetpie_1_1pipelining.html#a877590b7fc6795fe07d7674323bbf92e">More...</a><br /></td></tr>
<tr class="separator:a877590b7fc6795fe07d7674323bbf92e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3d10d0df467a28cb2d9e08106241029"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classtpie_1_1pipelining_1_1pipe__middle.html">pipe_middle</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1factory.html">factory</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1chunker__t.html">bits::chunker_t</a>, size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetpie_1_1pipelining.html#ad3d10d0df467a28cb2d9e08106241029">chunker</a></td></tr>
<tr class="memdesc:ad3d10d0df467a28cb2d9e08106241029"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pipelining node that gathers elements into a vector of some size.  <a href="namespacetpie_1_1pipelining.html#ad3d10d0df467a28cb2d9e08106241029">More...</a><br /></td></tr>
<tr class="separator:ad3d10d0df467a28cb2d9e08106241029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6338d4e3a353740f6d641699f012461"><td class="memItemLeft" align="right" valign="top"><a id="ae6338d4e3a353740f6d641699f012461"></a>
typedef <a class="el" href="classtpie_1_1flags.html">tpie::flags</a>&lt; stream_option &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>stream_options</b></td></tr>
<tr class="separator:ae6338d4e3a353740f6d641699f012461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98c484e810537b48040f63fdf8d52e9b"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classtpie_1_1pipelining_1_1pipe__begin.html">pipe_begin</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1factory.html">factory</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1named__input__t.html">bits::named_input_t</a>, std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetpie_1_1pipelining.html#a98c484e810537b48040f63fdf8d52e9b">named_input</a></td></tr>
<tr class="memdesc:a98c484e810537b48040f63fdf8d52e9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pipelining nodes that pushes the contents of the named file stream to the next node in the pipeline.  <a href="namespacetpie_1_1pipelining.html#a98c484e810537b48040f63fdf8d52e9b">More...</a><br /></td></tr>
<tr class="separator:a98c484e810537b48040f63fdf8d52e9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8635eea4a7a572a8d5f14c1087d266b9"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classtpie_1_1pipelining_1_1pullpipe__middle.html">pullpipe_middle</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1factory.html">factory</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1pull__peek__t.html">bits::pull_peek_t</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetpie_1_1pipelining.html#a8635eea4a7a572a8d5f14c1087d266b9">pull_peek</a></td></tr>
<tr class="memdesc:a8635eea4a7a572a8d5f14c1087d266b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A node that allows peeking at the next item in the pipeline.  <a href="namespacetpie_1_1pipelining.html#a8635eea4a7a572a8d5f14c1087d266b9">More...</a><br /></td></tr>
<tr class="separator:a8635eea4a7a572a8d5f14c1087d266b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89b529faf7a051312cb5aaabc5dc4446"><td class="memItemLeft" align="right" valign="top"><a id="a89b529faf7a051312cb5aaabc5dc4446"></a>
typedef boost::intrusive_ptr&lt; <a class="el" href="structtpie_1_1pipelining_1_1bits_1_1node__set__content.html">bits::node_set_content</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>node_set</b></td></tr>
<tr class="separator:a89b529faf7a051312cb5aaabc5dc4446"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd28a460d6c84426033fb0eb3d7a04fc"><td class="memTemplParams" colspan="2"><a id="acd28a460d6c84426033fb0eb3d7a04fc"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:acd28a460d6c84426033fb0eb3d7a04fc"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>push_type_map_identity</b> = T</td></tr>
<tr class="separator:acd28a460d6c84426033fb0eb3d7a04fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a791f08bb6beb00ee94880060b4e1b2f8"><td class="memTemplParams" colspan="2"><a id="a791f08bb6beb00ee94880060b4e1b2f8"></a>
template&lt;typename T , template&lt; typename &gt; typename map = push_type_map_identity&gt; </td></tr>
<tr class="memitem:a791f08bb6beb00ee94880060b4e1b2f8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><b>pull_type_base</b> = <a class="el" href="structtpie_1_1pipelining_1_1bits_1_1pull__type__base__help.html">bits::pull_type_base_help</a>&lt; typename <a class="el" href="structtpie_1_1pipelining_1_1push__type.html">push_type</a>&lt; T, bits::pull_type_base_tag &gt;::type, <a class="el" href="namespacetpie_1_1pipelining.html#a15bfa65d8eab87a59e638f883d441ad4">map</a> &gt;</td></tr>
<tr class="separator:a791f08bb6beb00ee94880060b4e1b2f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed007c3692365d601481e4454a9c58b0"><td class="memItemLeft" align="right" valign="top"><a id="aed007c3692365d601481e4454a9c58b0"></a>
typedef int&#160;</td><td class="memItemRight" valign="bottom"><b>priority_type</b></td></tr>
<tr class="separator:aed007c3692365d601481e4454a9c58b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff47d9407963e2e003e86a626b3a2a45"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classtpie_1_1pipelining_1_1pipe__middle.html">pipe_middle</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1split__factory.html">split_factory</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1reverser__input__t.html">bits::reverser_input_t</a>, <a class="el" href="classtpie_1_1pipelining_1_1node.html">node</a>, <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1reverser__output__t.html">bits::reverser_output_t</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetpie_1_1pipelining.html#aff47d9407963e2e003e86a626b3a2a45">reverser</a></td></tr>
<tr class="memdesc:aff47d9407963e2e003e86a626b3a2a45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a reverser node stored in external memory.  <a href="namespacetpie_1_1pipelining.html#aff47d9407963e2e003e86a626b3a2a45">More...</a><br /></td></tr>
<tr class="separator:aff47d9407963e2e003e86a626b3a2a45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14d6f6f08ebe853a0ea78ed5449faddb"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classtpie_1_1pipelining_1_1pipe__middle.html">pipe_middle</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1split__factory.html">split_factory</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1internal__reverser__input__t.html">bits::internal_reverser_input_t</a>, <a class="el" href="classtpie_1_1pipelining_1_1node.html">node</a>, <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1internal__reverser__output__t.html">bits::internal_reverser_output_t</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetpie_1_1pipelining.html#a14d6f6f08ebe853a0ea78ed5449faddb">internal_reverser</a></td></tr>
<tr class="memdesc:a14d6f6f08ebe853a0ea78ed5449faddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a reverser node stored in internal memory.  <a href="namespacetpie_1_1pipelining.html#a14d6f6f08ebe853a0ea78ed5449faddb">More...</a><br /></td></tr>
<tr class="separator:a14d6f6f08ebe853a0ea78ed5449faddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee041370b4ced1dcb5bd462f45e06eb1"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classtpie_1_1pipelining_1_1pipe__middle.html">pipe_middle</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1split__factory.html">split_factory</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1serialization__bits_1_1reverser__input__t.html">serialization_bits::reverser_input_t</a>, <a class="el" href="classtpie_1_1pipelining_1_1node.html">node</a>, <a class="el" href="classtpie_1_1pipelining_1_1serialization__bits_1_1reverser__output__t.html">serialization_bits::reverser_output_t</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetpie_1_1pipelining.html#aee041370b4ced1dcb5bd462f45e06eb1">serialization_reverser</a></td></tr>
<tr class="memdesc:aee041370b4ced1dcb5bd462f45e06eb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pipelining node that reverses serializable items and creates a phase boundary.  <a href="namespacetpie_1_1pipelining.html#aee041370b4ced1dcb5bd462f45e06eb1">More...</a><br /></td></tr>
<tr class="separator:aee041370b4ced1dcb5bd462f45e06eb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd9f0fd78ce19cfc6faf0b737afe7908"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classtpie_1_1pipelining_1_1pipe__middle.html">pipe_middle</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1split__factory.html">split_factory</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1serialization__bits_1_1buffer__input__t.html">serialization_bits::buffer_input_t</a>, <a class="el" href="classtpie_1_1pipelining_1_1node.html">node</a>, <a class="el" href="classtpie_1_1pipelining_1_1serialization__bits_1_1buffer__output__t.html">serialization_bits::buffer_output_t</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetpie_1_1pipelining.html#acd9f0fd78ce19cfc6faf0b737afe7908">serialization_buffer</a></td></tr>
<tr class="memdesc:acd9f0fd78ce19cfc6faf0b737afe7908"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pipelining node that acts as a buffer for serializable items and creates a phase boundary.  <a href="namespacetpie_1_1pipelining.html#acd9f0fd78ce19cfc6faf0b737afe7908">More...</a><br /></td></tr>
<tr class="separator:acd9f0fd78ce19cfc6faf0b737afe7908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac08cd229124e38812ddee98a6ad0bb73"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classtpie_1_1pipelining_1_1pipe__begin.html">pipe_begin</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1factory.html">factory</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1scanf__ints__t.html">bits::scanf_ints_t</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetpie_1_1pipelining.html#ac08cd229124e38812ddee98a6ad0bb73">scanf_ints</a></td></tr>
<tr class="memdesc:ac08cd229124e38812ddee98a6ad0bb73"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pipelining node that pushes the integers it reads using scanf.  <a href="namespacetpie_1_1pipelining.html#ac08cd229124e38812ddee98a6ad0bb73">More...</a><br /></td></tr>
<tr class="separator:ac08cd229124e38812ddee98a6ad0bb73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8185baaeedfd95e3d9fcfae0461441c"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classtpie_1_1pipelining_1_1pipe__end.html">pipe_end</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1termfactory.html">termfactory</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1printf__ints__t.html">bits::printf_ints_t</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetpie_1_1pipelining.html#ad8185baaeedfd95e3d9fcfae0461441c">printf_ints</a></td></tr>
<tr class="memdesc:ad8185baaeedfd95e3d9fcfae0461441c"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pipelining node that prints the items that are pushed to it.  <a href="namespacetpie_1_1pipelining.html#ad8185baaeedfd95e3d9fcfae0461441c">More...</a><br /></td></tr>
<tr class="separator:ad8185baaeedfd95e3d9fcfae0461441c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:afc5e334a139ffc40a9c57f7eaad67a3c"><td class="memItemLeft" align="right" valign="top"><a id="afc5e334a139ffc40a9c57f7eaad67a3c"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>stream_option</b> { <b>STREAM_RESET</b> =1, 
<b>STREAM_CLOSE</b> =2
 }</td></tr>
<tr class="separator:afc5e334a139ffc40a9c57f7eaad67a3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16a8744ad1f202f05bb32a2f60545ed4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetpie_1_1pipelining.html#a16a8744ad1f202f05bb32a2f60545ed4">maintain_order_type</a> { <a class="el" href="namespacetpie_1_1pipelining.html#a16a8744ad1f202f05bb32a2f60545ed4abf58a1a989c94ba7db61f23b21309b57">arbitrary_order</a> = false, 
<a class="el" href="namespacetpie_1_1pipelining.html#a16a8744ad1f202f05bb32a2f60545ed4a38a2c9bdf017a8b8d85054961d1c9dc8">maintain_order</a> = true
 }</td></tr>
<tr class="memdesc:a16a8744ad1f202f05bb32a2f60545ed4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type describing whether to maintain the order of items in parallel.  <a href="namespacetpie_1_1pipelining.html#a16a8744ad1f202f05bb32a2f60545ed4">More...</a><br /></td></tr>
<tr class="separator:a16a8744ad1f202f05bb32a2f60545ed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a97f4c0a4964d1aa7056e61cdc4d43163"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a97f4c0a4964d1aa7056e61cdc4d43163"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1pipelining_1_1pipe__begin.html">pipe_begin</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1factory.html">factory</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1ami__input__t.html">bits::ami_input_t</a>, <a class="el" href="classtpie_1_1ami_1_1stream.html">tpie::ami::stream</a>&lt; T &gt; &amp; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetpie_1_1pipelining.html#a97f4c0a4964d1aa7056e61cdc4d43163">ami_input</a> (<a class="el" href="classtpie_1_1ami_1_1stream.html">tpie::ami::stream</a>&lt; T &gt; &amp;<a class="el" href="namespacetpie_1_1pipelining.html#aec8021f755b4600d49276267552aa32b">input</a>)</td></tr>
<tr class="memdesc:a97f4c0a4964d1aa7056e61cdc4d43163"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pipelining nodes that pushes the contents of the given <a class="el" href="classtpie_1_1ami_1_1stream.html">ami::stream</a> to the next node in the pipeline.  <a href="namespacetpie_1_1pipelining.html#a97f4c0a4964d1aa7056e61cdc4d43163">More...</a><br /></td></tr>
<tr class="separator:a97f4c0a4964d1aa7056e61cdc4d43163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad31f8fb7606f19097ea9292fb7d72c94"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad31f8fb7606f19097ea9292fb7d72c94"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1pipelining_1_1pipe__begin.html">pipe_begin</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1factory.html">factory</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1ami__input__stack__t.html">bits::ami_input_stack_t</a>, <a class="el" href="classtpie_1_1ami_1_1stack.html">tpie::ami::stack</a>&lt; T &gt; &amp; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetpie_1_1pipelining.html#ad31f8fb7606f19097ea9292fb7d72c94">ami_input_stack</a> (<a class="el" href="classtpie_1_1ami_1_1stack.html">tpie::ami::stack</a>&lt; T &gt; &amp;<a class="el" href="namespacetpie_1_1pipelining.html#aec8021f755b4600d49276267552aa32b">input</a>)</td></tr>
<tr class="memdesc:ad31f8fb7606f19097ea9292fb7d72c94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pipelining nodes that pushes the contents of the given <a class="el" href="classtpie_1_1ami_1_1stack.html" title="An implementation of an external-memory stack compatible with the old AMI interface.">ami::stack</a> to the next node in the pipeline.  <a href="namespacetpie_1_1pipelining.html#ad31f8fb7606f19097ea9292fb7d72c94">More...</a><br /></td></tr>
<tr class="separator:ad31f8fb7606f19097ea9292fb7d72c94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdcd7c723ad5e7650c5492c2266063e2"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afdcd7c723ad5e7650c5492c2266063e2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1pipelining_1_1pullpipe__begin.html">pullpipe_begin</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1termfactory.html">termfactory</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1pull__input__t.html">bits::pull_input_t</a>&lt; T &gt;, <a class="el" href="classtpie_1_1ami_1_1stack.html">tpie::ami::stack</a>&lt; T &gt; &amp; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetpie_1_1pipelining.html#afdcd7c723ad5e7650c5492c2266063e2">ami_pull_input_stack</a> (<a class="el" href="classtpie_1_1ami_1_1stack.html">tpie::ami::stack</a>&lt; T &gt; &amp;fs)</td></tr>
<tr class="memdesc:afdcd7c723ad5e7650c5492c2266063e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pipelining pull-node that reads items from the given <a class="el" href="classtpie_1_1ami_1_1stack.html" title="An implementation of an external-memory stack compatible with the old AMI interface.">ami::stack</a>.  <a href="namespacetpie_1_1pipelining.html#afdcd7c723ad5e7650c5492c2266063e2">More...</a><br /></td></tr>
<tr class="separator:afdcd7c723ad5e7650c5492c2266063e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabb4cae0c7ab29258874bca1bd4ae78f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aabb4cae0c7ab29258874bca1bd4ae78f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1pipelining_1_1pipe__end.html">pipe_end</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1termfactory.html">termfactory</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1ami__output__t.html">bits::ami_output_t</a>&lt; T &gt;, <a class="el" href="classtpie_1_1ami_1_1stream.html">tpie::ami::stream</a>&lt; T &gt; &amp; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetpie_1_1pipelining.html#aabb4cae0c7ab29258874bca1bd4ae78f">ami_output</a> (<a class="el" href="classtpie_1_1ami_1_1stream.html">tpie::ami::stream</a>&lt; T &gt; &amp;fs)</td></tr>
<tr class="memdesc:aabb4cae0c7ab29258874bca1bd4ae78f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pipelining node that writes the pushed items to an ami stream.  <a href="namespacetpie_1_1pipelining.html#aabb4cae0c7ab29258874bca1bd4ae78f">More...</a><br /></td></tr>
<tr class="separator:aabb4cae0c7ab29258874bca1bd4ae78f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3d5a314b5a0210545be02b9ce43ae9a"><td class="memTemplParams" colspan="2"><a id="af3d5a314b5a0210545be02b9ce43ae9a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:af3d5a314b5a0210545be02b9ce43ae9a"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>move_if_movable</b> (typename std::remove_reference&lt; T &gt;::type &amp;t, typename std::enable_if&lt;!std::is_move_constructible&lt; T &gt;::value &gt;::type *=0)</td></tr>
<tr class="separator:af3d5a314b5a0210545be02b9ce43ae9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe4073cf31aa07b1a2e3dd3f9027547c"><td class="memTemplParams" colspan="2"><a id="abe4073cf31aa07b1a2e3dd3f9027547c"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:abe4073cf31aa07b1a2e3dd3f9027547c"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>move_if_movable</b> (typename std::remove_reference&lt; T &gt;::type &amp;t, typename std::enable_if&lt; std::is_move_constructible&lt; T &gt;::value &gt;::type *=0)</td></tr>
<tr class="separator:abe4073cf31aa07b1a2e3dd3f9027547c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ddc7f8f84c4a18e50db42afe86a6608"><td class="memTemplParams" colspan="2"><a id="a7ddc7f8f84c4a18e50db42afe86a6608"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7ddc7f8f84c4a18e50db42afe86a6608"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>move_if_movable_rvalue</b> (typename std::remove_reference&lt; T &gt;::type &amp;t, typename std::enable_if&lt; !std::is_move_constructible&lt; T &gt;::value||!std::is_rvalue_reference&lt; T &gt;::value &gt;::type *=0)</td></tr>
<tr class="separator:a7ddc7f8f84c4a18e50db42afe86a6608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad74c7e5d2a62e0a30ae37efaef12c655"><td class="memTemplParams" colspan="2"><a id="ad74c7e5d2a62e0a30ae37efaef12c655"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad74c7e5d2a62e0a30ae37efaef12c655"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>move_if_movable_rvalue</b> (typename std::remove_reference&lt; T &gt;::type &amp;t, typename std::enable_if&lt; std::is_move_constructible&lt; T &gt;::value &amp;&amp;std::is_rvalue_reference&lt; T &gt;::value &gt;::type *=0)</td></tr>
<tr class="separator:ad74c7e5d2a62e0a30ae37efaef12c655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea51d711868112b6294294ceaf602d79"><td class="memTemplParams" colspan="2"><a id="aea51d711868112b6294294ceaf602d79"></a>
template&lt;int i, typename ... T&gt; </td></tr>
<tr class="memitem:aea51d711868112b6294294ceaf602d79"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtpie_1_1pipelining_1_1bits_1_1get__impl.html">bits::get_impl</a>&lt; i, T... &gt;::type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (<a class="el" href="classtpie_1_1pipelining_1_1container.html">container</a>&lt; T... &gt; &amp;c)</td></tr>
<tr class="separator:aea51d711868112b6294294ceaf602d79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d02159e54347ec66646344ece564b00"><td class="memTemplParams" colspan="2"><a id="a7d02159e54347ec66646344ece564b00"></a>
template&lt;int i, typename ... T&gt; </td></tr>
<tr class="memitem:a7d02159e54347ec66646344ece564b00"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="structtpie_1_1pipelining_1_1bits_1_1get__impl.html">bits::get_impl</a>&lt; i, T... &gt;::type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (const <a class="el" href="classtpie_1_1pipelining_1_1container.html">container</a>&lt; T... &gt; &amp;c)</td></tr>
<tr class="separator:a7d02159e54347ec66646344ece564b00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a947c7126b4648731a2fe949f2e58eaff"><td class="memTemplParams" colspan="2"><a id="a947c7126b4648731a2fe949f2e58eaff"></a>
template&lt;typename F , typename ... T1, typename ... T2&gt; </td></tr>
<tr class="memitem:a947c7126b4648731a2fe949f2e58eaff"><td class="memTemplItemLeft" align="right" valign="top">F&#160;</td><td class="memTemplItemRight" valign="bottom"><b>container_construct</b> (<a class="el" href="classtpie_1_1pipelining_1_1container.html">container</a>&lt; T1... &gt; &amp;cont, T2 &amp;&amp;... a)</td></tr>
<tr class="separator:a947c7126b4648731a2fe949f2e58eaff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2589f8df4d959cd2241c574c32a8e313"><td class="memTemplParams" colspan="2"><a id="a2589f8df4d959cd2241c574c32a8e313"></a>
template&lt;typename F , typename ... T1, typename ... T2&gt; </td></tr>
<tr class="memitem:a2589f8df4d959cd2241c574c32a8e313"><td class="memTemplItemLeft" align="right" valign="top">F&#160;</td><td class="memTemplItemRight" valign="bottom"><b>container_construct_copy</b> (<a class="el" href="classtpie_1_1pipelining_1_1container.html">container</a>&lt; T1... &gt; &amp;cont, T2 &amp;&amp;... a)</td></tr>
<tr class="separator:a2589f8df4d959cd2241c574c32a8e313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace14c4444c346a9d0fb1c8b6367dfbdd"><td class="memTemplParams" colspan="2"><a id="ace14c4444c346a9d0fb1c8b6367dfbdd"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ace14c4444c346a9d0fb1c8b6367dfbdd"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>any_cast</b> (const <a class="el" href="classtpie_1_1pipelining_1_1any__noncopyable.html">any_noncopyable</a> &amp;a)</td></tr>
<tr class="separator:ace14c4444c346a9d0fb1c8b6367dfbdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dd39c0fd167c2058aa01a402a13dd53"><td class="memTemplParams" colspan="2"><a id="a5dd39c0fd167c2058aa01a402a13dd53"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5dd39c0fd167c2058aa01a402a13dd53"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>any_cast</b> (<a class="el" href="classtpie_1_1pipelining_1_1any__noncopyable.html">any_noncopyable</a> &amp;a)</td></tr>
<tr class="separator:a5dd39c0fd167c2058aa01a402a13dd53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86a9df41b0eb775d4ccb9dc4bcba064a"><td class="memItemLeft" align="right" valign="top"><a id="a86a9df41b0eb775d4ccb9dc4bcba064a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>swap</b> (<a class="el" href="classtpie_1_1pipelining_1_1any__noncopyable.html">any_noncopyable</a> &amp;l, <a class="el" href="classtpie_1_1pipelining_1_1any__noncopyable.html">any_noncopyable</a> &amp;r)</td></tr>
<tr class="separator:a86a9df41b0eb775d4ccb9dc4bcba064a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec8021f755b4600d49276267552aa32b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aec8021f755b4600d49276267552aa32b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1pipelining_1_1pipe__begin.html">pipe_begin</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1factory.html">factory</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1input__t.html">bits::input_t</a>, <a class="el" href="classtpie_1_1file__stream.html">file_stream</a>&lt; T &gt; &amp;, <a class="el" href="classtpie_1_1flags.html">stream_options</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetpie_1_1pipelining.html#aec8021f755b4600d49276267552aa32b">input</a> (<a class="el" href="classtpie_1_1file__stream.html">file_stream</a>&lt; T &gt; &amp;fs, <a class="el" href="classtpie_1_1flags.html">stream_options</a> options=<a class="el" href="classtpie_1_1flags.html">stream_options</a>())</td></tr>
<tr class="memdesc:aec8021f755b4600d49276267552aa32b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pipelining nodes that pushes the contents of the given file stream to the next node in the pipeline.  <a href="namespacetpie_1_1pipelining.html#aec8021f755b4600d49276267552aa32b">More...</a><br /></td></tr>
<tr class="separator:aec8021f755b4600d49276267552aa32b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42fc47efe0300f10914a02621970b8f8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a42fc47efe0300f10914a02621970b8f8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1pipelining_1_1pullpipe__begin.html">pullpipe_begin</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1termfactory.html">termfactory</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1pull__input__t.html">bits::pull_input_t</a>&lt; T &gt;, <a class="el" href="classtpie_1_1file__stream.html">file_stream</a>&lt; T &gt; &amp;, <a class="el" href="classtpie_1_1flags.html">stream_options</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetpie_1_1pipelining.html#a42fc47efe0300f10914a02621970b8f8">pull_input</a> (<a class="el" href="classtpie_1_1file__stream.html">file_stream</a>&lt; T &gt; &amp;fs, <a class="el" href="classtpie_1_1flags.html">stream_options</a> options=<a class="el" href="classtpie_1_1flags.html">stream_options</a>())</td></tr>
<tr class="memdesc:a42fc47efe0300f10914a02621970b8f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pipelining pull-node that reads items from the given <a class="el" href="classtpie_1_1file__stream.html" title="Compressed stream.">file_stream</a>.  <a href="namespacetpie_1_1pipelining.html#a42fc47efe0300f10914a02621970b8f8">More...</a><br /></td></tr>
<tr class="separator:a42fc47efe0300f10914a02621970b8f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d615413e1c535dec77cd44a4236f9f7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4d615413e1c535dec77cd44a4236f9f7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1pipelining_1_1pullpipe__begin.html">pullpipe_begin</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1termfactory.html">termfactory</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1pull__reverse__input__t.html">bits::pull_reverse_input_t</a>&lt; T &gt;, <a class="el" href="classtpie_1_1file__stream.html">file_stream</a>&lt; T &gt; &amp;, <a class="el" href="classtpie_1_1flags.html">stream_options</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetpie_1_1pipelining.html#a4d615413e1c535dec77cd44a4236f9f7">pull_reverse_input</a> (<a class="el" href="classtpie_1_1file__stream.html">file_stream</a>&lt; T &gt; &amp;fs, <a class="el" href="classtpie_1_1flags.html">stream_options</a> options=<a class="el" href="classtpie_1_1flags.html">stream_options</a>())</td></tr>
<tr class="memdesc:a4d615413e1c535dec77cd44a4236f9f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pipelining pull-node that reads items in reverse order from the given <a class="el" href="classtpie_1_1file__stream.html" title="Compressed stream.">file_stream</a>.  <a href="namespacetpie_1_1pipelining.html#a4d615413e1c535dec77cd44a4236f9f7">More...</a><br /></td></tr>
<tr class="separator:a4d615413e1c535dec77cd44a4236f9f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a176499840776c0e0ab867d510cde199f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a176499840776c0e0ab867d510cde199f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1pipelining_1_1pullpipe__begin.html">pullpipe_begin</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1termfactory.html">termfactory</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1named__pull__input__t.html">bits::named_pull_input_t</a>&lt; T &gt;, std::string &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetpie_1_1pipelining.html#a176499840776c0e0ab867d510cde199f">named_pull_input</a> (std::string path)</td></tr>
<tr class="memdesc:a176499840776c0e0ab867d510cde199f"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pipelining pull-node that reads items from the given file path.  <a href="namespacetpie_1_1pipelining.html#a176499840776c0e0ab867d510cde199f">More...</a><br /></td></tr>
<tr class="separator:a176499840776c0e0ab867d510cde199f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1ecad88e2e14856799abf63e36abd4b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa1ecad88e2e14856799abf63e36abd4b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1pipelining_1_1pipe__end.html">pipe_end</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1termfactory.html">termfactory</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1output__t.html">bits::output_t</a>&lt; T &gt;, <a class="el" href="classtpie_1_1file__stream.html">file_stream</a>&lt; T &gt; &amp; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetpie_1_1pipelining.html#aa1ecad88e2e14856799abf63e36abd4b">output</a> (<a class="el" href="classtpie_1_1file__stream.html">file_stream</a>&lt; T &gt; &amp;fs)</td></tr>
<tr class="memdesc:aa1ecad88e2e14856799abf63e36abd4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pipelining node that writes the pushed items to a file stream.  <a href="namespacetpie_1_1pipelining.html#aa1ecad88e2e14856799abf63e36abd4b">More...</a><br /></td></tr>
<tr class="separator:aa1ecad88e2e14856799abf63e36abd4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1da9316b9a840e71cb1744e3c3957323"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1da9316b9a840e71cb1744e3c3957323"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1pipelining_1_1pipe__end.html">pipe_end</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1termfactory.html">termfactory</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1named__output__t.html">bits::named_output_t</a>&lt; T &gt;, std::string &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetpie_1_1pipelining.html#a1da9316b9a840e71cb1744e3c3957323">named_output</a> (std::string path)</td></tr>
<tr class="memdesc:a1da9316b9a840e71cb1744e3c3957323"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pipelining node that writes the pushed items to a named file stream.  <a href="namespacetpie_1_1pipelining.html#a1da9316b9a840e71cb1744e3c3957323">More...</a><br /></td></tr>
<tr class="separator:a1da9316b9a840e71cb1744e3c3957323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69c66039bc8f2272069a16810f8209e4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a69c66039bc8f2272069a16810f8209e4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1pipelining_1_1pullpipe__end.html">pullpipe_end</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1factory.html">factory</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1pull__output__t.html">bits::pull_output_t</a>, <a class="el" href="classtpie_1_1file__stream.html">file_stream</a>&lt; T &gt; &amp; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetpie_1_1pipelining.html#a69c66039bc8f2272069a16810f8209e4">pull_output</a> (<a class="el" href="classtpie_1_1file__stream.html">file_stream</a>&lt; T &gt; &amp;fs)</td></tr>
<tr class="memdesc:a69c66039bc8f2272069a16810f8209e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pull-pipe node that writes the pulled items to a file stream.  <a href="namespacetpie_1_1pipelining.html#a69c66039bc8f2272069a16810f8209e4">More...</a><br /></td></tr>
<tr class="separator:a69c66039bc8f2272069a16810f8209e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6988cf4e74c17c45538ad9461a9de102"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6988cf4e74c17c45538ad9461a9de102"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1pipelining_1_1pipe__middle.html">pipe_middle</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1tfactory.html">tfactory</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1tee__t.html">bits::tee_t</a>, <a class="el" href="classtpie_1_1pipelining_1_1Args.html">Args</a>&lt; typename T::item_type &gt;, T &amp; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetpie_1_1pipelining.html#a6988cf4e74c17c45538ad9461a9de102">tee</a> (T &amp;fs)</td></tr>
<tr class="memdesc:a6988cf4e74c17c45538ad9461a9de102"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pipelining node that writes the pushed to a file stream and then pushes the items to the next node.  <a href="namespacetpie_1_1pipelining.html#a6988cf4e74c17c45538ad9461a9de102">More...</a><br /></td></tr>
<tr class="separator:a6988cf4e74c17c45538ad9461a9de102"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94273e51dba887f090f60a87f0a77c94"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a94273e51dba887f090f60a87f0a77c94"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1pipelining_1_1pullpipe__middle.html">pullpipe_middle</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1tfactory.html">tfactory</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1pull__tee__t.html">bits::pull_tee_t</a>, <a class="el" href="classtpie_1_1pipelining_1_1Args.html">Args</a>&lt; typename T::item_type &gt;, T &amp; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetpie_1_1pipelining.html#a94273e51dba887f090f60a87f0a77c94">pull_tee</a> (T &amp;fs)</td></tr>
<tr class="memdesc:a94273e51dba887f090f60a87f0a77c94"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pull-pipe node that when pulled from will pull from its source, write its item to disk and then return the item.  <a href="namespacetpie_1_1pipelining.html#a94273e51dba887f090f60a87f0a77c94">More...</a><br /></td></tr>
<tr class="separator:a94273e51dba887f090f60a87f0a77c94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a452f18cf33bcbcf635fc7063a0806031"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a452f18cf33bcbcf635fc7063a0806031"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1pipelining_1_1pipe__middle.html">pipe_middle</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1tfactory.html">tfactory</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1filter__t.html">bits::filter_t</a>, <a class="el" href="classtpie_1_1pipelining_1_1Args.html">Args</a>&lt; F &gt;, F &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetpie_1_1pipelining.html#a452f18cf33bcbcf635fc7063a0806031">filter</a> (const F &amp;functor)</td></tr>
<tr class="memdesc:a452f18cf33bcbcf635fc7063a0806031"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pipelining node that keeps only elements where functor evaluates to true.  <a href="namespacetpie_1_1pipelining.html#a452f18cf33bcbcf635fc7063a0806031">More...</a><br /></td></tr>
<tr class="separator:a452f18cf33bcbcf635fc7063a0806031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97aad0575703e1809b1edfecbd0a3e8a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1pipelining_1_1pipe__middle.html">pipe_middle</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1factory.html">factory</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1Forwarder.html">bits::Forwarder</a>, std::vector&lt; std::pair&lt; std::string, <a class="el" href="classtpie_1_1pipelining_1_1any__noncopyable.html">any_noncopyable</a> &gt; &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetpie_1_1pipelining.html#a97aad0575703e1809b1edfecbd0a3e8a">forwarder</a> (std::vector&lt; std::pair&lt; std::string, <a class="el" href="classtpie_1_1pipelining_1_1any__noncopyable.html">any_noncopyable</a> &gt; &gt; items)</td></tr>
<tr class="memdesc:a97aad0575703e1809b1edfecbd0a3e8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pipelining node that will forward values on prepare, and.  <a href="namespacetpie_1_1pipelining.html#a97aad0575703e1809b1edfecbd0a3e8a">More...</a><br /></td></tr>
<tr class="separator:a97aad0575703e1809b1edfecbd0a3e8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac237f521b990f35755cecf90feab050d"><td class="memTemplParams" colspan="2">template&lt;typename VT &gt; </td></tr>
<tr class="memitem:ac237f521b990f35755cecf90feab050d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1pipelining_1_1pipe__middle.html">pipe_middle</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1factory.html">factory</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1Forwarder.html">bits::Forwarder</a>, std::vector&lt; std::pair&lt; std::string, <a class="el" href="classtpie_1_1pipelining_1_1any__noncopyable.html">any_noncopyable</a> &gt; &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetpie_1_1pipelining.html#ac237f521b990f35755cecf90feab050d">forwarder</a> (std::string name, VT value)</td></tr>
<tr class="memdesc:ac237f521b990f35755cecf90feab050d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pipelining node that will forward value on prepare, and.  <a href="namespacetpie_1_1pipelining.html#ac237f521b990f35755cecf90feab050d">More...</a><br /></td></tr>
<tr class="separator:ac237f521b990f35755cecf90feab050d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b4481ce6224c2a4be88c2cc89864da0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1pipelining_1_1pipe__middle.html">pipe_middle</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1factory.html">factory</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1ostream__logger__t.html">bits::ostream_logger_t</a>, std::ostream &amp; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetpie_1_1pipelining.html#a6b4481ce6224c2a4be88c2cc89864da0">cout_logger</a> ()</td></tr>
<tr class="memdesc:a6b4481ce6224c2a4be88c2cc89864da0"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pipelining node that writes items to standard out and then pushes them to the next node.  <a href="namespacetpie_1_1pipelining.html#a6b4481ce6224c2a4be88c2cc89864da0">More...</a><br /></td></tr>
<tr class="separator:a6b4481ce6224c2a4be88c2cc89864da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f77702baa0872e01291bbbb3362a447"><td class="memTemplParams" colspan="2">template&lt;typename fact_t &gt; </td></tr>
<tr class="memitem:a8f77702baa0872e01291bbbb3362a447"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1pipelining_1_1pipe__middle.html">pipe_middle</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1tfactory.html">tfactory</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1fork__t.html">bits::fork_t</a>, <a class="el" href="classtpie_1_1pipelining_1_1Args.html">Args</a>&lt; fact_t &gt;, fact_t &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetpie_1_1pipelining.html#a8f77702baa0872e01291bbbb3362a447">fork</a> (<a class="el" href="classtpie_1_1pipelining_1_1pipe__end.html">pipe_end</a>&lt; fact_t &gt; to)</td></tr>
<tr class="memdesc:a8f77702baa0872e01291bbbb3362a447"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a fork pipe node.  <a href="namespacetpie_1_1pipelining.html#a8f77702baa0872e01291bbbb3362a447">More...</a><br /></td></tr>
<tr class="separator:a8f77702baa0872e01291bbbb3362a447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d1f42a8cf73450e188ce23400ca2469"><td class="memTemplParams" colspan="2">template&lt;typename dest_fact_t &gt; </td></tr>
<tr class="memitem:a6d1f42a8cf73450e188ce23400ca2469"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1pipelining_1_1pullpipe__middle.html">pullpipe_middle</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1tfactory.html">tfactory</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1pull__fork__t.html">bits::pull_fork_t</a>, <a class="el" href="classtpie_1_1pipelining_1_1Args.html">Args</a>&lt; dest_fact_t &gt;, dest_fact_t &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetpie_1_1pipelining.html#a6d1f42a8cf73450e188ce23400ca2469">pull_fork</a> (dest_fact_t dest_fact)</td></tr>
<tr class="memdesc:a6d1f42a8cf73450e188ce23400ca2469"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pulling fork pipe node.  <a href="namespacetpie_1_1pipelining.html#a6d1f42a8cf73450e188ce23400ca2469">More...</a><br /></td></tr>
<tr class="separator:a6d1f42a8cf73450e188ce23400ca2469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a483dc27681b8a8c37b38e4fca54ee7"><td class="memTemplParams" colspan="2">template&lt;typename fact_t &gt; </td></tr>
<tr class="memitem:a0a483dc27681b8a8c37b38e4fca54ee7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1pipelining_1_1pipe__middle.html">pipe_middle</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1tfactory.html">tfactory</a>&lt; <a class="el" href="structtpie_1_1pipelining_1_1bits_1_1unzip__t.html">bits::unzip_t</a>, <a class="el" href="classtpie_1_1pipelining_1_1Args.html">Args</a>&lt; fact_t &gt;, fact_t &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetpie_1_1pipelining.html#a0a483dc27681b8a8c37b38e4fca54ee7">unzip</a> (<a class="el" href="classtpie_1_1pipelining_1_1pipe__end.html">pipe_end</a>&lt; fact_t &gt; to)</td></tr>
<tr class="memdesc:a0a483dc27681b8a8c37b38e4fca54ee7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create unzip pipe node.  <a href="namespacetpie_1_1pipelining.html#a0a483dc27681b8a8c37b38e4fca54ee7">More...</a><br /></td></tr>
<tr class="separator:a0a483dc27681b8a8c37b38e4fca54ee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad647b0fea511df644718470b27740c00"><td class="memTemplParams" colspan="2">template&lt;typename fact_t &gt; </td></tr>
<tr class="memitem:ad647b0fea511df644718470b27740c00"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1pipelining_1_1pipe__middle.html">pipe_middle</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1tfactory.html">tfactory</a>&lt; <a class="el" href="structtpie_1_1pipelining_1_1bits_1_1zip__t.html">bits::zip_t</a>, <a class="el" href="classtpie_1_1pipelining_1_1Args.html">Args</a>&lt; fact_t &gt;, fact_t &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetpie_1_1pipelining.html#ad647b0fea511df644718470b27740c00">zip</a> (<a class="el" href="classtpie_1_1pipelining_1_1pullpipe__begin.html">pullpipe_begin</a>&lt; fact_t &gt; from)</td></tr>
<tr class="memdesc:ad647b0fea511df644718470b27740c00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a zip pipe node.  <a href="namespacetpie_1_1pipelining.html#ad647b0fea511df644718470b27740c00">More...</a><br /></td></tr>
<tr class="separator:ad647b0fea511df644718470b27740c00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77c270323d5db9828f2f123238ef552b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a77c270323d5db9828f2f123238ef552b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1pipelining_1_1pipe__end.html">pipe_end</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1termfactory.html">termfactory</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1null__sink__t.html">bits::null_sink_t</a>&lt; T &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetpie_1_1pipelining.html#a77c270323d5db9828f2f123238ef552b">null_sink</a> ()</td></tr>
<tr class="memdesc:a77c270323d5db9828f2f123238ef552b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a dummy end pipe node.  <a href="namespacetpie_1_1pipelining.html#a77c270323d5db9828f2f123238ef552b">More...</a><br /></td></tr>
<tr class="separator:a77c270323d5db9828f2f123238ef552b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8f709136c57b612cf9336b44d3e6ff1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac8f709136c57b612cf9336b44d3e6ff1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1pipelining_1_1pullpipe__begin.html">pullpipe_begin</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1termfactory.html">termfactory</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1zero__source__t.html">bits::zero_source_t</a>&lt; T &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetpie_1_1pipelining.html#ac8f709136c57b612cf9336b44d3e6ff1">zero_source</a> ()</td></tr>
<tr class="memdesc:ac8f709136c57b612cf9336b44d3e6ff1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a dummy pull begin pipe node.  <a href="namespacetpie_1_1pipelining.html#ac8f709136c57b612cf9336b44d3e6ff1">More...</a><br /></td></tr>
<tr class="separator:ac8f709136c57b612cf9336b44d3e6ff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfc2c36cb05728052775f202db00154b"><td class="memTemplParams" colspan="2"><a id="adfc2c36cb05728052775f202db00154b"></a>
template&lt;template&lt; typename dest_t &gt; class Fact, typename... T&gt; </td></tr>
<tr class="memitem:adfc2c36cb05728052775f202db00154b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1pipelining_1_1pipe__begin.html">pipe_begin</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1factory.html">factory</a>&lt; Fact, T... &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_pipe_begin</b> (T... t)</td></tr>
<tr class="separator:adfc2c36cb05728052775f202db00154b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee5e17775f74c0cc87d0f34595430809"><td class="memTemplParams" colspan="2"><a id="aee5e17775f74c0cc87d0f34595430809"></a>
template&lt;template&lt; typename dest_t &gt; class Fact, typename... T&gt; </td></tr>
<tr class="memitem:aee5e17775f74c0cc87d0f34595430809"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1pipelining_1_1pipe__middle.html">pipe_middle</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1factory.html">factory</a>&lt; Fact, T... &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_pipe_middle</b> (T... t)</td></tr>
<tr class="separator:aee5e17775f74c0cc87d0f34595430809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d8beb975e20ff721f3890be42f9ed76"><td class="memTemplParams" colspan="2"><a id="a3d8beb975e20ff721f3890be42f9ed76"></a>
template&lt;typename Fact , typename... T&gt; </td></tr>
<tr class="memitem:a3d8beb975e20ff721f3890be42f9ed76"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1pipelining_1_1pipe__end.html">pipe_end</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1termfactory.html">termfactory</a>&lt; Fact, T... &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>make_pipe_end</b> (T ... t)</td></tr>
<tr class="separator:a3d8beb975e20ff721f3890be42f9ed76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc8ae3fedd9d93c5d942e1b1f110f2e9"><td class="memTemplParams" colspan="2">template&lt;typename IT &gt; </td></tr>
<tr class="memitem:adc8ae3fedd9d93c5d942e1b1f110f2e9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1pipelining_1_1pullpipe__begin.html">pullpipe_begin</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1termfactory.html">termfactory</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1pull__input__iterator__t.html">bits::pull_input_iterator_t</a>&lt; IT &gt;, IT, IT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetpie_1_1pipelining.html#adc8ae3fedd9d93c5d942e1b1f110f2e9">pull_input_iterator</a> (IT begin, IT end)</td></tr>
<tr class="memdesc:adc8ae3fedd9d93c5d942e1b1f110f2e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pull-pipe that returns items in the range given by two iterators.  <a href="namespacetpie_1_1pipelining.html#adc8ae3fedd9d93c5d942e1b1f110f2e9">More...</a><br /></td></tr>
<tr class="separator:adc8ae3fedd9d93c5d942e1b1f110f2e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ac8c3ceb431fe3cd083fbd20cf21a6e"><td class="memTemplParams" colspan="2">template&lt;typename IT &gt; </td></tr>
<tr class="memitem:a3ac8c3ceb431fe3cd083fbd20cf21a6e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1pipelining_1_1pipe__begin.html">pipe_begin</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1tfactory.html">tfactory</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1push__input__iterator__t.html">bits::push_input_iterator_t</a>, <a class="el" href="classtpie_1_1pipelining_1_1Args.html">Args</a>&lt; IT &gt;, IT, IT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetpie_1_1pipelining.html#a3ac8c3ceb431fe3cd083fbd20cf21a6e">push_input_iterator</a> (IT begin, IT end)</td></tr>
<tr class="memdesc:a3ac8c3ceb431fe3cd083fbd20cf21a6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pipelining node that pushes the items in the range given by two iterators.  <a href="namespacetpie_1_1pipelining.html#a3ac8c3ceb431fe3cd083fbd20cf21a6e">More...</a><br /></td></tr>
<tr class="separator:a3ac8c3ceb431fe3cd083fbd20cf21a6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af20c4dde69b51b38a3113dd02488fc31"><td class="memTemplParams" colspan="2">template&lt;typename IT &gt; </td></tr>
<tr class="memitem:af20c4dde69b51b38a3113dd02488fc31"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1pipelining_1_1pipe__end.html">pipe_end</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1termfactory.html">termfactory</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1push__output__iterator__t.html">bits::push_output_iterator_t</a>&lt; IT &gt;, IT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetpie_1_1pipelining.html#af20c4dde69b51b38a3113dd02488fc31">push_output_iterator</a> (IT to)</td></tr>
<tr class="memdesc:af20c4dde69b51b38a3113dd02488fc31"><td class="mdescLeft">&#160;</td><td class="mdescRight">A node that writes its given items to the destination pointed to by the given iterator.  <a href="namespacetpie_1_1pipelining.html#af20c4dde69b51b38a3113dd02488fc31">More...</a><br /></td></tr>
<tr class="separator:af20c4dde69b51b38a3113dd02488fc31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addd3d020dacea6455669b8cf01ddb0a9"><td class="memTemplParams" colspan="2">template&lt;typename Item , typename IT &gt; </td></tr>
<tr class="memitem:addd3d020dacea6455669b8cf01ddb0a9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1pipelining_1_1pipe__end.html">pipe_end</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1termfactory.html">termfactory</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1push__output__iterator__t.html">bits::push_output_iterator_t</a>&lt; IT, Item &gt;, IT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetpie_1_1pipelining.html#addd3d020dacea6455669b8cf01ddb0a9">typed_push_output_iterator</a> (IT to)</td></tr>
<tr class="memdesc:addd3d020dacea6455669b8cf01ddb0a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">A node that writes its given items to the destination pointed to by the given iterator.  <a href="namespacetpie_1_1pipelining.html#addd3d020dacea6455669b8cf01ddb0a9">More...</a><br /></td></tr>
<tr class="separator:addd3d020dacea6455669b8cf01ddb0a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca26fb8ab96bc2f381574504caa75e52"><td class="memTemplParams" colspan="2">template&lt;typename IT &gt; </td></tr>
<tr class="memitem:aca26fb8ab96bc2f381574504caa75e52"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1pipelining_1_1pullpipe__end.html">pullpipe_end</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1tfactory.html">tfactory</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1pull__output__iterator__t.html">bits::pull_output_iterator_t</a>, <a class="el" href="classtpie_1_1pipelining_1_1Args.html">Args</a>&lt; IT &gt;, IT &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetpie_1_1pipelining.html#aca26fb8ab96bc2f381574504caa75e52">pull_output_iterator</a> (IT to)</td></tr>
<tr class="memdesc:aca26fb8ab96bc2f381574504caa75e52"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pull-pipe node that writes its given items to the destination pointed to by the given iterator.  <a href="namespacetpie_1_1pipelining.html#aca26fb8ab96bc2f381574504caa75e52">More...</a><br /></td></tr>
<tr class="separator:aca26fb8ab96bc2f381574504caa75e52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5833caaf7bbc9286f64656e44ec78eca"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a5833caaf7bbc9286f64656e44ec78eca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1pipelining_1_1pipe__middle.html">pipe_middle</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1tfactory.html">tfactory</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1preparer__t.html">bits::preparer_t</a>, <a class="el" href="classtpie_1_1pipelining_1_1Args.html">Args</a>&lt; F &gt;, F &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetpie_1_1pipelining.html#a5833caaf7bbc9286f64656e44ec78eca">preparer</a> (const F &amp;functor)</td></tr>
<tr class="memdesc:a5833caaf7bbc9286f64656e44ec78eca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create preparer callback identity pipe node.  <a href="namespacetpie_1_1pipelining.html#a5833caaf7bbc9286f64656e44ec78eca">More...</a><br /></td></tr>
<tr class="separator:a5833caaf7bbc9286f64656e44ec78eca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e9fef0b1bbd33a4ea0ee45fe7887811"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a6e9fef0b1bbd33a4ea0ee45fe7887811"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1pipelining_1_1pipe__middle.html">pipe_middle</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1tfactory.html">tfactory</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1propagater__t.html">bits::propagater_t</a>, <a class="el" href="classtpie_1_1pipelining_1_1Args.html">Args</a>&lt; F &gt;, F &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetpie_1_1pipelining.html#a6e9fef0b1bbd33a4ea0ee45fe7887811">propagater</a> (const F &amp;functor)</td></tr>
<tr class="memdesc:a6e9fef0b1bbd33a4ea0ee45fe7887811"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create propagate callback identity pipe node.  <a href="namespacetpie_1_1pipelining.html#a6e9fef0b1bbd33a4ea0ee45fe7887811">More...</a><br /></td></tr>
<tr class="separator:a6e9fef0b1bbd33a4ea0ee45fe7887811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad25e30e578fb780f9fff601b94fed33b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad25e30e578fb780f9fff601b94fed33b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1pipelining_1_1pipe__middle.html">pipe_middle</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1tfactory.html">tfactory</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1item__type__t.html">bits::item_type_t</a>, <a class="el" href="classtpie_1_1pipelining_1_1Args.html">Args</a>&lt; T &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetpie_1_1pipelining.html#ad25e30e578fb780f9fff601b94fed33b">item_type</a> ()</td></tr>
<tr class="memdesc:ad25e30e578fb780f9fff601b94fed33b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create item type defining identity pipe node.  <a href="namespacetpie_1_1pipelining.html#ad25e30e578fb780f9fff601b94fed33b">More...</a><br /></td></tr>
<tr class="separator:ad25e30e578fb780f9fff601b94fed33b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b16ca3ea552cf3bffabaeec5ebd5be7"><td class="memTemplParams" colspan="2">template&lt;typename fact_t &gt; </td></tr>
<tr class="memitem:a2b16ca3ea552cf3bffabaeec5ebd5be7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1pipelining_1_1pipe__begin.html">pipe_begin</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1tfactory.html">tfactory</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1pull__source__t.html">bits::pull_source_t</a>, <a class="el" href="classtpie_1_1pipelining_1_1Args.html">Args</a>&lt; fact_t &gt;, fact_t &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetpie_1_1pipelining.html#a2b16ca3ea552cf3bffabaeec5ebd5be7">pull_source</a> (<a class="el" href="classtpie_1_1pipelining_1_1pullpipe__begin.html">pullpipe_begin</a>&lt; fact_t &gt; from)</td></tr>
<tr class="memdesc:a2b16ca3ea552cf3bffabaeec5ebd5be7"><td class="mdescLeft">&#160;</td><td class="mdescRight">A node that pulls items from source and push them into dest.  <a href="namespacetpie_1_1pipelining.html#a2b16ca3ea552cf3bffabaeec5ebd5be7">More...</a><br /></td></tr>
<tr class="separator:a2b16ca3ea552cf3bffabaeec5ebd5be7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8c0664c8f94f9666def0d4c444fc1dd"><td class="memTemplParams" colspan="2">template&lt;typename equal_t &gt; </td></tr>
<tr class="memitem:ad8c0664c8f94f9666def0d4c444fc1dd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1pipelining_1_1pipe__middle.html">pipe_middle</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1tfactory.html">tfactory</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1unique__t.html">bits::unique_t</a>, <a class="el" href="classtpie_1_1pipelining_1_1Args.html">Args</a>&lt; equal_t &gt;, equal_t &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetpie_1_1pipelining.html#ad8c0664c8f94f9666def0d4c444fc1dd">unique</a> (equal_t equal)</td></tr>
<tr class="memdesc:ad8c0664c8f94f9666def0d4c444fc1dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Filter consecutive duplicates out.  <a href="namespacetpie_1_1pipelining.html#ad8c0664c8f94f9666def0d4c444fc1dd">More...</a><br /></td></tr>
<tr class="separator:ad8c0664c8f94f9666def0d4c444fc1dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40938c59d6956699ee5b6c322db70476"><td class="memTemplParams" colspan="2">template&lt;typename equal_t &gt; </td></tr>
<tr class="memitem:a40938c59d6956699ee5b6c322db70476"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1pipelining_1_1pullpipe__middle.html">pullpipe_middle</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1tfactory.html">tfactory</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1pull__unique__t.html">bits::pull_unique_t</a>, <a class="el" href="classtpie_1_1pipelining_1_1Args.html">Args</a>&lt; equal_t &gt;, equal_t &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetpie_1_1pipelining.html#a40938c59d6956699ee5b6c322db70476">pull_unique</a> (equal_t equal)</td></tr>
<tr class="memdesc:a40938c59d6956699ee5b6c322db70476"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pull version of unique.  <a href="namespacetpie_1_1pipelining.html#a40938c59d6956699ee5b6c322db70476">More...</a><br /></td></tr>
<tr class="separator:a40938c59d6956699ee5b6c322db70476"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15bfa65d8eab87a59e638f883d441ad4"><td class="memTemplParams" colspan="2">template&lt;typename F , typename  = typename std::enable_if&lt;bits::has_argument_type&lt;F&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a15bfa65d8eab87a59e638f883d441ad4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1pipelining_1_1pipe__middle.html">pipe_middle</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1tfactory.html">tfactory</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1map__t.html">bits::map_t</a>, <a class="el" href="classtpie_1_1pipelining_1_1Args.html">Args</a>&lt; F &gt;, F &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetpie_1_1pipelining.html#a15bfa65d8eab87a59e638f883d441ad4">map</a> (const F &amp;functor)</td></tr>
<tr class="memdesc:a15bfa65d8eab87a59e638f883d441ad4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pipelining nodes that applies to given functor to items in the stream.  <a href="namespacetpie_1_1pipelining.html#a15bfa65d8eab87a59e638f883d441ad4">More...</a><br /></td></tr>
<tr class="separator:a15bfa65d8eab87a59e638f883d441ad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23a1918feeb6bc34b49eacd1e34ebeaa"><td class="memTemplParams" colspan="2"><a id="a23a1918feeb6bc34b49eacd1e34ebeaa"></a>
template&lt;typename F , typename  = typename std::enable_if&lt;!bits::has_argument_type&lt;F&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a23a1918feeb6bc34b49eacd1e34ebeaa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1pipelining_1_1pipe__middle.html">pipe_middle</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1tfactory.html">tfactory</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1map__temp__t.html">bits::map_temp_t</a>, <a class="el" href="classtpie_1_1pipelining_1_1Args.html">Args</a>&lt; F &gt;, F &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>map</b> (const F &amp;functor)</td></tr>
<tr class="separator:a23a1918feeb6bc34b49eacd1e34ebeaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8b96db7849184635a360227410a7213"><td class="memTemplParams" colspan="2"><a id="ab8b96db7849184635a360227410a7213"></a>
template&lt;typename F &gt; </td></tr>
<tr class="memitem:ab8b96db7849184635a360227410a7213"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1pipelining_1_1pipe__end.html">pipe_end</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1termfactory.html">termfactory</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1map__sink__t.html">bits::map_sink_t</a>&lt; F &gt;, F &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>map_sink</b> (const F &amp;functor)</td></tr>
<tr class="separator:ab8b96db7849184635a360227410a7213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acab156e1a78016a3ed33a2d5d9b2b75c"><td class="memTemplParams" colspan="2"><a id="acab156e1a78016a3ed33a2d5d9b2b75c"></a>
template&lt;typename F &gt; </td></tr>
<tr class="memitem:acab156e1a78016a3ed33a2d5d9b2b75c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1pipelining_1_1pullpipe__middle.html">pullpipe_middle</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1tfactory.html">tfactory</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1pull__map__t.html">bits::pull_map_t</a>, <a class="el" href="classtpie_1_1pipelining_1_1Args.html">Args</a>&lt; F &gt;, F &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>pull_map</b> (const F &amp;functor)</td></tr>
<tr class="separator:acab156e1a78016a3ed33a2d5d9b2b75c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c3f9245bc9d962ebf02c81603ece124"><td class="memTemplParams" colspan="2">template&lt;typename pull_t &gt; </td></tr>
<tr class="memitem:a7c3f9245bc9d962ebf02c81603ece124"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1pipelining_1_1pipe__middle.html">pipe_middle</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1tfactory.html">tfactory</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1merge__t.html">bits::merge_t</a>, <a class="el" href="classtpie_1_1pipelining_1_1Args.html">Args</a>&lt; pull_t &gt;, pull_t &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetpie_1_1pipelining.html#a7c3f9245bc9d962ebf02c81603ece124">merge</a> (<a class="el" href="classtpie_1_1pipelining_1_1pullpipe__begin.html">pullpipe_begin</a>&lt; pull_t &gt; with)</td></tr>
<tr class="memdesc:a7c3f9245bc9d962ebf02c81603ece124"><td class="mdescLeft">&#160;</td><td class="mdescRight">A node that merges a pull pipeline into a push pipeline.  <a href="namespacetpie_1_1pipelining.html#a7c3f9245bc9d962ebf02c81603ece124">More...</a><br /></td></tr>
<tr class="separator:a7c3f9245bc9d962ebf02c81603ece124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d83cf3ca7b45eb58f9150b9d922eac6"><td class="memItemLeft" align="right" valign="top"><a id="a2d83cf3ca7b45eb58f9150b9d922eac6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TPIE_DECLARE_OPERATORS_FOR_FLAGS</b> (<a class="el" href="classtpie_1_1pipelining_1_1node.html#aec7deb6509a587b11cf1c6b2d4598553">node::PLOT</a>)</td></tr>
<tr class="separator:a2d83cf3ca7b45eb58f9150b9d922eac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbb8771be8163bb097137c027a02347a"><td class="memItemLeft" align="right" valign="top"><a id="adbb8771be8163bb097137c027a02347a"></a>
node_set&#160;</td><td class="memItemRight" valign="bottom"><b>make_node_set</b> ()</td></tr>
<tr class="separator:adbb8771be8163bb097137c027a02347a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24a50efe4be1c714302ac073d9666928"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a24a50efe4be1c714302ac073d9666928"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1pipelining_1_1pipe__middle.html">pipe_middle</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1factory.html">factory</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1linear__t.html">bits::linear_t</a>, T, T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetpie_1_1pipelining.html#a24a50efe4be1c714302ac073d9666928">linear</a> (T factor, T term)</td></tr>
<tr class="memdesc:a24a50efe4be1c714302ac073d9666928"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pipelining node that transforms the items by applying a linear function to them.  <a href="namespacetpie_1_1pipelining.html#a24a50efe4be1c714302ac073d9666928">More...</a><br /></td></tr>
<tr class="separator:a24a50efe4be1c714302ac073d9666928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8fb3e2643886d2db05b8e1ab217abb1"><td class="memTemplParams" colspan="2"><a id="ae8fb3e2643886d2db05b8e1ab217abb1"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae8fb3e2643886d2db05b8e1ab217abb1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1pipelining_1_1pipe__begin.html">pipe_begin</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1factory.html">factory</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1range__t.html">bits::range_t</a>, T, T, T &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>range</b> (T from, T to, T increment=1)</td></tr>
<tr class="separator:ae8fb3e2643886d2db05b8e1ab217abb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaba833e0ea7898df157671f9911e6676"><td class="memTemplParams" colspan="2">template&lt;typename fact_t , typename comp_t  = std::less&lt;&gt;&gt; </td></tr>
<tr class="memitem:aaba833e0ea7898df157671f9911e6676"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1pipelining_1_1pipe__middle.html">pipe_middle</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1tfactory.html">tfactory</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1ordered__merge__t.html">bits::ordered_merge_t</a>, <a class="el" href="classtpie_1_1pipelining_1_1Args.html">Args</a>&lt; fact_t, comp_t &gt;, fact_t, comp_t &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetpie_1_1pipelining.html#aaba833e0ea7898df157671f9911e6676">ordered_merge</a> (fact_t fact, comp_t comp=std::less&lt;&gt;())</td></tr>
<tr class="memdesc:aaba833e0ea7898df157671f9911e6676"><td class="mdescLeft">&#160;</td><td class="mdescRight">A node that merges a pull pipeline into a push pipeline.  <a href="namespacetpie_1_1pipelining.html#aaba833e0ea7898df157671f9911e6676">More...</a><br /></td></tr>
<tr class="separator:aaba833e0ea7898df157671f9911e6676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c894e9fba7cb73afb0a62d2d67d0237"><td class="memTemplParams" colspan="2">template&lt;typename fact_t &gt; </td></tr>
<tr class="memitem:a4c894e9fba7cb73afb0a62d2d67d0237"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1pipelining_1_1pipe__middle.html">pipe_middle</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1parallel__bits_1_1factory.html">parallel_bits::factory</a>&lt; fact_t &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetpie_1_1pipelining.html#a4c894e9fba7cb73afb0a62d2d67d0237">parallel</a> (<a class="el" href="classtpie_1_1pipelining_1_1pipe__middle.html">pipe_middle</a>&lt; fact_t &gt; &amp;&amp;fact, <a class="el" href="namespacetpie_1_1pipelining.html#a16a8744ad1f202f05bb32a2f60545ed4">maintain_order_type</a> maintainOrder, size_t numJobs, size_t bufSize=2048)</td></tr>
<tr class="memdesc:a4c894e9fba7cb73afb0a62d2d67d0237"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs a pipeline in multiple threads.  <a href="namespacetpie_1_1pipelining.html#a4c894e9fba7cb73afb0a62d2d67d0237">More...</a><br /></td></tr>
<tr class="separator:a4c894e9fba7cb73afb0a62d2d67d0237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7520734a419631cecaa49958c62bd204"><td class="memTemplParams" colspan="2">template&lt;typename fact_t &gt; </td></tr>
<tr class="memitem:a7520734a419631cecaa49958c62bd204"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1pipelining_1_1pipe__middle.html">pipe_middle</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1parallel__bits_1_1factory.html">parallel_bits::factory</a>&lt; fact_t &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetpie_1_1pipelining.html#a7520734a419631cecaa49958c62bd204">parallel</a> (<a class="el" href="classtpie_1_1pipelining_1_1pipe__middle.html">pipe_middle</a>&lt; fact_t &gt; &amp;&amp;fact, <a class="el" href="namespacetpie_1_1pipelining.html#a16a8744ad1f202f05bb32a2f60545ed4">maintain_order_type</a> maintainOrder=<a class="el" href="namespacetpie_1_1pipelining.html#a16a8744ad1f202f05bb32a2f60545ed4abf58a1a989c94ba7db61f23b21309b57">arbitrary_order</a>)</td></tr>
<tr class="memdesc:a7520734a419631cecaa49958c62bd204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs a pipeline in multiple threads, using the number of threads reported by <a class="el" href="namespacetpie.html#a18fbf567e45c8a656464a6777ae5996f" title="Return the number of job threads initialized by the job framework in init_job().">tpie::default_worker_count</a>.  <a href="namespacetpie_1_1pipelining.html#a7520734a419631cecaa49958c62bd204">More...</a><br /></td></tr>
<tr class="separator:a7520734a419631cecaa49958c62bd204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ed3df452a198254d78e53d9f1cf5f93"><td class="memTemplParams" colspan="2"><a id="a6ed3df452a198254d78e53d9f1cf5f93"></a>
template&lt;typename fact_t &gt; </td></tr>
<tr class="memitem:a6ed3df452a198254d78e53d9f1cf5f93"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1pipelining_1_1pipe__middle.html">pipe_middle</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1parallel__bits_1_1factory.html">parallel_bits::factory</a>&lt; fact_t &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>parallel</b> (<a class="el" href="classtpie_1_1pipelining_1_1pipe__middle.html">pipe_middle</a>&lt; fact_t &gt; &amp;&amp;fact, bool maintainOrder, size_t numJobs, size_t bufSize=2048)</td></tr>
<tr class="separator:a6ed3df452a198254d78e53d9f1cf5f93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57071170682bf7c2e273af313ea4457b"><td class="memTemplParams" colspan="2"><a id="a57071170682bf7c2e273af313ea4457b"></a>
template&lt;typename fact_t &gt; </td></tr>
<tr class="memitem:a57071170682bf7c2e273af313ea4457b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1pipelining_1_1pipe__middle.html">pipe_middle</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1parallel__bits_1_1factory.html">parallel_bits::factory</a>&lt; fact_t &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>parallel</b> (<a class="el" href="classtpie_1_1pipelining_1_1pipe__middle.html">pipe_middle</a>&lt; fact_t &gt; &amp;&amp;fact, bool maintainOrder)</td></tr>
<tr class="separator:a57071170682bf7c2e273af313ea4457b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8c0a94662f2d06e13f43273b6968053"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1pipelining_1_1pipe__begin.html">pipe_begin</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1factory.html">serialization_bits::input_factory</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetpie_1_1pipelining.html#af8c0a94662f2d06e13f43273b6968053">serialization_input</a> (<a class="el" href="classtpie_1_1serialization__reader.html">serialization_reader</a> &amp;rd)</td></tr>
<tr class="memdesc:af8c0a94662f2d06e13f43273b6968053"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pipelining node that reads items from a <a class="el" href="classtpie_1_1serialization__reader.html">serialization_reader</a>.  <a href="namespacetpie_1_1pipelining.html#af8c0a94662f2d06e13f43273b6968053">More...</a><br /></td></tr>
<tr class="separator:af8c0a94662f2d06e13f43273b6968053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14597d3a526e50e60da1738b0e81c28a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a14597d3a526e50e60da1738b0e81c28a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1pipelining_1_1pipe__end.html">pipe_end</a>&lt; typename <a class="el" href="structtpie_1_1pipelining_1_1serialization__bits_1_1output__factory.html">serialization_bits::output_factory</a>&lt; T &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetpie_1_1pipelining.html#a14597d3a526e50e60da1738b0e81c28a">serialization_output</a> (<a class="el" href="classtpie_1_1serialization__writer.html">serialization_writer</a> &amp;wr)</td></tr>
<tr class="memdesc:a14597d3a526e50e60da1738b0e81c28a"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pipelining node that writes item to a <a class="el" href="classtpie_1_1serialization__writer.html">serialization_writer</a>.  <a href="namespacetpie_1_1pipelining.html#a14597d3a526e50e60da1738b0e81c28a">More...</a><br /></td></tr>
<tr class="separator:a14597d3a526e50e60da1738b0e81c28a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a219b052fec6d05e4ff793194ca78a656"><td class="memTemplParams" colspan="2">template&lt;typename pred_t  = std::less&lt;void&gt;&gt; </td></tr>
<tr class="memitem:a219b052fec6d05e4ff793194ca78a656"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1pipelining_1_1pipe__middle.html">pipe_middle</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1serialization__bits_1_1sort__factory.html">serialization_bits::sort_factory</a>&lt; pred_t &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetpie_1_1pipelining.html#a219b052fec6d05e4ff793194ca78a656">serialization_sort</a> (const pred_t &amp;p=std::less&lt; void &gt;())</td></tr>
<tr class="memdesc:a219b052fec6d05e4ff793194ca78a656"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pipelining sorter using the given predicate.  <a href="namespacetpie_1_1pipelining.html#a219b052fec6d05e4ff793194ca78a656">More...</a><br /></td></tr>
<tr class="separator:a219b052fec6d05e4ff793194ca78a656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a6884d071abf3893b0cd29c1f1f9cbd"><td class="memTemplParams" colspan="2">template&lt;typename store_t &gt; </td></tr>
<tr class="memitem:a3a6884d071abf3893b0cd29c1f1f9cbd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1pipelining_1_1pipe__middle.html">pipe_middle</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1sort__factory.html">bits::sort_factory</a>&lt; std::less&lt; void &gt;, store_t &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetpie_1_1pipelining.html#a3a6884d071abf3893b0cd29c1f1f9cbd">store_sort</a> (store_t store=store_t())</td></tr>
<tr class="memdesc:a3a6884d071abf3893b0cd29c1f1f9cbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pipelining node that sorts large elements indirectly by using a store and std::less.  <a href="namespacetpie_1_1pipelining.html#a3a6884d071abf3893b0cd29c1f1f9cbd">More...</a><br /></td></tr>
<tr class="separator:a3a6884d071abf3893b0cd29c1f1f9cbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7f4bf6228dcee5efb1649c95df8c4ed"><td class="memTemplParams" colspan="2">template&lt;typename store_t , typename pred_t &gt; </td></tr>
<tr class="memitem:ac7f4bf6228dcee5efb1649c95df8c4ed"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1pipelining_1_1pipe__middle.html">pipe_middle</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1sort__factory.html">bits::sort_factory</a>&lt; pred_t, store_t &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetpie_1_1pipelining.html#ac7f4bf6228dcee5efb1649c95df8c4ed">store_sort</a> (const pred_t &amp;p, store_t store=store_t())</td></tr>
<tr class="memdesc:ac7f4bf6228dcee5efb1649c95df8c4ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pipelining node that sorts large elements indirectly by using a store and the given predicate.  <a href="namespacetpie_1_1pipelining.html#ac7f4bf6228dcee5efb1649c95df8c4ed">More...</a><br /></td></tr>
<tr class="separator:ac7f4bf6228dcee5efb1649c95df8c4ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a056b07e01a80b672521c04c866455bf4"><td class="memTemplParams" colspan="2">template&lt;typename pred_t  = std::less&lt;void&gt;, typename store_t  = default_store&gt; </td></tr>
<tr class="memitem:a056b07e01a80b672521c04c866455bf4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1pipelining_1_1pipe__middle.html">pipe_middle</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1sort__factory.html">bits::sort_factory</a>&lt; pred_t, store_t &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetpie_1_1pipelining.html#a056b07e01a80b672521c04c866455bf4">sort</a> (const pred_t &amp;p=std::less&lt; void &gt;(), store_t store=<a class="el" href="structtpie_1_1dynamic__store.html">default_store</a>())</td></tr>
<tr class="memdesc:a056b07e01a80b672521c04c866455bf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pipelining node that sorts large elements indirectly by using a store and a given predicate.  <a href="namespacetpie_1_1pipelining.html#a056b07e01a80b672521c04c866455bf4">More...</a><br /></td></tr>
<tr class="separator:a056b07e01a80b672521c04c866455bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e3dda0e2b9a9c46e996e22744803d84"><td class="memTemplParams" colspan="2">template&lt;typename T , typename A &gt; </td></tr>
<tr class="memitem:a5e3dda0e2b9a9c46e996e22744803d84"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1pipelining_1_1pipe__begin.html">pipe_begin</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1tfactory.html">tfactory</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1input__vector__t.html">bits::input_vector_t</a>, <a class="el" href="classtpie_1_1pipelining_1_1Args.html">Args</a>&lt; T, A &gt;, const std::vector&lt; T, A &gt; &amp; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetpie_1_1pipelining.html#a5e3dda0e2b9a9c46e996e22744803d84">input_vector</a> (const std::vector&lt; T, A &gt; &amp;<a class="el" href="namespacetpie_1_1pipelining.html#aec8021f755b4600d49276267552aa32b">input</a>)</td></tr>
<tr class="memdesc:a5e3dda0e2b9a9c46e996e22744803d84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pipelining nodes that pushes the contents of the given vector to the next node in the pipeline.  <a href="namespacetpie_1_1pipelining.html#a5e3dda0e2b9a9c46e996e22744803d84">More...</a><br /></td></tr>
<tr class="separator:a5e3dda0e2b9a9c46e996e22744803d84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8de49163e2146bfac890a722f843707"><td class="memTemplParams" colspan="2"><a id="ac8de49163e2146bfac890a722f843707"></a>
template&lt;typename T , typename A &gt; </td></tr>
<tr class="memitem:ac8de49163e2146bfac890a722f843707"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1pipelining_1_1pipe__begin.html">pipe_begin</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1tfactory.html">tfactory</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1input__vector__t.html">bits::input_vector_t</a>, <a class="el" href="classtpie_1_1pipelining_1_1Args.html">Args</a>&lt; T, A &gt;, const std::vector&lt; T, A &gt; &amp; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>input_vector</b> (std::vector&lt; T, A &gt; &amp;&amp;<a class="el" href="namespacetpie_1_1pipelining.html#aec8021f755b4600d49276267552aa32b">input</a>)=delete</td></tr>
<tr class="separator:ac8de49163e2146bfac890a722f843707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bd3f49b46fbe9efb7f6638105c78ebe"><td class="memTemplParams" colspan="2">template&lt;typename T , typename A &gt; </td></tr>
<tr class="memitem:a5bd3f49b46fbe9efb7f6638105c78ebe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1pipelining_1_1pullpipe__begin.html">pullpipe_begin</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1termfactory.html">termfactory</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1pull__input__vector__t.html">bits::pull_input_vector_t</a>&lt; T, A &gt;, const std::vector&lt; T, A &gt; &amp; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetpie_1_1pipelining.html#a5bd3f49b46fbe9efb7f6638105c78ebe">pull_input_vector</a> (const std::vector&lt; T, A &gt; &amp;<a class="el" href="namespacetpie_1_1pipelining.html#aec8021f755b4600d49276267552aa32b">input</a>)</td></tr>
<tr class="memdesc:a5bd3f49b46fbe9efb7f6638105c78ebe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pipelining nodes that pushes the contents of the given vector to the next node in the pipeline.  <a href="namespacetpie_1_1pipelining.html#a5bd3f49b46fbe9efb7f6638105c78ebe">More...</a><br /></td></tr>
<tr class="separator:a5bd3f49b46fbe9efb7f6638105c78ebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a451275ca496e4202cea1818b5afb3d6d"><td class="memTemplParams" colspan="2"><a id="a451275ca496e4202cea1818b5afb3d6d"></a>
template&lt;typename T , typename A &gt; </td></tr>
<tr class="memitem:a451275ca496e4202cea1818b5afb3d6d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1pipelining_1_1pullpipe__begin.html">pullpipe_begin</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1termfactory.html">termfactory</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1pull__input__vector__t.html">bits::pull_input_vector_t</a>&lt; T, A &gt;, const std::vector&lt; T, A &gt; &amp; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>pull_input_vector</b> (std::vector&lt; T, A &gt; &amp;&amp;<a class="el" href="namespacetpie_1_1pipelining.html#aec8021f755b4600d49276267552aa32b">input</a>)=delete</td></tr>
<tr class="separator:a451275ca496e4202cea1818b5afb3d6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a283900e15c2f8e39c87e3f2ec8bebb68"><td class="memTemplParams" colspan="2">template&lt;typename T , typename A &gt; </td></tr>
<tr class="memitem:a283900e15c2f8e39c87e3f2ec8bebb68"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1pipelining_1_1pipe__end.html">pipe_end</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1termfactory.html">termfactory</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1output__vector__t.html">bits::output_vector_t</a>&lt; T, A &gt;, std::vector&lt; T, A &gt; &amp; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetpie_1_1pipelining.html#a283900e15c2f8e39c87e3f2ec8bebb68">output_vector</a> (std::vector&lt; T, A &gt; &amp;<a class="el" href="namespacetpie_1_1pipelining.html#aa1ecad88e2e14856799abf63e36abd4b">output</a>)</td></tr>
<tr class="memdesc:a283900e15c2f8e39c87e3f2ec8bebb68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pipelining node that pushes items to the given vector.  <a href="namespacetpie_1_1pipelining.html#a283900e15c2f8e39c87e3f2ec8bebb68">More...</a><br /></td></tr>
<tr class="separator:a283900e15c2f8e39c87e3f2ec8bebb68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae472074cd0d10a3e4003793905f9f3b8"><td class="memTemplParams" colspan="2"><a id="ae472074cd0d10a3e4003793905f9f3b8"></a>
template&lt;typename T , typename A &gt; </td></tr>
<tr class="memitem:ae472074cd0d10a3e4003793905f9f3b8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1pipelining_1_1pipe__end.html">pipe_end</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1termfactory.html">termfactory</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1output__vector__t.html">bits::output_vector_t</a>&lt; T, A &gt;, std::vector&lt; T, A &gt; &amp; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>output_vector</b> (std::vector&lt; T, A &gt; &amp;&amp;<a class="el" href="namespacetpie_1_1pipelining.html#aa1ecad88e2e14856799abf63e36abd4b">output</a>)=delete</td></tr>
<tr class="separator:ae472074cd0d10a3e4003793905f9f3b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad15fbeeb9b78d2dbef1aa9bcc59280f5"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:ad15fbeeb9b78d2dbef1aa9bcc59280f5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1pipelining_1_1pipe__middle.html">pipe_middle</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1tfactory.html">tfactory</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1lambda__t.html">bits::lambda_t</a>, <a class="el" href="classtpie_1_1pipelining_1_1Args.html">Args</a>&lt; F &gt;, F &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetpie_1_1pipelining.html#ad15fbeeb9b78d2dbef1aa9bcc59280f5">lambda</a> (const F &amp;f)</td></tr>
<tr class="memdesc:ad15fbeeb9b78d2dbef1aa9bcc59280f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pipelining nodes that applies to given functor to items in the stream.  <a href="namespacetpie_1_1pipelining.html#ad15fbeeb9b78d2dbef1aa9bcc59280f5">More...</a><br /></td></tr>
<tr class="separator:ad15fbeeb9b78d2dbef1aa9bcc59280f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e9ad77f3e10365636102e3b1bcbca74"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a9e9ad77f3e10365636102e3b1bcbca74"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1pipelining_1_1pipe__middle.html">pipe_middle</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1tfactory.html">tfactory</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1exclude__lambda__t.html">bits::exclude_lambda_t</a>, <a class="el" href="classtpie_1_1pipelining_1_1Args.html">Args</a>&lt; F &gt;, F &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetpie_1_1pipelining.html#a9e9ad77f3e10365636102e3b1bcbca74">exclude_lambda</a> (const F &amp;f)</td></tr>
<tr class="memdesc:a9e9ad77f3e10365636102e3b1bcbca74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pipelining nodes that applies to given functor to items in the stream.  <a href="namespacetpie_1_1pipelining.html#a9e9ad77f3e10365636102e3b1bcbca74">More...</a><br /></td></tr>
<tr class="separator:a9e9ad77f3e10365636102e3b1bcbca74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adccbb850b1876db82662643ca5db8054"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1pipelining_1_1pipe__middle.html">pipe_middle</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1pair__factory.html">bits::pair_factory</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1factory.html">factory</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1count__consecutive__t.html">bits::count_consecutive_t</a> &gt;, <a class="el" href="classtpie_1_1pipelining_1_1factory.html">factory</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1extract__first__t.html">bits::extract_first_t</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetpie_1_1pipelining.html#adccbb850b1876db82662643ca5db8054">pipeuniq</a> ()</td></tr>
<tr class="memdesc:adccbb850b1876db82662643ca5db8054"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pipelining node that removes duplicate items and create a phase boundary.  <a href="namespacetpie_1_1pipelining.html#adccbb850b1876db82662643ca5db8054">More...</a><br /></td></tr>
<tr class="separator:adccbb850b1876db82662643ca5db8054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec16e3bda26cde1cbfb5aefd25e5f7d6"><td class="memTemplParams" colspan="2">template&lt;typename Input &gt; </td></tr>
<tr class="memitem:aec16e3bda26cde1cbfb5aefd25e5f7d6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1pipelining_1_1pipe__end.html">pipe_end</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1termfactory.html">termfactory</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1devirtualize__end__node.html">bits::devirtualize_end_node</a>&lt; Input &gt;, <a class="el" href="classtpie_1_1pipelining_1_1virtual__chunk__end.html">virtual_chunk_end</a>&lt; Input &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetpie_1_1pipelining.html#aec16e3bda26cde1cbfb5aefd25e5f7d6">devirtualize</a> (const <a class="el" href="classtpie_1_1pipelining_1_1virtual__chunk__end.html">virtual_chunk_end</a>&lt; Input &gt; &amp;out)</td></tr>
<tr class="memdesc:aec16e3bda26cde1cbfb5aefd25e5f7d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a <a class="el" href="classtpie_1_1pipelining_1_1virtual__chunk__end.html" title="Virtual chunk that has no output (that is, virtual consumer).">virtual_chunk_end</a> for use at the end of a normal none virtual pipeline.  <a href="namespacetpie_1_1pipelining.html#aec16e3bda26cde1cbfb5aefd25e5f7d6">More...</a><br /></td></tr>
<tr class="separator:aec16e3bda26cde1cbfb5aefd25e5f7d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a441c4af387aa9bf4cf482f76cea7592f"><td class="memTemplParams" colspan="2">template&lt;typename Output &gt; </td></tr>
<tr class="memitem:a441c4af387aa9bf4cf482f76cea7592f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1pipelining_1_1pipe__begin.html">pipe_begin</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1tfactory.html">tfactory</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1devirtualize__begin__node.html">bits::devirtualize_begin_node</a>, <a class="el" href="classtpie_1_1pipelining_1_1Args.html">Args</a>&lt; Output &gt;, <a class="el" href="classtpie_1_1pipelining_1_1virtual__chunk__begin.html">virtual_chunk_begin</a>&lt; Output &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetpie_1_1pipelining.html#a441c4af387aa9bf4cf482f76cea7592f">devirtualize</a> (const <a class="el" href="classtpie_1_1pipelining_1_1virtual__chunk__begin.html">virtual_chunk_begin</a>&lt; Output &gt; &amp;in)</td></tr>
<tr class="memdesc:a441c4af387aa9bf4cf482f76cea7592f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a <a class="el" href="classtpie_1_1pipelining_1_1virtual__chunk__begin.html" title="Virtual chunk that has no input (that is, virtual producer).">virtual_chunk_begin</a> for use at the beginning of a normal none virtual pipeline.  <a href="namespacetpie_1_1pipelining.html#a441c4af387aa9bf4cf482f76cea7592f">More...</a><br /></td></tr>
<tr class="separator:a441c4af387aa9bf4cf482f76cea7592f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6620b2142a72bd7529cd24fa8ba5f8a4"><td class="memTemplParams" colspan="2">template&lt;typename Input , typename Output &gt; </td></tr>
<tr class="memitem:a6620b2142a72bd7529cd24fa8ba5f8a4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1pipelining_1_1pipe__middle.html">pipe_middle</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1devirtualization__factory.html">bits::devirtualization_factory</a>&lt; Input, Output &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetpie_1_1pipelining.html#a6620b2142a72bd7529cd24fa8ba5f8a4">devirtualize</a> (const <a class="el" href="classtpie_1_1pipelining_1_1virtual__chunk.html">virtual_chunk</a>&lt; Input, Output &gt; &amp;mid)</td></tr>
<tr class="memdesc:a6620b2142a72bd7529cd24fa8ba5f8a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a <a class="el" href="classtpie_1_1pipelining_1_1virtual__chunk.html" title="Virtual chunk that has input and output.">virtual_chunk</a> for use in the middle of a normal none virtual pipeline.  <a href="namespacetpie_1_1pipelining.html#a6620b2142a72bd7529cd24fa8ba5f8a4">More...</a><br /></td></tr>
<tr class="separator:a6620b2142a72bd7529cd24fa8ba5f8a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae88e535b4b18fc762c6dfc6ab7d36de5"><td class="memTemplParams" colspan="2">template&lt;typename Input &gt; </td></tr>
<tr class="memitem:ae88e535b4b18fc762c6dfc6ab7d36de5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1pipelining_1_1pullpipe__begin.html">pullpipe_begin</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1termfactory.html">termfactory</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1devirtualize__pull__begin__node.html">bits::devirtualize_pull_begin_node</a>&lt; Input &gt;, <a class="el" href="classtpie_1_1pipelining_1_1virtual__chunk__pull__begin.html">virtual_chunk_pull_begin</a>&lt; Input &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetpie_1_1pipelining.html#ae88e535b4b18fc762c6dfc6ab7d36de5">devirtualize</a> (const <a class="el" href="classtpie_1_1pipelining_1_1virtual__chunk__pull__begin.html">virtual_chunk_pull_begin</a>&lt; Input &gt; &amp;out)</td></tr>
<tr class="memdesc:ae88e535b4b18fc762c6dfc6ab7d36de5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a <a class="el" href="classtpie_1_1pipelining_1_1virtual__chunk__pull__begin.html" title="Virtual chunk that has no output (that is, virtual consumer).">virtual_chunk_pull_begin</a> for use at the beginning of a normal none virtual pull pipeline.  <a href="namespacetpie_1_1pipelining.html#ae88e535b4b18fc762c6dfc6ab7d36de5">More...</a><br /></td></tr>
<tr class="separator:ae88e535b4b18fc762c6dfc6ab7d36de5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab750cb7baed4888cecdf06b71935a348"><td class="memTemplParams" colspan="2"><a id="ab750cb7baed4888cecdf06b71935a348"></a>
template&lt;typename Input &gt; </td></tr>
<tr class="memitem:ab750cb7baed4888cecdf06b71935a348"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1pipelining_1_1pullpipe__end.html">pullpipe_end</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1tfactory.html">tfactory</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1devirtualize__pull__end__node.html">bits::devirtualize_pull_end_node</a>, <a class="el" href="classtpie_1_1pipelining_1_1Args.html">Args</a>&lt; Input &gt;, <a class="el" href="classtpie_1_1pipelining_1_1virtual__chunk__pull__end.html">virtual_chunk_pull_end</a>&lt; Input &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>devirtualize</b> (const <a class="el" href="classtpie_1_1pipelining_1_1virtual__chunk__pull__end.html">virtual_chunk_pull_end</a>&lt; Input &gt; &amp;in)</td></tr>
<tr class="separator:ab750cb7baed4888cecdf06b71935a348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7c5427bb574503e5a7c06477a95365d"><td class="memTemplParams" colspan="2"><a id="ae7c5427bb574503e5a7c06477a95365d"></a>
template&lt;typename Input , typename Output &gt; </td></tr>
<tr class="memitem:ae7c5427bb574503e5a7c06477a95365d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1pipelining_1_1pullpipe__middle.html">pullpipe_middle</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1devirtualization__pull__factory.html">bits::devirtualization_pull_factory</a>&lt; Input, Output &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>devirtualize</b> (const <a class="el" href="classtpie_1_1pipelining_1_1virtual__chunk__pull.html">virtual_chunk_pull</a>&lt; Input, Output &gt; &amp;mid)</td></tr>
<tr class="separator:ae7c5427bb574503e5a7c06477a95365d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90e90774b53a47653bf592e14dd352e3"><td class="memTemplParams" colspan="2"><a id="a90e90774b53a47653bf592e14dd352e3"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a90e90774b53a47653bf592e14dd352e3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1pipelining_1_1pipe__middle.html">pipe_middle</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1tfactory.html">tfactory</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1vfork__node.html">bits::vfork_node</a>, <a class="el" href="classtpie_1_1pipelining_1_1Args.html">Args</a>&lt; T &gt;, <a class="el" href="classtpie_1_1pipelining_1_1virtual__chunk__end.html">virtual_chunk_end</a>&lt; T &gt; &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>fork_to_virtual</b> (const <a class="el" href="classtpie_1_1pipelining_1_1virtual__chunk__end.html">virtual_chunk_end</a>&lt; T &gt; &amp;out)</td></tr>
<tr class="separator:a90e90774b53a47653bf592e14dd352e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e4031d3c272560849228a2fe938ca77"><td class="memTemplParams" colspan="2"><a id="a6e4031d3c272560849228a2fe938ca77"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6e4031d3c272560849228a2fe938ca77"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1pipelining_1_1virtual__chunk.html">virtual_chunk</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>vfork</b> (const <a class="el" href="classtpie_1_1pipelining_1_1virtual__chunk__end.html">virtual_chunk_end</a>&lt; T &gt; &amp;out)</td></tr>
<tr class="separator:a6e4031d3c272560849228a2fe938ca77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e78ee0e093dfc19f0a36dab45a991aa"><td class="memTemplParams" colspan="2"><a id="a0e78ee0e093dfc19f0a36dab45a991aa"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0e78ee0e093dfc19f0a36dab45a991aa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1pipelining_1_1virtual__chunk.html">virtual_chunk</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>chunk_if</b> (bool b, <a class="el" href="classtpie_1_1pipelining_1_1virtual__chunk.html">virtual_chunk</a>&lt; T &gt; t)</td></tr>
<tr class="separator:a0e78ee0e093dfc19f0a36dab45a991aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40a59b97118929e097ea44053fb29132"><td class="memTemplParams" colspan="2"><a id="a40a59b97118929e097ea44053fb29132"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a40a59b97118929e097ea44053fb29132"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1pipelining_1_1virtual__chunk__end.html">virtual_chunk_end</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>chunk_end_if</b> (bool b, <a class="el" href="classtpie_1_1pipelining_1_1virtual__chunk__end.html">virtual_chunk_end</a>&lt; T &gt; t)</td></tr>
<tr class="separator:a40a59b97118929e097ea44053fb29132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a715b7f70cec7f2c4a3be9300e50aade4"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a715b7f70cec7f2c4a3be9300e50aade4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1pipelining_1_1pipe__middle.html">pipe_middle</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1tfactory.html">tfactory</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1visit__t.html">bits::visit_t</a>, <a class="el" href="classtpie_1_1pipelining_1_1Args.html">Args</a>&lt; F &gt;, F &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetpie_1_1pipelining.html#a715b7f70cec7f2c4a3be9300e50aade4">visit</a> (const F &amp;functor)</td></tr>
<tr class="memdesc:a715b7f70cec7f2c4a3be9300e50aade4"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pipelining node that applies a functor to elements pushed to it.  <a href="namespacetpie_1_1pipelining.html#a715b7f70cec7f2c4a3be9300e50aade4">More...</a><br /></td></tr>
<tr class="separator:a715b7f70cec7f2c4a3be9300e50aade4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ab154aafa45c2cb062ffb0290def85b6b"><td class="memItemLeft" align="right" valign="top"><a id="ab154aafa45c2cb062ffb0290def85b6b"></a>
TPIE_EXPORT std::unordered_set&lt; <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1pipeline__base__base.html">bits::pipeline_base_base</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>current_pipelines</b></td></tr>
<tr class="separator:ab154aafa45c2cb062ffb0290def85b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ba22f0d6a747ecac1a6ee05152d7749"><td class="memItemLeft" align="right" valign="top"><a id="a2ba22f0d6a747ecac1a6ee05152d7749"></a>
TPIE_EXPORT std::mutex&#160;</td><td class="memItemRight" valign="bottom"><b>current_pipelines_mutex</b></td></tr>
<tr class="separator:a2ba22f0d6a747ecac1a6ee05152d7749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae4e02fc1e0c3edf3007ae360485508c"><td class="memItemLeft" align="right" valign="top"><a id="aae4e02fc1e0c3edf3007ae360485508c"></a>
const priority_type&#160;</td><td class="memItemRight" valign="bottom"><b>PRIORITY_NO_NAME</b> = 0</td></tr>
<tr class="separator:aae4e02fc1e0c3edf3007ae360485508c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa7d60922936cc9dc73ba220a034f7f8"><td class="memItemLeft" align="right" valign="top"><a id="afa7d60922936cc9dc73ba220a034f7f8"></a>
const priority_type&#160;</td><td class="memItemRight" valign="bottom"><b>PRIORITY_INSIGNIFICANT</b> = 5</td></tr>
<tr class="separator:afa7d60922936cc9dc73ba220a034f7f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd9d765b9910509b05eec59b2022bd79"><td class="memItemLeft" align="right" valign="top"><a id="afd9d765b9910509b05eec59b2022bd79"></a>
const priority_type&#160;</td><td class="memItemRight" valign="bottom"><b>PRIORITY_SIGNIFICANT</b> = 10</td></tr>
<tr class="separator:afd9d765b9910509b05eec59b2022bd79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30670194483f97ed932d03280a86485a"><td class="memItemLeft" align="right" valign="top"><a id="a30670194483f97ed932d03280a86485a"></a>
const priority_type&#160;</td><td class="memItemRight" valign="bottom"><b>PRIORITY_USER</b> = 20</td></tr>
<tr class="separator:a30670194483f97ed932d03280a86485a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="factory__base_8h_source.html">pipelining/factory_base.h</a> Base class of pipelining factories </p>
<p>TPIE pipelining framework. </p><dl class="section author"><dt>Author</dt><dd>Mathias Rav </dd></dl>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a877590b7fc6795fe07d7674323bbf92e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a877590b7fc6795fe07d7674323bbf92e">&#9670;&nbsp;</a></span>buffer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classtpie_1_1pipelining_1_1pipe__middle.html">pipe_middle</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1split__factory.html">split_factory</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1bits_1_1buffer__input__t.html">bits::buffer_input_t</a>, <a class="el" href="classtpie_1_1pipelining_1_1node.html">node</a>, <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1buffer__output__t.html">bits::buffer_output_t</a>&gt; &gt; <a class="el" href="namespacetpie_1_1pipelining.html#a877590b7fc6795fe07d7674323bbf92e">tpie::pipelining::buffer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The buffer node inserts a phase boundary into the pipeline by writing items to disk. </p>
<p>It does not change the contents of the stream. </p>

<p class="definition">Definition at line <a class="el" href="pipelining_2buffer_8h_source.html#l00205">205</a> of file <a class="el" href="pipelining_2buffer_8h_source.html">buffer.h</a>.</p>

</div>
</div>
<a id="ad3d10d0df467a28cb2d9e08106241029"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3d10d0df467a28cb2d9e08106241029">&#9670;&nbsp;</a></span>chunker</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classtpie_1_1pipelining_1_1pipe__middle.html">pipe_middle</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1factory.html">factory</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1bits_1_1chunker__t.html">bits::chunker_t</a>, size_t&gt; &gt; <a class="el" href="namespacetpie_1_1pipelining.html#ad3d10d0df467a28cb2d9e08106241029">tpie::pipelining::chunker</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A pipelining node that gathers elements into a vector of some size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxSize</td><td>the maximum size of the vector </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="chunker_8h_source.html#l00075">75</a> of file <a class="el" href="chunker_8h_source.html">chunker.h</a>.</p>

</div>
</div>
<a id="a14d6f6f08ebe853a0ea78ed5449faddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14d6f6f08ebe853a0ea78ed5449faddb">&#9670;&nbsp;</a></span>internal_reverser</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classtpie_1_1pipelining_1_1pipe__middle.html">pipe_middle</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1split__factory.html">split_factory</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1bits_1_1internal__reverser__input__t.html">bits::internal_reverser_input_t</a>, <a class="el" href="classtpie_1_1pipelining_1_1node.html">node</a>, <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1internal__reverser__output__t.html">bits::internal_reverser_output_t</a>&gt; &gt; <a class="el" href="namespacetpie_1_1pipelining.html#a14d6f6f08ebe853a0ea78ed5449faddb">tpie::pipelining::internal_reverser</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a reverser node stored in internal memory. </p>
<p>Reverses the stream and creates a phase boundary </p>

<p class="definition">Definition at line <a class="el" href="reverse_8h_source.html#l00373">373</a> of file <a class="el" href="reverse_8h_source.html">reverse.h</a>.</p>

</div>
</div>
<a id="a98c484e810537b48040f63fdf8d52e9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98c484e810537b48040f63fdf8d52e9b">&#9670;&nbsp;</a></span>named_input</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classtpie_1_1pipelining_1_1pipe__begin.html">pipe_begin</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1factory.html">factory</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1bits_1_1named__input__t.html">bits::named_input_t</a>, std::string&gt; &gt; <a class="el" href="namespacetpie_1_1pipelining.html#a98c484e810537b48040f63fdf8d52e9b">tpie::pipelining::named_input</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pipelining nodes that pushes the contents of the named file stream to the next node in the pipeline. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The file stream from which it pushes items </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="pipelining_2file__stream_8h_source.html#l00388">388</a> of file <a class="el" href="pipelining_2file__stream_8h_source.html">file_stream.h</a>.</p>

</div>
</div>
<a id="ad8185baaeedfd95e3d9fcfae0461441c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8185baaeedfd95e3d9fcfae0461441c">&#9670;&nbsp;</a></span>printf_ints</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classtpie_1_1pipelining_1_1pipe__end.html">pipe_end</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1termfactory.html">termfactory</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1bits_1_1printf__ints__t.html">bits::printf_ints_t</a>&gt; &gt; <a class="el" href="namespacetpie_1_1pipelining.html#ad8185baaeedfd95e3d9fcfae0461441c">tpie::pipelining::printf_ints</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A pipelining node that prints the items that are pushed to it. </p>

<p class="definition">Definition at line <a class="el" href="pipelining_2stdio_8h_source.html#l00073">73</a> of file <a class="el" href="pipelining_2stdio_8h_source.html">stdio.h</a>.</p>

</div>
</div>
<a id="a8635eea4a7a572a8d5f14c1087d266b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8635eea4a7a572a8d5f14c1087d266b9">&#9670;&nbsp;</a></span>pull_peek</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classtpie_1_1pipelining_1_1pullpipe__middle.html">pullpipe_middle</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1factory.html">factory</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1bits_1_1pull__peek__t.html">bits::pull_peek_t</a>&gt; &gt; <a class="el" href="namespacetpie_1_1pipelining.html#a8635eea4a7a572a8d5f14c1087d266b9">tpie::pipelining::pull_peek</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A node that allows peeking at the next item in the pipeline. </p>

<p class="definition">Definition at line <a class="el" href="helpers_8h_source.html#l00484">484</a> of file <a class="el" href="helpers_8h_source.html">helpers.h</a>.</p>

</div>
</div>
<a id="aff47d9407963e2e003e86a626b3a2a45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff47d9407963e2e003e86a626b3a2a45">&#9670;&nbsp;</a></span>reverser</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classtpie_1_1pipelining_1_1pipe__middle.html">pipe_middle</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1split__factory.html">split_factory</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1bits_1_1reverser__input__t.html">bits::reverser_input_t</a>, <a class="el" href="classtpie_1_1pipelining_1_1node.html">node</a>, <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1reverser__output__t.html">bits::reverser_output_t</a>&gt; &gt; <a class="el" href="namespacetpie_1_1pipelining.html#aff47d9407963e2e003e86a626b3a2a45">tpie::pipelining::reverser</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a reverser node stored in external memory. </p>
<p>Reverses the stream and creates a phase boundary </p>

<p class="definition">Definition at line <a class="el" href="reverse_8h_source.html#l00367">367</a> of file <a class="el" href="reverse_8h_source.html">reverse.h</a>.</p>

</div>
</div>
<a id="ac08cd229124e38812ddee98a6ad0bb73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac08cd229124e38812ddee98a6ad0bb73">&#9670;&nbsp;</a></span>scanf_ints</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classtpie_1_1pipelining_1_1pipe__begin.html">pipe_begin</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1factory.html">factory</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1bits_1_1scanf__ints__t.html">bits::scanf_ints_t</a>&gt; &gt; <a class="el" href="namespacetpie_1_1pipelining.html#ac08cd229124e38812ddee98a6ad0bb73">tpie::pipelining::scanf_ints</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A pipelining node that pushes the integers it reads using scanf. </p>

<p class="definition">Definition at line <a class="el" href="pipelining_2stdio_8h_source.html#l00068">68</a> of file <a class="el" href="pipelining_2stdio_8h_source.html">stdio.h</a>.</p>

</div>
</div>
<a id="acd9f0fd78ce19cfc6faf0b737afe7908"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd9f0fd78ce19cfc6faf0b737afe7908">&#9670;&nbsp;</a></span>serialization_buffer</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classtpie_1_1pipelining_1_1pipe__middle.html">pipe_middle</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1split__factory.html">split_factory</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1serialization__bits_1_1buffer__input__t.html">serialization_bits::buffer_input_t</a>, <a class="el" href="classtpie_1_1pipelining_1_1node.html">node</a>, <a class="el" href="classtpie_1_1pipelining_1_1serialization__bits_1_1buffer__output__t.html">serialization_bits::buffer_output_t</a>&gt; &gt; <a class="el" href="namespacetpie_1_1pipelining.html#acd9f0fd78ce19cfc6faf0b737afe7908">tpie::pipelining::serialization_buffer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A pipelining node that acts as a buffer for serializable items and creates a phase boundary. </p>

<p class="definition">Definition at line <a class="el" href="serialization_8h_source.html#l00496">496</a> of file <a class="el" href="serialization_8h_source.html">serialization.h</a>.</p>

</div>
</div>
<a id="aee041370b4ced1dcb5bd462f45e06eb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee041370b4ced1dcb5bd462f45e06eb1">&#9670;&nbsp;</a></span>serialization_reverser</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classtpie_1_1pipelining_1_1pipe__middle.html">pipe_middle</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1split__factory.html">split_factory</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1serialization__bits_1_1reverser__input__t.html">serialization_bits::reverser_input_t</a>, <a class="el" href="classtpie_1_1pipelining_1_1node.html">node</a>, <a class="el" href="classtpie_1_1pipelining_1_1serialization__bits_1_1reverser__output__t.html">serialization_bits::reverser_output_t</a>&gt; &gt; <a class="el" href="namespacetpie_1_1pipelining.html#aee041370b4ced1dcb5bd462f45e06eb1">tpie::pipelining::serialization_reverser</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A pipelining node that reverses serializable items and creates a phase boundary. </p>

<p class="definition">Definition at line <a class="el" href="serialization_8h_source.html#l00490">490</a> of file <a class="el" href="serialization_8h_source.html">serialization.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a16a8744ad1f202f05bb32a2f60545ed4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16a8744ad1f202f05bb32a2f60545ed4">&#9670;&nbsp;</a></span>maintain_order_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacetpie_1_1pipelining.html#a16a8744ad1f202f05bb32a2f60545ed4">tpie::pipelining::maintain_order_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type describing whether to maintain the order of items in parallel. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a16a8744ad1f202f05bb32a2f60545ed4abf58a1a989c94ba7db61f23b21309b57"></a>arbitrary_order&#160;</td><td class="fielddoc"><p>Do not maintain order; push items as soon as a worker has processed them. </p>
</td></tr>
<tr><td class="fieldname"><a id="a16a8744ad1f202f05bb32a2f60545ed4a38a2c9bdf017a8b8d85054961d1c9dc8"></a>maintain_order&#160;</td><td class="fielddoc"><p>Maintain order; push items in the same order that a single thread would have. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="maintain__order__type_8h_source.html#l00029">29</a> of file <a class="el" href="maintain__order__type_8h_source.html">maintain_order_type.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;                         {</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;    <a class="code" href="namespacetpie_1_1pipelining.html#a16a8744ad1f202f05bb32a2f60545ed4abf58a1a989c94ba7db61f23b21309b57">arbitrary_order</a> = <span class="keyword">false</span>,</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;    <a class="code" href="namespacetpie_1_1pipelining.html#a16a8744ad1f202f05bb32a2f60545ed4a38a2c9bdf017a8b8d85054961d1c9dc8">maintain_order</a> = <span class="keyword">true</span></div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;};</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a97f4c0a4964d1aa7056e61cdc4d43163"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97f4c0a4964d1aa7056e61cdc4d43163">&#9670;&nbsp;</a></span>ami_input()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtpie_1_1pipelining_1_1pipe__begin.html">pipe_begin</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1factory.html">factory</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1bits_1_1ami__input__t.html">bits::ami_input_t</a>, <a class="el" href="classtpie_1_1ami_1_1stream.html">tpie::ami::stream</a>&lt;T&gt; &amp;&gt; &gt; tpie::pipelining::ami_input </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtpie_1_1ami_1_1stream.html">tpie::ami::stream</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pipelining nodes that pushes the contents of the given <a class="el" href="classtpie_1_1ami_1_1stream.html">ami::stream</a> to the next node in the pipeline. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The <a class="el" href="classtpie_1_1ami_1_1stream.html">ami::stream</a> from which it pushes items </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ami__glue_8h_source.html#l00140">140</a> of file <a class="el" href="ami__glue_8h_source.html">ami_glue.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;                                    {</div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;    <span class="keywordflow">return</span> factory&lt;bits::ami_input_t, tpie::ami::stream&lt;T&gt; &amp;&gt;(<a class="code" href="namespacetpie_1_1pipelining.html#aec8021f755b4600d49276267552aa32b">input</a>);</div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="pipelining_2file__stream_8h_source.html#l00378">input()</a>.</p>

</div>
</div>
<a id="ad31f8fb7606f19097ea9292fb7d72c94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad31f8fb7606f19097ea9292fb7d72c94">&#9670;&nbsp;</a></span>ami_input_stack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtpie_1_1pipelining_1_1pipe__begin.html">pipe_begin</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1factory.html">factory</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1bits_1_1ami__input__stack__t.html">bits::ami_input_stack_t</a>, <a class="el" href="classtpie_1_1ami_1_1stack.html">tpie::ami::stack</a>&lt;T&gt; &amp;&gt; &gt; tpie::pipelining::ami_input_stack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtpie_1_1ami_1_1stack.html">tpie::ami::stack</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pipelining nodes that pushes the contents of the given <a class="el" href="classtpie_1_1ami_1_1stack.html" title="An implementation of an external-memory stack compatible with the old AMI interface.">ami::stack</a> to the next node in the pipeline. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The <a class="el" href="classtpie_1_1ami_1_1stack.html" title="An implementation of an external-memory stack compatible with the old AMI interface.">ami::stack</a> from which it pushes items </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ami__glue_8h_source.html#l00151">151</a> of file <a class="el" href="ami__glue_8h_source.html">ami_glue.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;                                         {</div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;    <span class="keywordflow">return</span> factory&lt;bits::ami_input_stack_t, tpie::ami::stack&lt;T&gt; &amp;&gt;(<a class="code" href="namespacetpie_1_1pipelining.html#aec8021f755b4600d49276267552aa32b">input</a>);</div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="pipelining_2file__stream_8h_source.html#l00378">input()</a>.</p>

</div>
</div>
<a id="aabb4cae0c7ab29258874bca1bd4ae78f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabb4cae0c7ab29258874bca1bd4ae78f">&#9670;&nbsp;</a></span>ami_output()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtpie_1_1pipelining_1_1pipe__end.html">pipe_end</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1termfactory.html">termfactory</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1bits_1_1ami__output__t.html">bits::ami_output_t</a>&lt;T&gt;, <a class="el" href="classtpie_1_1ami_1_1stream.html">tpie::ami::stream</a>&lt;T&gt; &amp;&gt; &gt; tpie::pipelining::ami_output </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtpie_1_1ami_1_1stream.html">tpie::ami::stream</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>fs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A pipelining node that writes the pushed items to an ami stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fs</td><td>The stream that items should be written to </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ami__glue_8h_source.html#l00170">170</a> of file <a class="el" href="ami__glue_8h_source.html">ami_glue.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;                                                                                                         {</div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;    <span class="keywordflow">return</span> termfactory&lt;bits::ami_output_t&lt;T&gt;, <a class="code" href="classtpie_1_1ami_1_1stream.html">tpie::ami::stream&lt;T&gt;</a> &amp;&gt;(fs);</div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="afdcd7c723ad5e7650c5492c2266063e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdcd7c723ad5e7650c5492c2266063e2">&#9670;&nbsp;</a></span>ami_pull_input_stack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtpie_1_1pipelining_1_1pullpipe__begin.html">pullpipe_begin</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1termfactory.html">termfactory</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1bits_1_1pull__input__t.html">bits::pull_input_t</a>&lt;T&gt;, <a class="el" href="classtpie_1_1ami_1_1stack.html">tpie::ami::stack</a>&lt;T&gt; &amp;&gt; &gt; tpie::pipelining::ami_pull_input_stack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtpie_1_1ami_1_1stack.html">tpie::ami::stack</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>fs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A pipelining pull-node that reads items from the given <a class="el" href="classtpie_1_1ami_1_1stack.html" title="An implementation of an external-memory stack compatible with the old AMI interface.">ami::stack</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fs</td><td>The <a class="el" href="classtpie_1_1ami_1_1stack.html" title="An implementation of an external-memory stack compatible with the old AMI interface.">ami::stack</a> from which it reads items. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ami__glue_8h_source.html#l00161">161</a> of file <a class="el" href="ami__glue_8h_source.html">ami_glue.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;                                           {</div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;    <span class="keywordflow">return</span> termfactory&lt;bits::pull_input_t&lt;T&gt;, <a class="code" href="classtpie_1_1ami_1_1stack.html">tpie::ami::stack&lt;T&gt;</a> &amp;&gt;(fs);</div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a6b4481ce6224c2a4be88c2cc89864da0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b4481ce6224c2a4be88c2cc89864da0">&#9670;&nbsp;</a></span>cout_logger()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtpie_1_1pipelining_1_1pipe__middle.html">pipe_middle</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1factory.html">factory</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1bits_1_1ostream__logger__t.html">bits::ostream_logger_t</a>, std::ostream &amp;&gt; &gt; tpie::pipelining::cout_logger </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A pipelining node that writes items to standard out and then pushes them to the next node. </p>

<p class="definition">Definition at line <a class="el" href="helpers_8h_source.html#l00477">477</a> of file <a class="el" href="helpers_8h_source.html">helpers.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;              {</div>
<div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;    <span class="keywordflow">return</span> {std::cout};</div>
<div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a6620b2142a72bd7529cd24fa8ba5f8a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6620b2142a72bd7529cd24fa8ba5f8a4">&#9670;&nbsp;</a></span>devirtualize() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Input , typename Output &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtpie_1_1pipelining_1_1pipe__middle.html">pipe_middle</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1bits_1_1devirtualization__factory.html">bits::devirtualization_factory</a>&lt;Input, Output&gt; &gt; tpie::pipelining::devirtualize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtpie_1_1pipelining_1_1virtual__chunk.html">virtual_chunk</a>&lt; Input, Output &gt; &amp;&#160;</td>
          <td class="paramname"><em>mid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a <a class="el" href="classtpie_1_1pipelining_1_1virtual__chunk.html" title="Virtual chunk that has input and output.">virtual_chunk</a> for use in the middle of a normal none virtual pipeline. </p>

<p class="definition">Definition at line <a class="el" href="virtual_8h_source.html#l01292">1292</a> of file <a class="el" href="virtual_8h_source.html">virtual.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01292"></a><span class="lineno"> 1292</span>&#160;                                                                                                                {</div>
<div class="line"><a name="l01293"></a><span class="lineno"> 1293</span>&#160;    <span class="keywordflow">return</span> {mid};</div>
<div class="line"><a name="l01294"></a><span class="lineno"> 1294</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a441c4af387aa9bf4cf482f76cea7592f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a441c4af387aa9bf4cf482f76cea7592f">&#9670;&nbsp;</a></span>devirtualize() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Output &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtpie_1_1pipelining_1_1pipe__begin.html">pipe_begin</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1tfactory.html">tfactory</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1bits_1_1devirtualize__begin__node.html">bits::devirtualize_begin_node</a>, <a class="el" href="classtpie_1_1pipelining_1_1Args.html">Args</a>&lt;Output&gt;, <a class="el" href="classtpie_1_1pipelining_1_1virtual__chunk__begin.html">virtual_chunk_begin</a>&lt;Output&gt; &gt; &gt; tpie::pipelining::devirtualize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtpie_1_1pipelining_1_1virtual__chunk__begin.html">virtual_chunk_begin</a>&lt; Output &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a <a class="el" href="classtpie_1_1pipelining_1_1virtual__chunk__begin.html" title="Virtual chunk that has no input (that is, virtual producer).">virtual_chunk_begin</a> for use at the beginning of a normal none virtual pipeline. </p>

<p class="definition">Definition at line <a class="el" href="virtual_8h_source.html#l01284">1284</a> of file <a class="el" href="virtual_8h_source.html">virtual.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01284"></a><span class="lineno"> 1284</span>&#160;                                                                                                                                                  {</div>
<div class="line"><a name="l01285"></a><span class="lineno"> 1285</span>&#160;    <span class="keywordflow">return</span> {in};</div>
<div class="line"><a name="l01286"></a><span class="lineno"> 1286</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aec16e3bda26cde1cbfb5aefd25e5f7d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec16e3bda26cde1cbfb5aefd25e5f7d6">&#9670;&nbsp;</a></span>devirtualize() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Input &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtpie_1_1pipelining_1_1pipe__end.html">pipe_end</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1termfactory.html">termfactory</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1bits_1_1devirtualize__end__node.html">bits::devirtualize_end_node</a>&lt;Input&gt;, <a class="el" href="classtpie_1_1pipelining_1_1virtual__chunk__end.html">virtual_chunk_end</a>&lt;Input&gt; &gt; &gt; tpie::pipelining::devirtualize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtpie_1_1pipelining_1_1virtual__chunk__end.html">virtual_chunk_end</a>&lt; Input &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a <a class="el" href="classtpie_1_1pipelining_1_1virtual__chunk__end.html" title="Virtual chunk that has no output (that is, virtual consumer).">virtual_chunk_end</a> for use at the end of a normal none virtual pipeline. </p>

<p class="definition">Definition at line <a class="el" href="virtual_8h_source.html#l01276">1276</a> of file <a class="el" href="virtual_8h_source.html">virtual.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01276"></a><span class="lineno"> 1276</span>&#160;                                                                                                                                     {</div>
<div class="line"><a name="l01277"></a><span class="lineno"> 1277</span>&#160;    <span class="keywordflow">return</span> {out};</div>
<div class="line"><a name="l01278"></a><span class="lineno"> 1278</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ae88e535b4b18fc762c6dfc6ab7d36de5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae88e535b4b18fc762c6dfc6ab7d36de5">&#9670;&nbsp;</a></span>devirtualize() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Input &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtpie_1_1pipelining_1_1pullpipe__begin.html">pullpipe_begin</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1termfactory.html">termfactory</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1bits_1_1devirtualize__pull__begin__node.html">bits::devirtualize_pull_begin_node</a>&lt;Input&gt;, <a class="el" href="classtpie_1_1pipelining_1_1virtual__chunk__pull__begin.html">virtual_chunk_pull_begin</a>&lt;Input&gt; &gt; &gt; tpie::pipelining::devirtualize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtpie_1_1pipelining_1_1virtual__chunk__pull__begin.html">virtual_chunk_pull_begin</a>&lt; Input &gt; &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a <a class="el" href="classtpie_1_1pipelining_1_1virtual__chunk__pull__begin.html" title="Virtual chunk that has no output (that is, virtual consumer).">virtual_chunk_pull_begin</a> for use at the beginning of a normal none virtual pull pipeline. </p>

<p class="definition">Definition at line <a class="el" href="virtual_8h_source.html#l01300">1300</a> of file <a class="el" href="virtual_8h_source.html">virtual.h</a>.</p>
<div class="fragment"><div class="line"><a name="l01300"></a><span class="lineno"> 1300</span>&#160;                                                                                                                                                                {</div>
<div class="line"><a name="l01301"></a><span class="lineno"> 1301</span>&#160;    <span class="keywordflow">return</span> {out};</div>
<div class="line"><a name="l01302"></a><span class="lineno"> 1302</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a9e9ad77f3e10365636102e3b1bcbca74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e9ad77f3e10365636102e3b1bcbca74">&#9670;&nbsp;</a></span>exclude_lambda()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtpie_1_1pipelining_1_1pipe__middle.html">pipe_middle</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1tfactory.html">tfactory</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1bits_1_1exclude__lambda__t.html">bits::exclude_lambda_t</a>, <a class="el" href="classtpie_1_1pipelining_1_1Args.html">Args</a>&lt;F&gt;, F&gt; &gt; tpie::pipelining::exclude_lambda </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pipelining nodes that applies to given functor to items in the stream. </p>
<p>The functor should have a typedef named argument_type that is the type of the argument given to the call operator. It is required that the functor returns a pair. The first item should be a boolean indicating whether the item should be pushed to the next node. The second should be the value itself. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The functor that should be applied to items </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="std__glue_8h_source.html#l00192">192</a> of file <a class="el" href="std__glue_8h_source.html">std_glue.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;                                                                                            {</div>
<div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;    <span class="keywordflow">return</span> {f};</div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a452f18cf33bcbcf635fc7063a0806031"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a452f18cf33bcbcf635fc7063a0806031">&#9670;&nbsp;</a></span>filter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtpie_1_1pipelining_1_1pipe__middle.html">pipe_middle</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1tfactory.html">tfactory</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1bits_1_1filter__t.html">bits::filter_t</a>, <a class="el" href="classtpie_1_1pipelining_1_1Args.html">Args</a>&lt;F&gt;, F&gt; &gt; tpie::pipelining::filter </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>functor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A pipelining node that keeps only elements where functor evaluates to true. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">functor</td><td>The filter to use </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="filter_8h_source.html#l00060">60</a> of file <a class="el" href="filter_8h_source.html">filter.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;                                                                           {</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;    <span class="keywordflow">return</span> {functor};</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a8f77702baa0872e01291bbbb3362a447"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f77702baa0872e01291bbbb3362a447">&#9670;&nbsp;</a></span>fork()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename fact_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtpie_1_1pipelining_1_1pipe__middle.html">pipe_middle</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1tfactory.html">tfactory</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1bits_1_1fork__t.html">bits::fork_t</a>, <a class="el" href="classtpie_1_1pipelining_1_1Args.html">Args</a>&lt;fact_t&gt;, fact_t&gt; &gt; tpie::pipelining::fork </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtpie_1_1pipelining_1_1pipe__end.html">pipe_end</a>&lt; fact_t &gt;&#160;</td>
          <td class="paramname"><em>to</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a fork pipe node. </p>
<p>Whenever an element e is push into the fork node, e is pushed to the destination and then to "to" </p>

<p class="definition">Definition at line <a class="el" href="helpers_8h_source.html#l00495">495</a> of file <a class="el" href="helpers_8h_source.html">helpers.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;                          {</div>
<div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;    <span class="keywordflow">return</span> {std::move(to.factory)};</div>
<div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac237f521b990f35755cecf90feab050d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac237f521b990f35755cecf90feab050d">&#9670;&nbsp;</a></span>forwarder() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtpie_1_1pipelining_1_1pipe__middle.html">pipe_middle</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1factory.html">factory</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1bits_1_1Forwarder.html">bits::Forwarder</a>, std::vector&lt;std::pair&lt;std::string, <a class="el" href="classtpie_1_1pipelining_1_1any__noncopyable.html">any_noncopyable</a>&gt; &gt; &gt; &gt; tpie::pipelining::forwarder </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VT&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A pipelining node that will forward value on prepare, and. </p>

<p class="definition">Definition at line <a class="el" href="forwarder_8h_source.html#l00067">67</a> of file <a class="el" href="forwarder_8h_source.html">forwarder.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;                                                                                                                           {</div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;    std::vector&lt;std::pair&lt;std::string, any_noncopyable&gt; &gt; v;</div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;    v.push_back(std::make_pair(name, any_noncopyable(value)));</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacetpie_1_1pipelining.html#a97aad0575703e1809b1edfecbd0a3e8a">forwarder</a>(std::move(v));</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="forwarder_8h_source.html#l00058">forwarder()</a>.</p>

</div>
</div>
<a id="a97aad0575703e1809b1edfecbd0a3e8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97aad0575703e1809b1edfecbd0a3e8a">&#9670;&nbsp;</a></span>forwarder() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtpie_1_1pipelining_1_1pipe__middle.html">pipe_middle</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1factory.html">factory</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1bits_1_1Forwarder.html">bits::Forwarder</a>, std::vector&lt;std::pair&lt;std::string, <a class="el" href="classtpie_1_1pipelining_1_1any__noncopyable.html">any_noncopyable</a>&gt; &gt; &gt; &gt; tpie::pipelining::forwarder </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::pair&lt; std::string, <a class="el" href="classtpie_1_1pipelining_1_1any__noncopyable.html">any_noncopyable</a> &gt; &gt;&#160;</td>
          <td class="paramname"><em>items</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A pipelining node that will forward values on prepare, and. </p>

<p class="definition">Definition at line <a class="el" href="forwarder_8h_source.html#l00058">58</a> of file <a class="el" href="forwarder_8h_source.html">forwarder.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;                                                                                                                                                               {</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;    <span class="keywordflow">return</span> factory&lt;bits::Forwarder, std::vector&lt;std::pair&lt;std::string, any_noncopyable&gt; &gt;  &gt;(std::move(items));</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="forwarder_8h_source.html#l00067">forwarder()</a>.</p>

</div>
</div>
<a id="aec8021f755b4600d49276267552aa32b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec8021f755b4600d49276267552aa32b">&#9670;&nbsp;</a></span>input()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtpie_1_1pipelining_1_1pipe__begin.html">pipe_begin</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1factory.html">factory</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1bits_1_1input__t.html">bits::input_t</a>, <a class="el" href="classtpie_1_1file__stream.html">file_stream</a>&lt;T&gt; &amp;, <a class="el" href="classtpie_1_1flags.html">stream_options</a>&gt; &gt; tpie::pipelining::input </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtpie_1_1file__stream.html">file_stream</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtpie_1_1flags.html">stream_options</a>&#160;</td>
          <td class="paramname"><em>options</em> = <code><a class="el" href="classtpie_1_1flags.html">stream_options</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pipelining nodes that pushes the contents of the given file stream to the next node in the pipeline. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fs</td><td>The file stream from which it pushes items </td></tr>
    <tr><td class="paramname">options</td><td>Stream options </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="pipelining_2file__stream_8h_source.html#l00378">378</a> of file <a class="el" href="pipelining_2file__stream_8h_source.html">file_stream.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;                                                                                                                            {</div>
<div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;    <span class="keywordflow">return</span> {fs, options};</div>
<div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="ami__glue_8h_source.html#l00140">ami_input()</a>, <a class="el" href="ami__glue_8h_source.html#l00151">ami_input_stack()</a>, <a class="el" href="std__glue_8h_source.html#l00048">tpie::pipelining::bits::input_vector_t&lt; dest_t, T, A &gt;::go()</a>, <a class="el" href="std__glue_8h_source.html#l00142">input_vector()</a>, <a class="el" href="std__glue_8h_source.html#l00043">tpie::pipelining::bits::input_vector_t&lt; dest_t, T, A &gt;::propagate()</a>, <a class="el" href="std__glue_8h_source.html#l00068">tpie::pipelining::bits::pull_input_vector_t&lt; T, A &gt;::propagate()</a>, and <a class="el" href="std__glue_8h_source.html#l00154">pull_input_vector()</a>.</p>

</div>
</div>
<a id="a5e3dda0e2b9a9c46e996e22744803d84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e3dda0e2b9a9c46e996e22744803d84">&#9670;&nbsp;</a></span>input_vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtpie_1_1pipelining_1_1pipe__begin.html">pipe_begin</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1tfactory.html">tfactory</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1bits_1_1input__vector__t.html">bits::input_vector_t</a>, <a class="el" href="classtpie_1_1pipelining_1_1Args.html">Args</a>&lt;T, A&gt;, const std::vector&lt;T, A&gt; &amp;&gt; &gt; tpie::pipelining::input_vector </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pipelining nodes that pushes the contents of the given vector to the next node in the pipeline. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The vector from which it pushes items </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="std__glue_8h_source.html#l00142">142</a> of file <a class="el" href="std__glue_8h_source.html">std_glue.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;                                                                                                                                  {</div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;    <span class="keywordflow">return</span> {<a class="code" href="namespacetpie_1_1pipelining.html#aec8021f755b4600d49276267552aa32b">input</a>};</div>
<div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="pipelining_2file__stream_8h_source.html#l00378">input()</a>.</p>

</div>
</div>
<a id="ad25e30e578fb780f9fff601b94fed33b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad25e30e578fb780f9fff601b94fed33b">&#9670;&nbsp;</a></span>item_type()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtpie_1_1pipelining_1_1pipe__middle.html">pipe_middle</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1tfactory.html">tfactory</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1bits_1_1item__type__t.html">bits::item_type_t</a>, <a class="el" href="classtpie_1_1pipelining_1_1Args.html">Args</a>&lt;T&gt; &gt; &gt; tpie::pipelining::item_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create item type defining identity pipe node. </p>
<p>Defines the item_type to be T. Whenever an element is push, it is immidiately pushed to the destination </p>

<p class="definition">Definition at line <a class="el" href="helpers_8h_source.html#l00654">654</a> of file <a class="el" href="helpers_8h_source.html">helpers.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00654"></a><span class="lineno">  654</span>&#160;                                                              {</div>
<div class="line"><a name="l00655"></a><span class="lineno">  655</span>&#160;    <span class="keywordflow">return</span> {};</div>
<div class="line"><a name="l00656"></a><span class="lineno">  656</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad15fbeeb9b78d2dbef1aa9bcc59280f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad15fbeeb9b78d2dbef1aa9bcc59280f5">&#9670;&nbsp;</a></span>lambda()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtpie_1_1pipelining_1_1pipe__middle.html">pipe_middle</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1tfactory.html">tfactory</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1bits_1_1lambda__t.html">bits::lambda_t</a>, <a class="el" href="classtpie_1_1pipelining_1_1Args.html">Args</a>&lt;F&gt;, F&gt; &gt; tpie::pipelining::lambda </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pipelining nodes that applies to given functor to items in the stream. </p>
<p>The functor should have a typedef named argument_type that is the type of the argument given to the call operator. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The functor that should be applied to items </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="std__glue_8h_source.html#l00178">178</a> of file <a class="el" href="std__glue_8h_source.html">std_glue.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;                                                                            {</div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;    <span class="keywordflow">return</span> {f};</div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a24a50efe4be1c714302ac073d9666928"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24a50efe4be1c714302ac073d9666928">&#9670;&nbsp;</a></span>linear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtpie_1_1pipelining_1_1pipe__middle.html">pipe_middle</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1factory.html">factory</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1bits_1_1linear__t.html">bits::linear_t</a>, T, T&gt; &gt; tpie::pipelining::linear </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>term</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A pipelining node that transforms the items by applying a linear function to them. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factor</td><td>the factor that items should be multiplied by </td></tr>
    <tr><td class="paramname">term</td><td>the term is added after the item is multipled by the factor </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="numeric_8h_source.html#l00083">83</a> of file <a class="el" href="numeric_8h_source.html">numeric.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;                         {</div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;    <span class="keywordflow">return</span> factory&lt;bits::linear_t, T, T&gt;(factor, term);</div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a15bfa65d8eab87a59e638f883d441ad4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15bfa65d8eab87a59e638f883d441ad4">&#9670;&nbsp;</a></span>map()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F , typename  = typename std::enable_if&lt;bits::has_argument_type&lt;F&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtpie_1_1pipelining_1_1pipe__middle.html">pipe_middle</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1tfactory.html">tfactory</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1bits_1_1map__t.html">bits::map_t</a>, <a class="el" href="classtpie_1_1pipelining_1_1Args.html">Args</a>&lt;F&gt;, F&gt; &gt; tpie::pipelining::map </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>functor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pipelining nodes that applies to given functor to items in the stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">functor</td><td>The functor that should be applied to items </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="map_8h_source.html#l00154">154</a> of file <a class="el" href="map_8h_source.html">map.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;                                                                     {</div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;    <span class="keywordflow">return</span> {functor};</div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a7c3f9245bc9d962ebf02c81603ece124"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c3f9245bc9d962ebf02c81603ece124">&#9670;&nbsp;</a></span>merge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename pull_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtpie_1_1pipelining_1_1pipe__middle.html">pipe_middle</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1tfactory.html">tfactory</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1bits_1_1merge__t.html">bits::merge_t</a>, <a class="el" href="classtpie_1_1pipelining_1_1Args.html">Args</a>&lt;pull_t&gt;, pull_t&gt; &gt; tpie::pipelining::merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtpie_1_1pipelining_1_1pullpipe__begin.html">pullpipe_begin</a>&lt; pull_t &gt;&#160;</td>
          <td class="paramname"><em>with</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A node that merges a pull pipeline into a push pipeline. </p>
<p>It pulls an items for each item pushed to it. </p>

<p class="definition">Definition at line <a class="el" href="merge_8h_source.html#l00065">65</a> of file <a class="el" href="merge_8h_source.html">merge.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;                                   {</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;    <span class="keywordflow">return</span> {std::move(with.factory)};</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a1da9316b9a840e71cb1744e3c3957323"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1da9316b9a840e71cb1744e3c3957323">&#9670;&nbsp;</a></span>named_output()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtpie_1_1pipelining_1_1pipe__end.html">pipe_end</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1termfactory.html">termfactory</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1bits_1_1named__output__t.html">bits::named_output_t</a>&lt;T&gt;, std::string&gt; &gt; tpie::pipelining::named_output </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A pipelining node that writes the pushed items to a named file stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path of where to write the firestream </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="pipelining_2file__stream_8h_source.html#l00439">439</a> of file <a class="el" href="pipelining_2file__stream_8h_source.html">file_stream.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;                                                                                             {</div>
<div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;    <span class="keywordflow">return</span> {std::move(path)}; </div>
<div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a176499840776c0e0ab867d510cde199f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a176499840776c0e0ab867d510cde199f">&#9670;&nbsp;</a></span>named_pull_input()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtpie_1_1pipelining_1_1pullpipe__begin.html">pullpipe_begin</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1termfactory.html">termfactory</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1bits_1_1named__pull__input__t.html">bits::named_pull_input_t</a>&lt;T&gt;, std::string&gt; &gt; tpie::pipelining::named_pull_input </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A pipelining pull-node that reads items from the given file path. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>The path of the file from which it reads items. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="pipelining_2file__stream_8h_source.html#l00420">420</a> of file <a class="el" href="pipelining_2file__stream_8h_source.html">file_stream.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;                                                                                                           {</div>
<div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;    <span class="keywordflow">return</span> {std::move(path)};</div>
<div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a77c270323d5db9828f2f123238ef552b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77c270323d5db9828f2f123238ef552b">&#9670;&nbsp;</a></span>null_sink()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtpie_1_1pipelining_1_1pipe__end.html">pipe_end</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1termfactory.html">termfactory</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1bits_1_1null__sink__t.html">bits::null_sink_t</a>&lt;T&gt; &gt; &gt; tpie::pipelining::null_sink </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a dummy end pipe node. </p>
<p>Whenever an element of type T is pushed to the null_sink it is disregarded </p>

<p class="definition">Definition at line <a class="el" href="helpers_8h_source.html#l00543">543</a> of file <a class="el" href="helpers_8h_source.html">helpers.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;{<span class="keywordflow">return</span> {};}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aaba833e0ea7898df157671f9911e6676"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaba833e0ea7898df157671f9911e6676">&#9670;&nbsp;</a></span>ordered_merge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename fact_t , typename comp_t  = std::less&lt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtpie_1_1pipelining_1_1pipe__middle.html">pipe_middle</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1tfactory.html">tfactory</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1bits_1_1ordered__merge__t.html">bits::ordered_merge_t</a>, <a class="el" href="classtpie_1_1pipelining_1_1Args.html">Args</a>&lt;fact_t, comp_t&gt;, fact_t, comp_t&gt; &gt; tpie::pipelining::ordered_merge </td>
          <td>(</td>
          <td class="paramtype">fact_t&#160;</td>
          <td class="paramname"><em>fact</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">comp_t&#160;</td>
          <td class="paramname"><em>comp</em> = <code>std::less&lt;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A node that merges a pull pipeline into a push pipeline. </p>
<p>It pulls an items for each item pushed to it. </p>

<p class="definition">Definition at line <a class="el" href="ordered__merge_8h_source.html#l00071">71</a> of file <a class="el" href="ordered__merge_8h_source.html">ordered_merge.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;                                                        {</div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;    <span class="keywordflow">return</span> {std::move(fact), std::move(comp)};</div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aa1ecad88e2e14856799abf63e36abd4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1ecad88e2e14856799abf63e36abd4b">&#9670;&nbsp;</a></span>output()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtpie_1_1pipelining_1_1pipe__end.html">pipe_end</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1termfactory.html">termfactory</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1bits_1_1output__t.html">bits::output_t</a>&lt;T&gt;, <a class="el" href="classtpie_1_1file__stream.html">file_stream</a>&lt;T&gt; &amp;&gt; &gt; tpie::pipelining::output </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtpie_1_1file__stream.html">file_stream</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>fs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A pipelining node that writes the pushed items to a file stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fs</td><td>The file stream that items should be written to </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="pipelining_2file__stream_8h_source.html#l00430">430</a> of file <a class="el" href="pipelining_2file__stream_8h_source.html">file_stream.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;                                                                                             {</div>
<div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;    <span class="keywordflow">return</span> {fs};</div>
<div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="std__glue_8h_source.html#l00165">output_vector()</a>.</p>

</div>
</div>
<a id="a283900e15c2f8e39c87e3f2ec8bebb68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a283900e15c2f8e39c87e3f2ec8bebb68">&#9670;&nbsp;</a></span>output_vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtpie_1_1pipelining_1_1pipe__end.html">pipe_end</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1termfactory.html">termfactory</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1bits_1_1output__vector__t.html">bits::output_vector_t</a>&lt;T, A&gt;, std::vector&lt;T, A&gt; &amp;&gt; &gt; tpie::pipelining::output_vector </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pipelining node that pushes items to the given vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>The vector to push items to </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="std__glue_8h_source.html#l00165">165</a> of file <a class="el" href="std__glue_8h_source.html">std_glue.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;                                                                                                                    {</div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;    <span class="keywordflow">return</span> {<a class="code" href="namespacetpie_1_1pipelining.html#aa1ecad88e2e14856799abf63e36abd4b">output</a>};</div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="pipelining_2file__stream_8h_source.html#l00430">output()</a>.</p>

</div>
</div>
<a id="a4c894e9fba7cb73afb0a62d2d67d0237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c894e9fba7cb73afb0a62d2d67d0237">&#9670;&nbsp;</a></span>parallel() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename fact_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtpie_1_1pipelining_1_1pipe__middle.html">pipe_middle</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1parallel__bits_1_1factory.html">parallel_bits::factory</a>&lt;fact_t&gt; &gt; tpie::pipelining::parallel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtpie_1_1pipelining_1_1pipe__middle.html">pipe_middle</a>&lt; fact_t &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>fact</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetpie_1_1pipelining.html#a16a8744ad1f202f05bb32a2f60545ed4">maintain_order_type</a>&#160;</td>
          <td class="paramname"><em>maintainOrder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numJobs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufSize</em> = <code>2048</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Runs a pipeline in multiple threads. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maintainOrder</td><td>Whether to make sure that items are processed and output in the order they are input. </td></tr>
    <tr><td class="paramname">numJobs</td><td>The number of threads to utilize for parallel execution. </td></tr>
    <tr><td class="paramname">bufSize</td><td>The number of items to store in the buffer sent between threads. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="pipes_8h_source.html#l00040">40</a> of file <a class="el" href="pipes_8h_source.html">pipes.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;                                                                                                                {</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;    parallel_bits::options opts;</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;    <span class="keywordflow">switch</span> (maintainOrder) {</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;        <span class="keywordflow">case</span> <a class="code" href="namespacetpie_1_1pipelining.html#a16a8744ad1f202f05bb32a2f60545ed4abf58a1a989c94ba7db61f23b21309b57">arbitrary_order</a>:</div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;            opts.maintainOrder = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;            <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;        <span class="keywordflow">case</span> <a class="code" href="namespacetpie_1_1pipelining.html#a16a8744ad1f202f05bb32a2f60545ed4a38a2c9bdf017a8b8d85054961d1c9dc8">maintain_order</a>:</div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;            opts.maintainOrder = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;            <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;    }</div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;    opts.numJobs = numJobs;</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;    opts.bufSize = bufSize;</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;    <span class="keywordflow">return</span> pipe_middle&lt;parallel_bits::factory&lt;fact_t&gt; &gt;</div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;        (parallel_bits::factory&lt;fact_t&gt;</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;         (std::move(fact.factory), std::move(opts)));</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="maintain__order__type_8h_source.html#l00032">arbitrary_order</a>, and <a class="el" href="maintain__order__type_8h_source.html#l00035">maintain_order</a>.</p>

<p class="reference">Referenced by <a class="el" href="pipes_8h_source.html#l00065">parallel()</a>.</p>

</div>
</div>
<a id="a7520734a419631cecaa49958c62bd204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7520734a419631cecaa49958c62bd204">&#9670;&nbsp;</a></span>parallel() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename fact_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtpie_1_1pipelining_1_1pipe__middle.html">pipe_middle</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1parallel__bits_1_1factory.html">parallel_bits::factory</a>&lt;fact_t&gt; &gt; tpie::pipelining::parallel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtpie_1_1pipelining_1_1pipe__middle.html">pipe_middle</a>&lt; fact_t &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>fact</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetpie_1_1pipelining.html#a16a8744ad1f202f05bb32a2f60545ed4">maintain_order_type</a>&#160;</td>
          <td class="paramname"><em>maintainOrder</em> = <code><a class="el" href="namespacetpie_1_1pipelining.html#a16a8744ad1f202f05bb32a2f60545ed4abf58a1a989c94ba7db61f23b21309b57">arbitrary_order</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Runs a pipeline in multiple threads, using the number of threads reported by <a class="el" href="namespacetpie.html#a18fbf567e45c8a656464a6777ae5996f" title="Return the number of job threads initialized by the job framework in init_job().">tpie::default_worker_count</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maintainOrder</td><td>Whether to make sure that items are processed and output in the order they are input. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="pipes_8h_source.html#l00065">65</a> of file <a class="el" href="pipes_8h_source.html">pipes.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;                                                                                           {</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="namespacetpie_1_1pipelining.html#a4c894e9fba7cb73afb0a62d2d67d0237">parallel</a>(std::move(fact), maintainOrder, <a class="code" href="namespacetpie.html#a18fbf567e45c8a656464a6777ae5996f">default_worker_count</a>());</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="namespacetpie.html#a18fbf567e45c8a656464a6777ae5996f">tpie::default_worker_count()</a>, and <a class="el" href="pipes_8h_source.html#l00040">parallel()</a>.</p>

</div>
</div>
<a id="adccbb850b1876db82662643ca5db8054"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adccbb850b1876db82662643ca5db8054">&#9670;&nbsp;</a></span>pipeuniq()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtpie_1_1pipelining_1_1pipe__middle.html">pipe_middle</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1bits_1_1pair__factory.html">bits::pair_factory</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1factory.html">factory</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1bits_1_1count__consecutive__t.html">bits::count_consecutive_t</a>&gt;, <a class="el" href="classtpie_1_1pipelining_1_1factory.html">factory</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1bits_1_1extract__first__t.html">bits::extract_first_t</a>&gt; &gt; &gt; tpie::pipelining::pipeuniq </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A pipelining node that removes duplicate items and create a phase boundary. </p>

<p class="definition">Definition at line <a class="el" href="uniq_8h_source.html#l00100">100</a> of file <a class="el" href="uniq_8h_source.html">uniq.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;           {</div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;    <span class="keywordflow">return</span> bits::pair_factory&lt;factory&lt;bits::count_consecutive_t&gt;, factory&lt;bits::extract_first_t&gt; &gt;</div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;        (factory&lt;bits::count_consecutive_t&gt;(), factory&lt;bits::extract_first_t&gt;());</div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a5833caaf7bbc9286f64656e44ec78eca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5833caaf7bbc9286f64656e44ec78eca">&#9670;&nbsp;</a></span>preparer()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtpie_1_1pipelining_1_1pipe__middle.html">pipe_middle</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1tfactory.html">tfactory</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1bits_1_1preparer__t.html">bits::preparer_t</a>, <a class="el" href="classtpie_1_1pipelining_1_1Args.html">Args</a>&lt;F&gt;, F&gt; &gt; tpie::pipelining::preparer </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>functor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create preparer callback identity pipe node. </p>
<p>When prepare is called on the node the functor is called Whenever an element is pushed, it is immidiately pushed to the destination </p>

<p class="definition">Definition at line <a class="el" href="helpers_8h_source.html#l00632">632</a> of file <a class="el" href="helpers_8h_source.html">helpers.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00632"></a><span class="lineno">  632</span>&#160;                                                                               {</div>
<div class="line"><a name="l00633"></a><span class="lineno">  633</span>&#160;    <span class="keywordflow">return</span> {functor};</div>
<div class="line"><a name="l00634"></a><span class="lineno">  634</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a6e9fef0b1bbd33a4ea0ee45fe7887811"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e9fef0b1bbd33a4ea0ee45fe7887811">&#9670;&nbsp;</a></span>propagater()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtpie_1_1pipelining_1_1pipe__middle.html">pipe_middle</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1tfactory.html">tfactory</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1bits_1_1propagater__t.html">bits::propagater_t</a>, <a class="el" href="classtpie_1_1pipelining_1_1Args.html">Args</a>&lt;F&gt;, F&gt; &gt; tpie::pipelining::propagater </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>functor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create propagate callback identity pipe node. </p>
<p>When propagate is called on the node the functor is called Whenever an element is pushed, it is immediately pushed to the destination </p>

<p class="definition">Definition at line <a class="el" href="helpers_8h_source.html#l00643">643</a> of file <a class="el" href="helpers_8h_source.html">helpers.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00643"></a><span class="lineno">  643</span>&#160;                                                                                   {</div>
<div class="line"><a name="l00644"></a><span class="lineno">  644</span>&#160;    <span class="keywordflow">return</span> {functor};</div>
<div class="line"><a name="l00645"></a><span class="lineno">  645</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a6d1f42a8cf73450e188ce23400ca2469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d1f42a8cf73450e188ce23400ca2469">&#9670;&nbsp;</a></span>pull_fork()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename dest_fact_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtpie_1_1pipelining_1_1pullpipe__middle.html">pullpipe_middle</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1tfactory.html">tfactory</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1bits_1_1pull__fork__t.html">bits::pull_fork_t</a>, <a class="el" href="classtpie_1_1pipelining_1_1Args.html">Args</a>&lt;dest_fact_t&gt;, dest_fact_t&gt; &gt; tpie::pipelining::pull_fork </td>
          <td>(</td>
          <td class="paramtype">dest_fact_t&#160;</td>
          <td class="paramname"><em>dest_fact</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pulling fork pipe node. </p>
<p>Whenever an element e is pulled from fork node, e is first pushed into the destination </p>

<p class="definition">Definition at line <a class="el" href="helpers_8h_source.html#l00507">507</a> of file <a class="el" href="helpers_8h_source.html">helpers.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;                                 {</div>
<div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;    <span class="keywordflow">return</span> {std::move(dest_fact)};</div>
<div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a42fc47efe0300f10914a02621970b8f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42fc47efe0300f10914a02621970b8f8">&#9670;&nbsp;</a></span>pull_input()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtpie_1_1pipelining_1_1pullpipe__begin.html">pullpipe_begin</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1termfactory.html">termfactory</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1bits_1_1pull__input__t.html">bits::pull_input_t</a>&lt;T&gt;, <a class="el" href="classtpie_1_1file__stream.html">file_stream</a>&lt;T&gt; &amp;, <a class="el" href="classtpie_1_1flags.html">stream_options</a>&gt; &gt; tpie::pipelining::pull_input </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtpie_1_1file__stream.html">file_stream</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtpie_1_1flags.html">stream_options</a>&#160;</td>
          <td class="paramname"><em>options</em> = <code><a class="el" href="classtpie_1_1flags.html">stream_options</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A pipelining pull-node that reads items from the given <a class="el" href="classtpie_1_1file__stream.html" title="Compressed stream.">file_stream</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fs</td><td>The file stream from which it reads items. </td></tr>
    <tr><td class="paramname">options</td><td>Stream options </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="pipelining_2file__stream_8h_source.html#l00396">396</a> of file <a class="el" href="pipelining_2file__stream_8h_source.html">file_stream.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;                                             {</div>
<div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;    <span class="keywordflow">return</span> {fs, options};</div>
<div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="adc8ae3fedd9d93c5d942e1b1f110f2e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc8ae3fedd9d93c5d942e1b1f110f2e9">&#9670;&nbsp;</a></span>pull_input_iterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtpie_1_1pipelining_1_1pullpipe__begin.html">pullpipe_begin</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1termfactory.html">termfactory</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1bits_1_1pull__input__iterator__t.html">bits::pull_input_iterator_t</a>&lt;IT&gt;, IT, IT&gt; &gt; tpie::pipelining::pull_input_iterator </td>
          <td>(</td>
          <td class="paramtype">IT&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IT&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A pull-pipe that returns items in the range given by two iterators. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>The iterator pointing to the first item </td></tr>
    <tr><td class="paramname">end</td><td>The iterator pointing to the end of the range </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="helpers_8h_source.html#l00576">576</a> of file <a class="el" href="helpers_8h_source.html">helpers.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00576"></a><span class="lineno">  576</span>&#160;                                                                                                          {</div>
<div class="line"><a name="l00577"></a><span class="lineno">  577</span>&#160;    <span class="keywordflow">return</span> {begin, end};</div>
<div class="line"><a name="l00578"></a><span class="lineno">  578</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a5bd3f49b46fbe9efb7f6638105c78ebe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bd3f49b46fbe9efb7f6638105c78ebe">&#9670;&nbsp;</a></span>pull_input_vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename A &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtpie_1_1pipelining_1_1pullpipe__begin.html">pullpipe_begin</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1termfactory.html">termfactory</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1bits_1_1pull__input__vector__t.html">bits::pull_input_vector_t</a>&lt;T, A&gt;, const std::vector&lt;T, A&gt; &amp;&gt; &gt; tpie::pipelining::pull_input_vector </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T, A &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pipelining nodes that pushes the contents of the given vector to the next node in the pipeline. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The vector from which it pushes items </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="std__glue_8h_source.html#l00154">154</a> of file <a class="el" href="std__glue_8h_source.html">std_glue.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;                                                                                                                                             {</div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;    <span class="keywordflow">return</span> {<a class="code" href="namespacetpie_1_1pipelining.html#aec8021f755b4600d49276267552aa32b">input</a>};</div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="pipelining_2file__stream_8h_source.html#l00378">input()</a>.</p>

</div>
</div>
<a id="a69c66039bc8f2272069a16810f8209e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69c66039bc8f2272069a16810f8209e4">&#9670;&nbsp;</a></span>pull_output()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtpie_1_1pipelining_1_1pullpipe__end.html">pullpipe_end</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1factory.html">factory</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1bits_1_1pull__output__t.html">bits::pull_output_t</a>, <a class="el" href="classtpie_1_1file__stream.html">file_stream</a>&lt;T&gt; &amp;&gt; &gt; tpie::pipelining::pull_output </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtpie_1_1file__stream.html">file_stream</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>fs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A pull-pipe node that writes the pulled items to a file stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fs</td><td>The file stream that items should be written to </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="pipelining_2file__stream_8h_source.html#l00449">449</a> of file <a class="el" href="pipelining_2file__stream_8h_source.html">file_stream.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;                                                                                                    {</div>
<div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;    <span class="keywordflow">return</span> {fs};</div>
<div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="aca26fb8ab96bc2f381574504caa75e52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca26fb8ab96bc2f381574504caa75e52">&#9670;&nbsp;</a></span>pull_output_iterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtpie_1_1pipelining_1_1pullpipe__end.html">pullpipe_end</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1tfactory.html">tfactory</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1bits_1_1pull__output__iterator__t.html">bits::pull_output_iterator_t</a>, <a class="el" href="classtpie_1_1pipelining_1_1Args.html">Args</a>&lt;IT&gt;, IT&gt; &gt; tpie::pipelining::pull_output_iterator </td>
          <td>(</td>
          <td class="paramtype">IT&#160;</td>
          <td class="paramname"><em>to</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A pull-pipe node that writes its given items to the destination pointed to by the given iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to</td><td>An iterator pointing to the destination that items should be written to </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="helpers_8h_source.html#l00621">621</a> of file <a class="el" href="helpers_8h_source.html">helpers.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00621"></a><span class="lineno">  621</span>&#160;                                                                                              {</div>
<div class="line"><a name="l00622"></a><span class="lineno">  622</span>&#160;    <span class="keywordflow">return</span> {to};</div>
<div class="line"><a name="l00623"></a><span class="lineno">  623</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a4d615413e1c535dec77cd44a4236f9f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d615413e1c535dec77cd44a4236f9f7">&#9670;&nbsp;</a></span>pull_reverse_input()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtpie_1_1pipelining_1_1pullpipe__begin.html">pullpipe_begin</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1termfactory.html">termfactory</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1bits_1_1pull__reverse__input__t.html">bits::pull_reverse_input_t</a>&lt;T&gt;, <a class="el" href="classtpie_1_1file__stream.html">file_stream</a>&lt;T&gt; &amp;, <a class="el" href="classtpie_1_1flags.html">stream_options</a>&gt; &gt; tpie::pipelining::pull_reverse_input </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtpie_1_1file__stream.html">file_stream</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>fs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtpie_1_1flags.html">stream_options</a>&#160;</td>
          <td class="paramname"><em>options</em> = <code><a class="el" href="classtpie_1_1flags.html">stream_options</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A pipelining pull-node that reads items in reverse order from the given <a class="el" href="classtpie_1_1file__stream.html" title="Compressed stream.">file_stream</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fs</td><td>The file stream from which it reads items. </td></tr>
    <tr><td class="paramname">options</td><td>Stream options </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="pipelining_2file__stream_8h_source.html#l00409">409</a> of file <a class="el" href="pipelining_2file__stream_8h_source.html">file_stream.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;                                             {</div>
<div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;    <span class="keywordflow">return</span> {fs, options};</div>
<div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a2b16ca3ea552cf3bffabaeec5ebd5be7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b16ca3ea552cf3bffabaeec5ebd5be7">&#9670;&nbsp;</a></span>pull_source()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename fact_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtpie_1_1pipelining_1_1pipe__begin.html">pipe_begin</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1tfactory.html">tfactory</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1bits_1_1pull__source__t.html">bits::pull_source_t</a>, <a class="el" href="classtpie_1_1pipelining_1_1Args.html">Args</a>&lt;fact_t&gt;, fact_t&gt; &gt; tpie::pipelining::pull_source </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtpie_1_1pipelining_1_1pullpipe__begin.html">pullpipe_begin</a>&lt; fact_t &gt;&#160;</td>
          <td class="paramname"><em>from</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A node that pulls items from source and push them into dest. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>The pull source, and the source forwards the number of items, "items" </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="helpers_8h_source.html#l00665">665</a> of file <a class="el" href="helpers_8h_source.html">helpers.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00665"></a><span class="lineno">  665</span>&#160;                                         {</div>
<div class="line"><a name="l00666"></a><span class="lineno">  666</span>&#160;    <span class="keywordflow">return</span> {std::move(from.factory)};</div>
<div class="line"><a name="l00667"></a><span class="lineno">  667</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a94273e51dba887f090f60a87f0a77c94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94273e51dba887f090f60a87f0a77c94">&#9670;&nbsp;</a></span>pull_tee()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtpie_1_1pipelining_1_1pullpipe__middle.html">pullpipe_middle</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1tfactory.html">tfactory</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1bits_1_1pull__tee__t.html">bits::pull_tee_t</a>, <a class="el" href="classtpie_1_1pipelining_1_1Args.html">Args</a>&lt;typename T::item_type&gt;, T &amp;&gt; &gt; tpie::pipelining::pull_tee </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>fs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A pull-pipe node that when pulled from will pull from its source, write its item to disk and then return the item. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fs</td><td>The file stream that items should be written to </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="pipelining_2file__stream_8h_source.html#l00469">469</a> of file <a class="el" href="pipelining_2file__stream_8h_source.html">file_stream.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;                                                                                                   {</div>
<div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;    <span class="keywordflow">return</span> {fs};</div>
<div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a40938c59d6956699ee5b6c322db70476"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40938c59d6956699ee5b6c322db70476">&#9670;&nbsp;</a></span>pull_unique()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename equal_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtpie_1_1pipelining_1_1pullpipe__middle.html">pullpipe_middle</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1tfactory.html">tfactory</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1bits_1_1pull__unique__t.html">bits::pull_unique_t</a>, <a class="el" href="classtpie_1_1pipelining_1_1Args.html">Args</a>&lt;equal_t&gt;, equal_t&gt; &gt; tpie::pipelining::pull_unique </td>
          <td>(</td>
          <td class="paramtype">equal_t&#160;</td>
          <td class="paramname"><em>equal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pull version of unique. </p>
<p>When items are pulled in Whenever a pulled item is same as the previous, it is dropped </p>

<p class="definition">Definition at line <a class="el" href="helpers_8h_source.html#l00687">687</a> of file <a class="el" href="helpers_8h_source.html">helpers.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00687"></a><span class="lineno">  687</span>&#160;                                                                                                 {</div>
<div class="line"><a name="l00688"></a><span class="lineno">  688</span>&#160;    <span class="keywordflow">return</span> {equal};</div>
<div class="line"><a name="l00689"></a><span class="lineno">  689</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a3ac8c3ceb431fe3cd083fbd20cf21a6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ac8c3ceb431fe3cd083fbd20cf21a6e">&#9670;&nbsp;</a></span>push_input_iterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtpie_1_1pipelining_1_1pipe__begin.html">pipe_begin</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1tfactory.html">tfactory</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1bits_1_1push__input__iterator__t.html">bits::push_input_iterator_t</a>, <a class="el" href="classtpie_1_1pipelining_1_1Args.html">Args</a>&lt;IT&gt;, IT, IT&gt; &gt; tpie::pipelining::push_input_iterator </td>
          <td>(</td>
          <td class="paramtype">IT&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IT&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A pipelining node that pushes the items in the range given by two iterators. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>The iterator pointing to the first item </td></tr>
    <tr><td class="paramname">end</td><td>The iterator pointing to the end of the range </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="helpers_8h_source.html#l00587">587</a> of file <a class="el" href="helpers_8h_source.html">helpers.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00587"></a><span class="lineno">  587</span>&#160;                                                                                                         {</div>
<div class="line"><a name="l00588"></a><span class="lineno">  588</span>&#160;    <span class="keywordflow">return</span> {begin, end};</div>
<div class="line"><a name="l00589"></a><span class="lineno">  589</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="af20c4dde69b51b38a3113dd02488fc31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af20c4dde69b51b38a3113dd02488fc31">&#9670;&nbsp;</a></span>push_output_iterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtpie_1_1pipelining_1_1pipe__end.html">pipe_end</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1termfactory.html">termfactory</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1bits_1_1push__output__iterator__t.html">bits::push_output_iterator_t</a>&lt;IT&gt;, IT&gt; &gt; tpie::pipelining::push_output_iterator </td>
          <td>(</td>
          <td class="paramtype">IT&#160;</td>
          <td class="paramname"><em>to</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A node that writes its given items to the destination pointed to by the given iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to</td><td>An iterator pointing to the destination that items should be written to </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="helpers_8h_source.html#l00598">598</a> of file <a class="el" href="helpers_8h_source.html">helpers.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00598"></a><span class="lineno">  598</span>&#160;                                                                                       {</div>
<div class="line"><a name="l00599"></a><span class="lineno">  599</span>&#160;    <span class="keywordflow">return</span> {to};</div>
<div class="line"><a name="l00600"></a><span class="lineno">  600</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="af8c0a94662f2d06e13f43273b6968053"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8c0a94662f2d06e13f43273b6968053">&#9670;&nbsp;</a></span>serialization_input()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtpie_1_1pipelining_1_1pipe__begin.html">pipe_begin</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1factory.html">serialization_bits::input_factory</a>&gt; tpie::pipelining::serialization_input </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtpie_1_1serialization__reader.html">serialization_reader</a> &amp;&#160;</td>
          <td class="paramname"><em>rd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A pipelining node that reads items from a <a class="el" href="classtpie_1_1serialization__reader.html">serialization_reader</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rd</td><td>The reader from which which items should be read </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="serialization_8h_source.html#l00107">107</a> of file <a class="el" href="serialization_8h_source.html">serialization.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;                                                      {</div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;    <span class="keywordflow">return</span> pipe_begin&lt;serialization_bits::input_factory&gt;(&amp;rd);</div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a14597d3a526e50e60da1738b0e81c28a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14597d3a526e50e60da1738b0e81c28a">&#9670;&nbsp;</a></span>serialization_output()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtpie_1_1pipelining_1_1pipe__end.html">pipe_end</a>&lt;typename <a class="el" href="structtpie_1_1pipelining_1_1serialization__bits_1_1output__factory.html">serialization_bits::output_factory</a>&lt;T&gt;::type&gt; tpie::pipelining::serialization_output </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtpie_1_1serialization__writer.html">serialization_writer</a> &amp;&#160;</td>
          <td class="paramname"><em>wr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A pipelining node that writes item to a <a class="el" href="classtpie_1_1serialization__writer.html">serialization_writer</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wr</td><td>The writer to which items should be written </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="serialization_8h_source.html#l00117">117</a> of file <a class="el" href="serialization_8h_source.html">serialization.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;                                                {</div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;    <span class="keywordflow">return</span> <span class="keyword">typename</span> serialization_bits::output_factory&lt;T&gt;::type(&amp;wr);</div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a219b052fec6d05e4ff793194ca78a656"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a219b052fec6d05e4ff793194ca78a656">&#9670;&nbsp;</a></span>serialization_sort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename pred_t  = std::less&lt;void&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtpie_1_1pipelining_1_1pipe__middle.html">pipe_middle</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1serialization__bits_1_1sort__factory.html">serialization_bits::sort_factory</a>&lt;pred_t&gt; &gt; tpie::pipelining::serialization_sort </td>
          <td>(</td>
          <td class="paramtype">const pred_t &amp;&#160;</td>
          <td class="paramname"><em>p</em> = <code>std::less&lt;void&gt;()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pipelining sorter using the given predicate. </p>

<p class="definition">Definition at line <a class="el" href="serialization__sort_8h_source.html#l00379">379</a> of file <a class="el" href="serialization__sort_8h_source.html">serialization_sort.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;                                                     {</div>
<div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;    <span class="keyword">typedef</span> serialization_bits::sort_factory&lt;pred_t&gt; fact;</div>
<div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;    <span class="keywordflow">return</span> pipe_middle&lt;fact&gt;(fact(p)).name(<span class="stringliteral">&quot;Sort&quot;</span>);</div>
<div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="pipe__base_8h_source.html#l00090">tpie::pipelining::bits::pipe_base&lt; child_t &gt;::name()</a>.</p>

</div>
</div>
<a id="a056b07e01a80b672521c04c866455bf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a056b07e01a80b672521c04c866455bf4">&#9670;&nbsp;</a></span>sort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename pred_t  = std::less&lt;void&gt;, typename store_t  = default_store&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtpie_1_1pipelining_1_1pipe__middle.html">pipe_middle</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1bits_1_1sort__factory.html">bits::sort_factory</a>&lt;pred_t, store_t&gt; &gt; tpie::pipelining::sort </td>
          <td>(</td>
          <td class="paramtype">const pred_t &amp;&#160;</td>
          <td class="paramname"><em>p</em> = <code>std::less&lt;void&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">store_t&#160;</td>
          <td class="paramname"><em>store</em> = <code><a class="el" href="structtpie_1_1dynamic__store.html">default_store</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A pipelining node that sorts large elements indirectly by using a store and a given predicate. </p>

<p class="definition">Definition at line <a class="el" href="pipelining_2sort_8h_source.html#l00452">452</a> of file <a class="el" href="pipelining_2sort_8h_source.html">sort.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;                                                                      {</div>
<div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;    <span class="keyword">typedef</span> bits::sort_factory&lt;pred_t, store_t&gt; fact;</div>
<div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;    <span class="keywordflow">return</span> pipe_middle&lt;fact&gt;(fact(p, store)).name(<span class="stringliteral">&quot;Sort&quot;</span>);</div>
<div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="pipe__base_8h_source.html#l00090">tpie::pipelining::bits::pipe_base&lt; child_t &gt;::name()</a>.</p>

</div>
</div>
<a id="ac7f4bf6228dcee5efb1649c95df8c4ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7f4bf6228dcee5efb1649c95df8c4ed">&#9670;&nbsp;</a></span>store_sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename store_t , typename pred_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtpie_1_1pipelining_1_1pipe__middle.html">pipe_middle</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1bits_1_1sort__factory.html">bits::sort_factory</a>&lt;pred_t, store_t&gt; &gt; tpie::pipelining::store_sort </td>
          <td>(</td>
          <td class="paramtype">const pred_t &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">store_t&#160;</td>
          <td class="paramname"><em>store</em> = <code>store_t()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A pipelining node that sorts large elements indirectly by using a store and the given predicate. </p>

<p class="definition">Definition at line <a class="el" href="pipelining_2sort_8h_source.html#l00441">441</a> of file <a class="el" href="pipelining_2sort_8h_source.html">sort.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;                                                      {</div>
<div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;    <span class="keyword">typedef</span> bits::sort_factory&lt;pred_t, store_t&gt; fact;</div>
<div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;    <span class="keywordflow">return</span> pipe_middle&lt;fact&gt;(fact(p, store)).name(<span class="stringliteral">&quot;Sort&quot;</span>);</div>
<div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="pipe__base_8h_source.html#l00090">tpie::pipelining::bits::pipe_base&lt; child_t &gt;::name()</a>.</p>

</div>
</div>
<a id="a3a6884d071abf3893b0cd29c1f1f9cbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a6884d071abf3893b0cd29c1f1f9cbd">&#9670;&nbsp;</a></span>store_sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename store_t &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtpie_1_1pipelining_1_1pipe__middle.html">pipe_middle</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1bits_1_1sort__factory.html">bits::sort_factory</a>&lt;std::less&lt;void&gt;, store_t&gt; &gt; tpie::pipelining::store_sort </td>
          <td>(</td>
          <td class="paramtype">store_t&#160;</td>
          <td class="paramname"><em>store</em> = <code>store_t()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A pipelining node that sorts large elements indirectly by using a store and std::less. </p>

<p class="definition">Definition at line <a class="el" href="pipelining_2sort_8h_source.html#l00430">430</a> of file <a class="el" href="pipelining_2sort_8h_source.html">sort.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;                                    {</div>
<div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;    <span class="keyword">typedef</span> bits::sort_factory&lt;std::less&lt;void&gt;, store_t&gt; fact;</div>
<div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;    <span class="keywordflow">return</span> pipe_middle&lt;fact&gt;(fact(std::less&lt;void&gt;(), store)).name(<span class="stringliteral">&quot;Sort&quot;</span>);</div>
<div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;}</div>
</div><!-- fragment -->
<p class="reference">References <a class="el" href="pipe__base_8h_source.html#l00090">tpie::pipelining::bits::pipe_base&lt; child_t &gt;::name()</a>.</p>

</div>
</div>
<a id="a6988cf4e74c17c45538ad9461a9de102"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6988cf4e74c17c45538ad9461a9de102">&#9670;&nbsp;</a></span>tee()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtpie_1_1pipelining_1_1pipe__middle.html">pipe_middle</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1tfactory.html">tfactory</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1bits_1_1tee__t.html">bits::tee_t</a>, <a class="el" href="classtpie_1_1pipelining_1_1Args.html">Args</a>&lt;typename T::item_type&gt;, T &amp;&gt; &gt; tpie::pipelining::tee </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>fs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A pipelining node that writes the pushed to a file stream and then pushes the items to the next node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fs</td><td>The file stream that items should be written to </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="pipelining_2file__stream_8h_source.html#l00459">459</a> of file <a class="el" href="pipelining_2file__stream_8h_source.html">file_stream.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;                                                                                     {</div>
<div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;    <span class="keywordflow">return</span> {fs};</div>
<div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="addd3d020dacea6455669b8cf01ddb0a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addd3d020dacea6455669b8cf01ddb0a9">&#9670;&nbsp;</a></span>typed_push_output_iterator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Item , typename IT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtpie_1_1pipelining_1_1pipe__end.html">pipe_end</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1termfactory.html">termfactory</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1bits_1_1push__output__iterator__t.html">bits::push_output_iterator_t</a>&lt;IT, Item&gt;, IT&gt; &gt; tpie::pipelining::typed_push_output_iterator </td>
          <td>(</td>
          <td class="paramtype">IT&#160;</td>
          <td class="paramname"><em>to</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A node that writes its given items to the destination pointed to by the given iterator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to</td><td>An iterator pointing to the destination that items should be written to </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Item</td><td>The type of the pushed items </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="helpers_8h_source.html#l00610">610</a> of file <a class="el" href="helpers_8h_source.html">helpers.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00610"></a><span class="lineno">  610</span>&#160;                                                                                                   {</div>
<div class="line"><a name="l00611"></a><span class="lineno">  611</span>&#160;    <span class="keywordflow">return</span> {to};</div>
<div class="line"><a name="l00612"></a><span class="lineno">  612</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad8c0664c8f94f9666def0d4c444fc1dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8c0664c8f94f9666def0d4c444fc1dd">&#9670;&nbsp;</a></span>unique()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename equal_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtpie_1_1pipelining_1_1pipe__middle.html">pipe_middle</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1tfactory.html">tfactory</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1bits_1_1unique__t.html">bits::unique_t</a>, <a class="el" href="classtpie_1_1pipelining_1_1Args.html">Args</a>&lt;equal_t&gt;, equal_t&gt; &gt; tpie::pipelining::unique </td>
          <td>(</td>
          <td class="paramtype">equal_t&#160;</td>
          <td class="paramname"><em>equal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Filter consecutive duplicates out. </p>
<p>When items are pushed in Whenever a pushed item is same as the previous, it is dropped </p>

<p class="definition">Definition at line <a class="el" href="helpers_8h_source.html#l00676">676</a> of file <a class="el" href="helpers_8h_source.html">helpers.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00676"></a><span class="lineno">  676</span>&#160;                                                                                   {</div>
<div class="line"><a name="l00677"></a><span class="lineno">  677</span>&#160;    <span class="keywordflow">return</span> {equal};</div>
<div class="line"><a name="l00678"></a><span class="lineno">  678</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a0a483dc27681b8a8c37b38e4fca54ee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a483dc27681b8a8c37b38e4fca54ee7">&#9670;&nbsp;</a></span>unzip()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename fact_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtpie_1_1pipelining_1_1pipe__middle.html">pipe_middle</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1tfactory.html">tfactory</a>&lt;<a class="el" href="structtpie_1_1pipelining_1_1bits_1_1unzip__t.html">bits::unzip_t</a>, <a class="el" href="classtpie_1_1pipelining_1_1Args.html">Args</a>&lt;fact_t&gt;, fact_t&gt; &gt; tpie::pipelining::unzip </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtpie_1_1pipelining_1_1pipe__end.html">pipe_end</a>&lt; fact_t &gt;&#160;</td>
          <td class="paramname"><em>to</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create unzip pipe node. </p>
<p>Whenever a std::pair&lt;A,B&gt;(a,b) is pushed to the unzip node, a is pushed to its destination, and then b is pushed to "to" </p>

<p class="definition">Definition at line <a class="el" href="helpers_8h_source.html#l00519">519</a> of file <a class="el" href="helpers_8h_source.html">helpers.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;                           {</div>
<div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;    <span class="keywordflow">return</span> {std::move(to.factory)};</div>
<div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a715b7f70cec7f2c4a3be9300e50aade4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a715b7f70cec7f2c4a3be9300e50aade4">&#9670;&nbsp;</a></span>visit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtpie_1_1pipelining_1_1pipe__middle.html">pipe_middle</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1tfactory.html">tfactory</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1bits_1_1visit__t.html">bits::visit_t</a>, <a class="el" href="classtpie_1_1pipelining_1_1Args.html">Args</a>&lt;F&gt;, F&gt; &gt; tpie::pipelining::visit </td>
          <td>(</td>
          <td class="paramtype">const F &amp;&#160;</td>
          <td class="paramname"><em>functor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A pipelining node that applies a functor to elements pushed to it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">functor</td><td>The visitor to use </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="visit_8h_source.html#l00056">56</a> of file <a class="el" href="visit_8h_source.html">visit.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;                                                                         {</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;    <span class="keywordflow">return</span> {functor};</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac8f709136c57b612cf9336b44d3e6ff1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8f709136c57b612cf9336b44d3e6ff1">&#9670;&nbsp;</a></span>zero_source()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtpie_1_1pipelining_1_1pullpipe__begin.html">pullpipe_begin</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1termfactory.html">termfactory</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1bits_1_1zero__source__t.html">bits::zero_source_t</a>&lt;T&gt; &gt; &gt; tpie::pipelining::zero_source </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a dummy pull begin pipe node. </p>
<p>Whenever an element of type T is pushed to the null_sink it is disregarded </p>

<p class="definition">Definition at line <a class="el" href="helpers_8h_source.html#l00552">552</a> of file <a class="el" href="helpers_8h_source.html">helpers.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;{<span class="keywordflow">return</span> {}; }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad647b0fea511df644718470b27740c00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad647b0fea511df644718470b27740c00">&#9670;&nbsp;</a></span>zip()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename fact_t &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtpie_1_1pipelining_1_1pipe__middle.html">pipe_middle</a>&lt;<a class="el" href="classtpie_1_1pipelining_1_1tfactory.html">tfactory</a>&lt;<a class="el" href="structtpie_1_1pipelining_1_1bits_1_1zip__t.html">bits::zip_t</a>, <a class="el" href="classtpie_1_1pipelining_1_1Args.html">Args</a>&lt;fact_t&gt;, fact_t&gt; &gt; tpie::pipelining::zip </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtpie_1_1pipelining_1_1pullpipe__begin.html">pullpipe_begin</a>&lt; fact_t &gt;&#160;</td>
          <td class="paramname"><em>from</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a zip pipe node. </p>
<p>Whenever an element a is pushed to the zip node, an element b is pulled from the "from" node, and std::make_pair(a,b) is pushed to the destination </p>

<p class="definition">Definition at line <a class="el" href="helpers_8h_source.html#l00532">532</a> of file <a class="el" href="helpers_8h_source.html">helpers.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;                                 {</div>
<div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;    <span class="keywordflow">return</span> {std::move(from.factory)};</div>
<div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;}</div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="anamespacetpie_1_1pipelining_html_a16a8744ad1f202f05bb32a2f60545ed4abf58a1a989c94ba7db61f23b21309b57"><div class="ttname"><a href="namespacetpie_1_1pipelining.html#a16a8744ad1f202f05bb32a2f60545ed4abf58a1a989c94ba7db61f23b21309b57">tpie::pipelining::arbitrary_order</a></div><div class="ttdeci">@ arbitrary_order</div><div class="ttdoc">Do not maintain order; push items as soon as a worker has processed them.</div><div class="ttdef"><b>Definition:</b> <a href="maintain__order__type_8h_source.html#l00032">maintain_order_type.h:32</a></div></div>
<div class="ttc" id="anamespacetpie_1_1pipelining_html_a16a8744ad1f202f05bb32a2f60545ed4a38a2c9bdf017a8b8d85054961d1c9dc8"><div class="ttname"><a href="namespacetpie_1_1pipelining.html#a16a8744ad1f202f05bb32a2f60545ed4a38a2c9bdf017a8b8d85054961d1c9dc8">tpie::pipelining::maintain_order</a></div><div class="ttdeci">@ maintain_order</div><div class="ttdoc">Maintain order; push items in the same order that a single thread would have.</div><div class="ttdef"><b>Definition:</b> <a href="maintain__order__type_8h_source.html#l00035">maintain_order_type.h:35</a></div></div>
<div class="ttc" id="aclasstpie_1_1ami_1_1stream_html"><div class="ttname"><a href="classtpie_1_1ami_1_1stream.html">tpie::ami::stream</a></div><div class="ttdef"><b>Definition:</b> <a href="stream_8h_source.html#l00031">stream.h:31</a></div></div>
<div class="ttc" id="anamespacetpie_1_1pipelining_html_a97aad0575703e1809b1edfecbd0a3e8a"><div class="ttname"><a href="namespacetpie_1_1pipelining.html#a97aad0575703e1809b1edfecbd0a3e8a">tpie::pipelining::forwarder</a></div><div class="ttdeci">pipe_middle&lt; factory&lt; bits::Forwarder, std::vector&lt; std::pair&lt; std::string, any_noncopyable &gt; &gt; &gt; &gt; forwarder(std::vector&lt; std::pair&lt; std::string, any_noncopyable &gt; &gt; items)</div><div class="ttdoc">A pipelining node that will forward values on prepare, and.</div><div class="ttdef"><b>Definition:</b> <a href="forwarder_8h_source.html#l00058">forwarder.h:58</a></div></div>
<div class="ttc" id="anamespacetpie_1_1pipelining_html_a4c894e9fba7cb73afb0a62d2d67d0237"><div class="ttname"><a href="namespacetpie_1_1pipelining.html#a4c894e9fba7cb73afb0a62d2d67d0237">tpie::pipelining::parallel</a></div><div class="ttdeci">pipe_middle&lt; parallel_bits::factory&lt; fact_t &gt; &gt; parallel(pipe_middle&lt; fact_t &gt; &amp;&amp;fact, maintain_order_type maintainOrder, size_t numJobs, size_t bufSize=2048)</div><div class="ttdoc">Runs a pipeline in multiple threads.</div><div class="ttdef"><b>Definition:</b> <a href="pipes_8h_source.html#l00040">pipes.h:40</a></div></div>
<div class="ttc" id="anamespacetpie_1_1pipelining_html_aec8021f755b4600d49276267552aa32b"><div class="ttname"><a href="namespacetpie_1_1pipelining.html#aec8021f755b4600d49276267552aa32b">tpie::pipelining::input</a></div><div class="ttdeci">pipe_begin&lt; factory&lt; bits::input_t, file_stream&lt; T &gt; &amp;, stream_options &gt; &gt; input(file_stream&lt; T &gt; &amp;fs, stream_options options=stream_options())</div><div class="ttdoc">Pipelining nodes that pushes the contents of the given file stream to the next node in the pipeline.</div><div class="ttdef"><b>Definition:</b> <a href="pipelining_2file__stream_8h_source.html#l00378">file_stream.h:378</a></div></div>
<div class="ttc" id="anamespacetpie_html_a18fbf567e45c8a656464a6777ae5996f"><div class="ttname"><a href="namespacetpie.html#a18fbf567e45c8a656464a6777ae5996f">tpie::default_worker_count</a></div><div class="ttdeci">TPIE_EXPORT memory_size_type default_worker_count()</div><div class="ttdoc">Return the number of job threads initialized by the job framework in init_job().</div></div>
<div class="ttc" id="anamespacetpie_1_1pipelining_html_aa1ecad88e2e14856799abf63e36abd4b"><div class="ttname"><a href="namespacetpie_1_1pipelining.html#aa1ecad88e2e14856799abf63e36abd4b">tpie::pipelining::output</a></div><div class="ttdeci">pipe_end&lt; termfactory&lt; bits::output_t&lt; T &gt;, file_stream&lt; T &gt; &amp; &gt; &gt; output(file_stream&lt; T &gt; &amp;fs)</div><div class="ttdoc">A pipelining node that writes the pushed items to a file stream.</div><div class="ttdef"><b>Definition:</b> <a href="pipelining_2file__stream_8h_source.html#l00430">file_stream.h:430</a></div></div>
<div class="ttc" id="aclasstpie_1_1ami_1_1stack_html"><div class="ttname"><a href="classtpie_1_1ami_1_1stack.html">tpie::ami::stack</a></div><div class="ttdoc">An implementation of an external-memory stack compatible with the old AMI interface.</div><div class="ttdef"><b>Definition:</b> <a href="stack_8h_source.html#l00180">stack.h:180</a></div></div>
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
      <li class="footer">from TPIE 4739728 (<a href="//github.com/thomasmoelhave/tpie/tree/4739728">browse source</a>). Generated on Mon May 23 2022 23:38:37 by
<a href="http://www.doxygen.org/index.html">Doxygen</a> 1.8.17 </li>
    </ul>
  </div>
</body>
</html>
