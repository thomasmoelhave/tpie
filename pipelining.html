<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>Pipelining</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="madalgo-doxygen.css" rel="stylesheet" type="text/css"/>
<link href="printstyle.css" rel="stylesheet" type="text/css" media="print" />
</head>
<body>
<div id="top">
<div id="titlearea">
<h1 id="projectname">TPIE</h1>
<span class="version"><a href="//github.com/thomasmoelhave/tpie/tree/4739728">4739728</a></span>
</div>
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('pipelining.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Pipelining </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="sec_pipeintro"></a>
Pipelining concepts</h1>
<p>Some algorithms can be expressed in terms of stream sweeps. For instance, the Graham sweep algorithm for computing the convex hull of a set of points will sweep through the input points from left to right, maintaining the upper convex hull and the lower convex hull in a stack of points. Thus, the algorithm consists of four components: reading the input, sorting by x-coordinate, computing the upper and lower hull, and reporting the convex polygon.</p>
<p>The pipelining framework is used to implement such so-called streaming algorithms that process streams of items in this manner. The programmer implements the specialized components needed for the algorithm (computing the upper and lower hull, for instance), and stitches them together with built-ins such as reading, sorting and writing.</p>
<p>In this way, we may test each component individually and reuse them in multiple contexts. Without the TPIE pipelining framework, streaming algorithms are often implemented as monolithic classes with multiple interdependent methods that do not facilitate individual development and testing. Using virtual polymorphism may enable unit testing of components, but the virtual method speed penalty paid per item per operation is too high a price to pay in our case.</p>
<p>What we want instead is a kind of compile-time polymorphism: Implementations of operations that use C++ generic programming to let the programmer mix and match at code time, but have the methods inlined and fused together at compile time. Without an underlying framework, this kind of architecture will lead to a lot of typedefs that are overly verbose and somewhat unmaintainable.</p>
<p>The pipelining framework provides compile-time polymorphism along with high maintainability, high testability and low verbosity.</p>
<h1><a class="anchor" id="sec_node"></a>
Nodes</h1>
<p>In TPIE pipelining, a <em>node</em> is any object that implements <code><a class="el" href="classtpie_1_1pipelining_1_1node.html" title="Base class of all nodes.">tpie::pipelining::node</a></code>. A node processes items of a stream in some fashion, typically by implementing a <code>push()</code> method which processes an item and pushes to a <em>destination</em> node.</p>
<p>The node can implement a <code>begin()</code> and/or an <code>end()</code> method to perform some initialization or finalization. The framework guarantees that <code>begin()</code> and <code>end()</code> are called in an order such that the destination of the node is ready to accept items via <code>push()</code> when <code>begin()</code> and <code>end()</code> are called.</p>
<p><img src="pipelining_sequence.png" alt="" class="inline"/></p>
<p>Since the framework computes the topological order of the nodes of the actor graph (that is, using the actor edges as in the above two figures) and the framework requires that the actor graph is acyclic, the nodes may call <code>push()</code>, <code>pull()</code> and <code>can_pull()</code> in both <code>begin()</code> and <code>end()</code> even when push and pull nodes are mixed together.</p>
<p>In code, a pipelining node implementation may look like the following.</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>tp = <a class="code" href="namespacetpie_1_1pipelining.html">tpie::pipelining</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> dest_t&gt;</div>
<div class="line"><span class="keyword">class </span>hello_world_type : <span class="keyword">public</span> tp::node {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    hello_world_type(dest_t dest): dest(std::move(dest)) {}</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> push(<span class="keyword">const</span> <span class="keywordtype">size_t</span> &amp; item) {</div>
<div class="line">        <span class="keywordflow">if</span> ((item % 2) == 0)</div>
<div class="line">            dest.push(item/2);</div>
<div class="line">        <span class="keywordflow">else</span></div>
<div class="line">            dest.push(3*item+1);</div>
<div class="line">    }</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    dest_t dest;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> tp::pipe_middle&lt;tp::factory&lt;hello_world_type&gt; &gt; hello_world;</div>
</div><!-- fragment --><p>A node implementation may supply the following extra information to the framework which is otherwise inferred in the ordinary case.</p>
<table class="doxtable">
<tr>
<th colspan="6" align="center"><a class="el" href="structtpie_1_1pipelining_1_1node__parameters.html">tpie::pipelining::node_parameters</a>  </th></tr>
<tr>
<td colspan="3" align="center">Memory </td><td colspan="2" align="center">Name </td><td colspan="1" align="center">Progress  </td></tr>
<tr>
<td align="left">Minimum <code>memory_size_type</code>  </td><td align="left">Maximum <code>memory_size_type</code>  </td><td align="left">Priority <code>double</code>  </td><td align="left">Name <code>std::string</code>  </td><td align="left">Priority <code>int</code>  </td><td align="left">Total steps <code>stream_size_type</code>   </td></tr>
</table>
<p>If the node needs to allocate a buffer in <code>begin()</code> which is deallocated in <code>end()</code>, it can specify the size of this buffer in bytes using a call to <code>set_minimum_memory()</code> in the constructor, in <code>prepare()</code> or in <code>propagate()</code>. If the node can benefit from a larger buffer, it should set a positive memory priority for itself using a call to <code>set_memory_fraction()</code>. If there is a limit to the amount of memory it can use, it should declare this limit using <code>set_maximum_memory()</code>. By default, the minimum memory is zero bytes, and the memory priority is zero, meaning the node is assigned its minimum memory. The default maximum memory is infinity.</p>
<p>If the node has multiple pull sources and/or push destinations, these must be specified using <code>add_push_destination</code> and <code>add_pull_source</code> in the constructor.</p>
<p>In <code>propagate()</code>, <code>begin()</code> and <code>end()</code>, the node may access the amount of memory assigned to it using <code>get_available_memory()</code>.</p>
<p>For debugging, each node object has a <em>name</em>, which defaults to a pretty version of the name provided by <code>typeid(*this)</code>.name(). The name can be set by a call to <code>set_name()</code> in the constructor.</p>
<p>If the node has multiple overloads of the <code>push()</code> method, it must declare a primary <code>item_type</code> as a public member typedef. Otherwise, the framework uses metaprogramming to discover the type accepted by <code>push()</code>.</p>
<p>Here, we restate the above implementation with all the defaults spelled out:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>tp = <a class="code" href="namespacetpie_1_1pipelining.html">tpie::pipelining</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> dest_t&gt;</div>
<div class="line"><span class="keyword">class </span>hello_world_type : <span class="keyword">public</span> tp::node {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">typedef</span> <span class="keywordtype">size_t</span> <a class="code" href="namespacetpie_1_1pipelining.html#ad25e30e578fb780f9fff601b94fed33b">item_type</a>;</div>
<div class="line"> </div>
<div class="line">    hello_world_type(dest_t dest)</div>
<div class="line">        : dest(std::move(dest))</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// The default name is the class name, capitalized,</span></div>
<div class="line">        <span class="comment">// with underscores replaced by spaces,</span></div>
<div class="line">        <span class="comment">// removing a trailing &quot;_type&quot; or &quot;_t&quot;.</span></div>
<div class="line">        set_name(<span class="stringliteral">&quot;Hello world&quot;</span>);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// If we have just one push destination or pull source,</span></div>
<div class="line">        <span class="comment">// this is inferred by the framework if we do not specify any.</span></div>
<div class="line">        add_push_destination(dest);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> prepare()<span class="keyword"> override </span>{</div>
<div class="line">        set_minimum_memory((tpie::memory_size_type) 0);</div>
<div class="line">        <span class="comment">//set_maximum_memory((tpie::memory_size_type) infinity);</span></div>
<div class="line">        set_memory_fraction((<span class="keywordtype">double</span>) 0.0);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> propagate()<span class="keyword"> override </span>{</div>
<div class="line">        <span class="comment">// optionally access get_available_memory</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> begin()<span class="keyword"> override </span>{</div>
<div class="line">        <span class="comment">// allocate buffer of size get_available_memory</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> push(<span class="keyword">const</span> <span class="keywordtype">size_t</span> &amp; item) {</div>
<div class="line">        <span class="keywordflow">if</span> ((item % 2) == 0) {</div>
<div class="line">            dest.push(item/2);</div>
<div class="line">        } <span class="keywordflow">else</span> {</div>
<div class="line">            dest.push(3*item+1);</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> end()<span class="keyword"> override </span>{</div>
<div class="line">        <span class="comment">// deallocate buffer</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    dest_t dest;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> tp::pipe_middle&lt;tp::factory&lt;hello_world_type&gt; &gt; hello_world;</div>
</div><!-- fragment --><h1><a class="anchor" id="sec_pull"></a>
Pull nodes</h1>
<p>In some applications it might be easier to express the operation in terms of pulling items from a source and returning a processed item. This is the style used by STL iterators, and it is the style preferred by STXXL, another framework which implements pipelining.</p>
<p>In this case, a TPIE pipelining node should implement the two methods <code>pull()</code> and <code>can_pull()</code>. Again, the framework ensures that it is permitted to call <code>pull()</code> and <code>can_pull()</code> in <code>begin()</code> and <code>end()</code>.</p>
<p><img src="pipelining_sequence_pull.png" alt="" class="inline"/></p>
<p>The implementation details of pull nodes are similar to regular nodes. The following is an example of a simple pull node. </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> source_t&gt;</div>
<div class="line"><span class="keyword">class </span>pull_hello_world_type : <span class="keyword">public</span> node {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">typedef</span> <span class="keywordtype">int</span> <a class="code" href="namespacetpie_1_1pipelining.html#ad25e30e578fb780f9fff601b94fed33b">item_type</a>;</div>
<div class="line">    pull_hello_world_type(source_t source) : source(std::move(source)) {</div>
<div class="line">        add_pull_source(source);</div>
<div class="line">    }</div>
<div class="line">    <a class="code" href="namespacetpie_1_1pipelining.html#ad25e30e578fb780f9fff601b94fed33b">item_type</a> pull() {</div>
<div class="line">        <span class="keywordtype">int</span> item = source.pull();</div>
<div class="line">        <span class="keywordflow">if</span> (item % 2 == 0)</div>
<div class="line">            <span class="keywordflow">return</span> item/2;</div>
<div class="line">        <span class="keywordflow">return</span> (3 * item + 1);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordtype">bool</span> can_pull() {</div>
<div class="line">        <span class="keywordflow">return</span> source.can_pull();</div>
<div class="line">    }</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    source_t source;</div>
<div class="line">};</div>
<div class="line"><span class="keyword">typedef</span> pullpipe_middle&lt;factory&lt;pull_hello_world_type&gt; &gt; pull_hello_world;</div>
</div><!-- fragment --><h1><a class="anchor" id="sec_forming_pipelines"></a>
Forming pipelines</h1>
<p>When nodes are used together they form a pipeline. When a pipeline is run, the items from the first node - the iniator node - is pushed through each node and into the last node where they are written disk or processed in some similar fashion. The following is a simple example using the <code>hello_world</code> node and some of the nodes in the pipelining library. Pull pipelines are created the same way, but by using pull nodes only.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <a class="code" href="namespacetpie.html#a8086afebcb2cbd02fd7c41a1bfcf4925">tpie::tpie_init</a>();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Calling tpie_finish() before the pipeline is destructed would result in a segmentation fault. A new scope is created to avoid this.</span></div>
<div class="line">    {</div>
<div class="line">    <a class="code" href="namespacetpie.html#a81742e80132b2ad62ebe12b38b68d1c5">tpie::get_memory_manager</a>().<a class="code" href="classtpie_1_1resource__manager.html#a0dccdd44fc2b6d68bc3976056900cff9">set_limit</a>(50*1024*1024);</div>
<div class="line"> </div>
<div class="line">    pipeline p = <a class="code" href="namespacetpie_1_1pipelining.html#ac08cd229124e38812ddee98a6ad0bb73">scanf_ints</a>() <span class="comment">// Read integers from standard input</span></div>
<div class="line">        | hello_world() <span class="comment">// Push the items through the hello_world node.</span></div>
<div class="line">        | <a class="code" href="namespacetpie_1_1pipelining.html#ad8185baaeedfd95e3d9fcfae0461441c">printf_ints</a>(); <span class="comment">// Print the integers.</span></div>
<div class="line">    p(); <span class="comment">// run the pipeline</span></div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <a class="code" href="namespacetpie.html#acbb913e5f9654a6f0cd7cb226c37bcc0">tpie::tpie_finish</a>();</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="sec_pipe_memory"></a>
Memory assignment</h1>
<p>Each node has three properties that control how much memory is assigned to it: its minimum memory, its maximum memory and its memory priority. The framework guarantees that the amount of memory assigned to the node is between the minimum and the maximum of the node, and in the absence of memory limits, memory is distributed proportional to the memory priority.</p>
<p><img src="pipelining_memory.png" alt="" class="inline"/></p>
<p>The memory assignment is implemented by a binary search for the parameter c such that the sum of assigned memory is equal to the available memory.</p>
<p>If there is not enough available memory in total to satisfy all minimum memory requirements, a warning is printed to the log and memory overusage can be expected.</p>
<h1><a class="anchor" id="sec_pipe_oob"></a>
Out-of-band data</h1>
<p>Sometimes it is useful to pass <em>metadata</em> between nodes before <code>begin()</code> is called. For this purpose, the TPIE pipelining framework lets nodes call <code>can_fetch()</code>, <code>fetch()</code> and <code>forward()</code> in the methods <code>prepare()</code> and <code>propagate()</code>.</p>
<p>Each piece of metadata is identified by a string, and <code>can_fetch</code> should be called before <code>fetch</code> to ensure that the metadata has actually been forwarded.</p>
<p>The method <code>fetch</code> takes a required template parameter which is the type of data to fetch. Internally, metadata is stored using <code>any_noncopyable</code>, and the method <code>fetch_any</code> fetches metadata just like <code>fetch</code>, except it returns the <code>any_noncopyable</code> object directly without using <code>any_cast</code>. An optional third argument <code>k</code> may be passed as well. This determines the maximum distance that the item should be forwarded. This lets the framework avoid doing extra work if the data is only needed in the next few nodes.</p>
<p>Using <code>forward</code>, a node may forward metadata to its successors in the item flow graph. That is, metadata is sent from item sources to item sinks; this is the actor order in push pipelines, and the reverse actor order in pull pipelines.</p>
<p>The metadata with the identifier <code>items</code> should be of type <code>tpie::stream_size_type</code> and should contain an upper bound on the number of items pushed to the destination. This is used among others by the sorter in the pipelining library to adjust the sizes of internal buffers.</p>
<h1><a class="anchor" id="sec_pipe_datastructures"></a>
Auxiliary datastructures</h1>
<p>It is sometimes useful to keep data in datastructures that exist across multiple nodes and phases. The pipelining framework provides methods to register such datastructures and assign memory limits and priorities to them.</p>
<p>Using <code>register_datastructure_usage</code>, a node may register the usage of a datastructure. Afterwards, the memory limits of the datastructure is set by calling <code>set_datastructure_memory_limits</code>.</p>
<p>When the memory assignment has taken place, the amount of memory available to the datastructure is accessible via the <code>get_datastructure_memory</code> method. Additionaly, a pointer to the datastructure can be set and retrieved by calling <code>set_datastructure</code> and <code>get_datastructure</code> respectively.</p>
<p>If you want to see an example pipelining program using auxiliary datastructures, checkout <code>apps/pipelining_datastructures</code> in the repository.</p>
<h1><a class="anchor" id="sec_passive"></a>
Passive nodes</h1>
<p>Several passive nodes have been implemented in the pipelining library. These node accepts items pushed to them and allow items to be pulled from them. The following is a bare-bones example of a pipeline that uses a passive buffer. The <code>square</code> node pulls integers from a passive buffer and pushes the square of the integer into its destination node.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> source_t&gt;</div>
<div class="line"><span class="keyword">class </span>square_t {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> dest_t&gt;</div>
<div class="line">    <span class="keyword">class </span>type : <span class="keyword">public</span> node {</div>
<div class="line">    <span class="keyword">public</span>:</div>
<div class="line">        <span class="keyword">typedef</span> <span class="keywordtype">int</span> <a class="code" href="namespacetpie_1_1pipelining.html#ad25e30e578fb780f9fff601b94fed33b">item_type</a>;</div>
<div class="line"> </div>
<div class="line">        type(dest_t dest, source_t src)</div>
<div class="line">            : dest(std::move(dest))</div>
<div class="line">            , puller(src.construct())</div>
<div class="line">        {</div>
<div class="line">            add_push_destination(dest);</div>
<div class="line">            add_pull_source(puller);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">virtual</span> <span class="keywordtype">void</span> go()<span class="keyword"> override </span>{</div>
<div class="line">            <span class="keywordflow">while</span> (puller.can_pull()) {</div>
<div class="line">                <span class="keywordtype">int</span> a = puller.pull();</div>
<div class="line"> </div>
<div class="line">                dest.push(a * a);</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">private</span>:</div>
<div class="line">        dest_t dest;</div>
<div class="line">        <span class="keyword">typename</span> source_t::constructed_type puller;</div>
<div class="line">    };</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> source_t&gt;</div>
<div class="line"><span class="keyword">inline</span> pipe_begin&lt;tempfactory&lt;square_t&lt;source_t&gt;, source_t&gt; &gt; square(<span class="keyword">const</span> source_t &amp; source) {</div>
<div class="line">    <span class="keywordflow">return</span> tempfactory&lt;square_t&lt;source_t&gt;, source_t &gt;(source);</div>
<div class="line">}</div>
</div><!-- fragment --> <div class="fragment"><div class="line"><span class="keywordtype">int</span> main() {</div>
<div class="line">    <a class="code" href="namespacetpie.html#a8086afebcb2cbd02fd7c41a1bfcf4925">tpie_init</a>();</div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="namespacetpie.html#a81742e80132b2ad62ebe12b38b68d1c5">get_memory_manager</a>().<a class="code" href="classtpie_1_1resource__manager.html#a0dccdd44fc2b6d68bc3976056900cff9">set_limit</a>(50*1024*1024);</div>
<div class="line"> </div>
<div class="line">        passive_buffer&lt;int&gt; <a class="code" href="namespacetpie_1_1pipelining.html#a877590b7fc6795fe07d7674323bbf92e">buffer</a>;</div>
<div class="line">        pipeline p1 = <a class="code" href="namespacetpie_1_1pipelining.html#ac08cd229124e38812ddee98a6ad0bb73">scanf_ints</a>() | <a class="code" href="namespacetpie_1_1pipelining.html#a877590b7fc6795fe07d7674323bbf92e">buffer</a>.input();</div>
<div class="line">        pipeline p2 = square(<a class="code" href="namespacetpie_1_1pipelining.html#a877590b7fc6795fe07d7674323bbf92e">buffer</a>.output()) | <a class="code" href="namespacetpie_1_1pipelining.html#ad8185baaeedfd95e3d9fcfae0461441c">printf_ints</a>();</div>
<div class="line"> </div>
<div class="line">        p1();</div>
<div class="line">    }</div>
<div class="line">    <a class="code" href="namespacetpie.html#acbb913e5f9654a6f0cd7cb226c37bcc0">tpie_finish</a>();</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>A full list of passive nodes can be seen at <a class="el" href="pipelining_nodes.html">Pipelining Nodes</a>. Another example of the usage of a passive node can be seen in <code>apps/pipelining_passive_sorter</code>.</p>
<h1><a class="anchor" id="sec_parallel"></a>
Parallel execution</h1>
<p>The pipelining framework provides transparent parallel execution of pipelines. For CPU intensive computations in which the function of one item does not depend on the previous item such as point projection, one simply wraps the part of the pipeline to be parallelized in a call to <code>parallel()</code> as such:</p>
<div class="fragment"><div class="line"><a class="code" href="namespacetpie_1_1pipelining.html#a16a8744ad1f202f05bb32a2f60545ed4">tp::maintain_order_type</a> maintainOrder = <a class="code" href="namespacetpie_1_1pipelining.html#a16a8744ad1f202f05bb32a2f60545ed4abf58a1a989c94ba7db61f23b21309b57">tp::arbitrary_order</a>; <span class="comment">// or tp::maintain_order</span></div>
<div class="line"><span class="keywordtype">size_t</span> numJobs = 4;</div>
<div class="line"><span class="keywordtype">size_t</span> bufSize = 1024;</div>
<div class="line"> </div>
<div class="line">tp::pipeline p =</div>
<div class="line">input_points()</div>
<div class="line">| <a class="code" href="namespacetpie_1_1pipelining.html#a4c894e9fba7cb73afb0a62d2d67d0237">parallel</a>(projection(mat), maintainOrder, numJobs, bufSize)</div>
<div class="line">| output_points();</div>
</div><!-- fragment --><p>The three extra parameters, <code>maintainOrder</code> (def. arbitrary_order), <code>numJobs</code> (def. <a class="el" href="namespacetpie.html#a18fbf567e45c8a656464a6777ae5996f" title="Return the number of job threads initialized by the job framework in init_job().">tpie::default_worker_count</a>) and <code>bufSize</code> (def. 64), are optional. If <code>maintainOrder</code> is set to maintain_order, the framework will make sure that the output is produced in the same order as the input, which may incur a performance penalty in some cases when the execution time varies per item. <code>numJobs</code> declares the number of worker threads to utilize. It defaults to the same number of worker threads as used by e.g. parallel internal sorting. <code>bufSize</code> is the number of items that are sent to a thread at a time. There is an overhead associated to each buffer sent (a couple virtual calls and a thread switch), so you should not set this too low. On the other hand, a larger buffer increases the memory overhead.</p>
<h1><a class="anchor" id="sec_phases"></a>
Pipeline phases</h1>
<p>Consider the following implementation of a reverser:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> dest_t&gt;</div>
<div class="line"><span class="keyword">class </span>reverser_type : <span class="keyword">public</span> <a class="code" href="classtpie_1_1pipelining_1_1node.html">tpie::pipelining::node</a> {</div>
<div class="line">    <a class="code" href="classtpie_1_1stack.html">tpie::stack&lt;point3d&gt;</a> points;</div>
<div class="line">    dest_t dest;</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">typedef</span> point3d <a class="code" href="namespacetpie_1_1pipelining.html#ad25e30e578fb780f9fff601b94fed33b">item_type</a>;</div>
<div class="line"> </div>
<div class="line">    reverser_type(dest_t dest)</div>
<div class="line">        : dest(std::move(dest))</div>
<div class="line">    {</div>
<div class="line">        <a class="code" href="classtpie_1_1pipelining_1_1node.html#ac5dacb7eebae9ddc445b579369ede28e">add_push_destination</a>(dest);</div>
<div class="line">        <a class="code" href="classtpie_1_1pipelining_1_1node.html#a8d39fac56ea1242d397cb4e7e087f58f">set_name</a>(<span class="stringliteral">&quot;Reverser&quot;</span>,</div>
<div class="line">                 tpie::pipelining::PRIORITY_SIGNIFICANT);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="classtpie_1_1pipelining_1_1node.html#a9baf8ec42c3fe532436b28bc6aa85ea2">push</a>(point3d p) {</div>
<div class="line">        points.<a class="code" href="classtpie_1_1stack.html#a3b4e719f585d63d66e2a83f3b36d2a5b">push</a>(p);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classtpie_1_1pipelining_1_1node.html#ad0802b1db95f1d74b49b1a4f9dd9709d">end</a>()<span class="keyword"> override </span>{</div>
<div class="line">        <span class="comment">// Pushing items in end() is bad!</span></div>
<div class="line">        <span class="keywordflow">while</span> (!points.<a class="code" href="classtpie_1_1stack.html#ac122df9b890e4c168895999497e38628">empty</a>()) {</div>
<div class="line">            dest.push(points.<a class="code" href="classtpie_1_1stack.html#a185619426cd0c33a3cd0871f4af7d7f7">pop</a>());</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p>This implementation seems innocuous at first, but it is in fact very wasteful. Note that the reverser needs to know the entire stream before it can push anything to its destination. This means that when all items have been pushed to it, we could as well deallocate all the item buffers that earlier nodes may have used while processing. As well, we could have waited until the stack was ready to push before initializing later nodes in the pipeline.</p>
<p>This is what pipelining phases are for. Phases are collections of nodes that do not have to operate synchronously. Nodes may establish an ordering of pipelining phases by adding dependencies to nodes in other phases.</p>
<p>A buffering node is split into an in-going and out-going node and a dependency is added between the two. This makes the buffering node act as a phase-boundary. Consider the following example of a node that reverses the input: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">class </span>reverser_input_t: <span class="keyword">public</span> node {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">typedef</span> T <a class="code" href="namespacetpie_1_1pipelining.html#ad25e30e578fb780f9fff601b94fed33b">item_type</a>;</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">inline</span> reverser_input_t(<span class="keyword">const</span> node_token &amp; token, std::shared_ptr&lt;node&gt; output=std::shared_ptr&lt;node&gt;())</div>
<div class="line">        : node(token), m_output(<a class="code" href="namespacetpie_1_1pipelining.html#aa1ecad88e2e14856799abf63e36abd4b">output</a>)</div>
<div class="line">    {</div>
<div class="line">        set_minimum_memory(stack&lt;item_type&gt;::memory_usage());</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> propagate()<span class="keyword"> override </span>{</div>
<div class="line">        m_stack = tpie_new&lt;stack&lt;item_type&gt; &gt;();</div>
<div class="line">        forward(<span class="stringliteral">&quot;stack&quot;</span>, m_stack);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> push(<span class="keyword">const</span> item_type &amp; t) {</div>
<div class="line">        m_stack-&gt;push(t);</div>
<div class="line">    }</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    stack&lt;item_type&gt; * m_stack;</div>
<div class="line">    std::shared_ptr&lt;node&gt; m_output;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> dest_t&gt;</div>
<div class="line"><span class="keyword">class </span>reverser_output_t: <span class="keyword">public</span> node {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> push_type&lt;dest_t&gt;::type <a class="code" href="namespacetpie_1_1pipelining.html#ad25e30e578fb780f9fff601b94fed33b">item_type</a>;</div>
<div class="line"> </div>
<div class="line">    reverser_output_t(dest_t dest, <span class="keyword">const</span> node_token &amp; input_token)</div>
<div class="line">        : dest(std::move(dest))</div>
<div class="line">    {</div>
<div class="line">        add_dependency(input_token);</div>
<div class="line">        add_push_destination(dest);</div>
<div class="line">        set_minimum_memory(this-&gt;m_stack-&gt;memory_usage());</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> propagate()<span class="keyword"> override </span>{</div>
<div class="line">        m_stack = fetch&lt;stack&lt;item_type&gt; *&gt;(<span class="stringliteral">&quot;stack&quot;</span>);</div>
<div class="line">        forward(<span class="stringliteral">&quot;items&quot;</span>, m_stack-&gt;size());</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> go()<span class="keyword"> override </span>{</div>
<div class="line">        <span class="keywordflow">while</span> (!m_stack-&gt;empty())</div>
<div class="line">            dest.push(m_stack-&gt;pop());</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">void</span> end()<span class="keyword"> override </span>{</div>
<div class="line">        <a class="code" href="namespacetpie.html#aa3ddea8b15e5629039c62b1b5b26e7a9">tpie_delete</a>(m_stack);</div>
<div class="line">    }</div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    dest_t dest;</div>
<div class="line">    stack&lt;item_type&gt; * m_stack;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> pipe_middle&lt;split_factory&lt;bits::reverser_input_t, node, bits::reverser_output_t&gt; &gt; <a class="code" href="namespacetpie_1_1pipelining.html#aff47d9407963e2e003e86a626b3a2a45">reverser</a>;</div>
</div><!-- fragment --><p>Common buffering operations that give rise to new phases are sorting and reversing, and these are already implemented in the pipelining framework.</p>
<p>For an idea of how to fully implement a generic buffering node such as a reverser using <code>node::add_dependency</code>, see <code><a class="el" href="reverse_8h_source.html">tpie/pipelining/reverse.h</a></code>.</p>
<h1><a class="anchor" id="sec_pipe_progress"></a>
Progress indication</h1>
<p>To support automatic progress indication from pipelining, at least one node in each phase should supply progress information to the framework.</p>
<p>This is done by calling <code>set_steps</code> in the node constructor or in <code>propagate</code> and calling <code>step</code> whenever one unit of work has been done.</p>
<p>Progress indication is implemented in the output node of each buffering node in the pipelining library as well as the input nodes in the pipelining library, so if an application uses e.g. sorting in pipelining, it will most likely get most of the progress indication for free.</p>
<p>If not, it is usually input nodes that read from disk or some other source that know the input size, so input nodes are usually where progress indication is implemented.</p>
<h1><a class="anchor" id="sec_pipe_evac"></a>
Evacuation</h1>
<p>Nodes at phase boundaries that may keep a buffer allocated between phases, such as a sorter that may keep some sorted data in memory after sorting but before reporting the sorted data, should be able to <em>evacuate</em>, that is, to store their buffer in external memory in order to release held resources.</p>
<p>This is needed for applications in which the phase graph is not just a simple chain; this happens for instance in applications that sort the same data with two different comparators.</p>
<p>Evacuation is implemented by overriding <code>can_evacuate</code> to return true, and overriding <code>evacuate</code> to actually perform the necessary evacuation.</p>
<h1><a class="anchor" id="sec_chunks"></a>
Virtual chunks</h1>
<p>So far, all pipelining code we have seen has been heavily templated, and in practice, debugging and compiler errors will not be easy on the eyes. Also, with the current setup we have seen, it is not easy (if at all possible) to distribute node implementations across compiled objects.</p>
<p>However, the pipelining framework supports <em>virtual chunks</em> which operate on the same level as, but are orthogonal to, pipeline phases as discussed in the previous section.</p>
<p>Whereas phases are computed at runtime and define the runtime order in which the node implementations have begin, go and end called, virtual chunks exist at compile time and are fused together at runtime.</p>
<p>Let us look at an example of how to use virtual chunks. The following is an example of an HTML handler with optional parsing and weeding. If weeding is requested (noText or noDynamic is set to true), the input HTML is parsed. Otherwise, it is fed directly to the output without parsing. The items passed around are html_tokens (representing a context-free HTML token; text, start node, end node, attribute, etc.) and tag_paths (representing a context-sensitive HTML leaf node; a token as well as the path from the root to the token).</p>
<div class="fragment"><div class="line">virtual_chunk_begin&lt;html_token&gt; input_pipe;</div>
<div class="line"> </div>
<div class="line">virtual_chunk&lt;html_token, tag_path&gt; parse_pipe;</div>
<div class="line">virtual_chunk&lt;tag_path, tag_path&gt; remove_text;</div>
<div class="line">virtual_chunk&lt;tag_path, tag_path&gt; remove_dynamic;</div>
<div class="line"> </div>
<div class="line">virtual_chunk_end&lt;tag_path&gt; reassembling_output;</div>
<div class="line">virtual_chunk_end&lt;html_token&gt; simple_output;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (!url.empty()) {</div>
<div class="line">    input_pipe = curl_input(url) <span class="comment">// pipe_begin</span></div>
<div class="line">    | curl_body_extract()        <span class="comment">// pipe_middle</span></div>
<div class="line">    | html_scanner();            <span class="comment">// pipe_middle</span></div>
<div class="line">    <span class="comment">// result is boxed into a virtual chunk</span></div>
<div class="line"> </div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    input_pipe = default_tag_generator();</div>
<div class="line">    <span class="comment">// pipe_begin boxed into virtual chunk</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">pipeline p;</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (noText || noDynamic) {</div>
<div class="line">    parse_pipe = html_parser();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (noText)</div>
<div class="line">        remove_text = html_text_weeder();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (noDynamic)</div>
<div class="line">        remove_dynamic = html_javascript_weeder()</div>
<div class="line">        | html_css_weeder();</div>
<div class="line"> </div>
<div class="line">    reassembling_output = html_reassembler();</div>
<div class="line"> </div>
<div class="line">    p = input_pipe         <span class="comment">// virtual_chunk_begin</span></div>
<div class="line">    | parse_pipe           <span class="comment">// virtual_chunk_middle</span></div>
<div class="line">    | remove_text          <span class="comment">// optional virtual_chunk_middle</span></div>
<div class="line">    | remove_dynamic       <span class="comment">// optional virtual_chunk_middle</span></div>
<div class="line">    | reassembling_output; <span class="comment">// virtual_chunk_end</span></div>
<div class="line">} <span class="keywordflow">else</span> {</div>
<div class="line">    simple_output = tag_printer();</div>
<div class="line"> </div>
<div class="line">    p = input_pipe         <span class="comment">// virtual_chunk_begin</span></div>
<div class="line">    | simple_output;       <span class="comment">// virtual_chunk_end</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">p(); <span class="comment">// invoking the pipeline as without chunks</span></div>
</div><!-- fragment --><p>Usually, supporting virtual chunks requires no additional work on the node end, as long as the node is templated to accept any node as destination.</p>
<p>In addition to constructing virtual chunks inline from pipe_bases, virtual chunks may be returned from a function in an implementation object out into a using object. This way, the using object does not have to define the node implementations - all it has to know is the type of object passed between the virtual chunks.</p>
<p>If the above options were implemented using compile-time switching on template parameters, the emitted code size would be eight times as large, corresponding to the eight different combinations of choices for noText, noDynamic and url.empty().</p>
<h1><a class="anchor" id="sec_pipelining_factory"></a>
Factories</h1>
<p>Since the C++ language does not infer template arguments to constructor calls, but does infer template arguments to functions and methods, we use factories to instantiate the node implementations. Usually, the built-in factories contained in <code><a class="el" href="factory__helpers_8h_source.html">factory_helpers.h</a></code> will suffice:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <a class="code" href="classtpie_1_1pipelining_1_1factory.html">tpie::pipelining::factory&lt;hello_world_type&gt;</a> hello_world_factory;</div>
</div><!-- fragment --><p>but in some cases it is helpful to implement one's own factory.</p>
<p>We could implement a <code>hello_world_factory</code> as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>hello_world_factory : <span class="keyword">public</span> <a class="code" href="classtpie_1_1pipelining_1_1factory__base.html">tpie::pipelining::factory_base</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> dest_t&gt;</div>
<div class="line">    <span class="keyword">struct </span>constructed {</div>
<div class="line">        <span class="keyword">typedef</span> hello_world_type&lt;dest_t&gt; type;</div>
<div class="line">    };</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> dest_t&gt;</div>
<div class="line">    hello_world_type&lt;dest_t&gt; construct(dest_t &amp;&amp; dest) {</div>
<div class="line">        hello_world_type&lt;dest_t&gt; hw(std::forward&lt;dest_t&gt;(dest));</div>
<div class="line">        this-&gt;<a class="code" href="classtpie_1_1pipelining_1_1factory__base.html#ae933074d0da0ab5f0fc483316a8873f0">init_node</a>(hw);</div>
<div class="line">        <span class="keywordflow">return</span> hw;</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p>For a terminating node, which doesn't have a destination, we would implement a so called termfactory as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>goodbye_world_type : <span class="keyword">public</span> <a class="code" href="classtpie_1_1pipelining_1_1node.html">tpie::pipelining::node</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">typedef</span> tpie::memory_size_type <a class="code" href="namespacetpie_1_1pipelining.html#ad25e30e578fb780f9fff601b94fed33b">item_type</a>;</div>
<div class="line">    <span class="keywordtype">void</span> <a class="code" href="classtpie_1_1pipelining_1_1node.html#a9baf8ec42c3fe532436b28bc6aa85ea2">push</a>(item_type) {}</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>goodbye_world_factory : <span class="keyword">public</span> <a class="code" href="classtpie_1_1pipelining_1_1factory__base.html">tpie::pipelining::factory_base</a> {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">typedef</span> goodbye_world constructed_type;</div>
<div class="line"> </div>
<div class="line">    goodbye_world_type construct() {</div>
<div class="line">        goodbye_world_type gw;</div>
<div class="line">        this-&gt;<a class="code" href="classtpie_1_1pipelining_1_1factory__base.html#ae933074d0da0ab5f0fc483316a8873f0">init_node</a>(gw);</div>
<div class="line">        <span class="keywordflow">return</span> gw;</div>
<div class="line">    }</div>
<div class="line">};</div>
</div><!-- fragment --><p>The main differences between an ordinary factory and a termfactory:</p>
<ul>
<li>Instead of a templated <code>construct()</code> accepting the destination as its first parameter, the <code>construct()</code> method takes no parameters, and</li>
<li><code>constructed&lt;dest_t&gt;::type</code> is replaced by the simpler <code>constructed_type</code> typedef.</li>
</ul>
<h1><a class="anchor" id="sec_pipe_base"></a>
Factory concatenation</h1>
<p>To use the above defined factories, we might write the following:</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacetpie.html">tpie</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacetpie_1_1pipelining.html">tpie::pipelining</a>;</div>
<div class="line"><a class="code" href="classtpie_1_1pipelining_1_1factory.html">factory&lt;input_t, file_stream&lt;memory_size_type&gt;</a> &amp;&gt; fact0(inputstream);</div>
<div class="line">hello_world_factory fact1;</div>
<div class="line">goodbye_world_factory fact2;</div>
<div class="line"><a class="code" href="classtpie_1_1pipelining_1_1pipeline.html">pipeline</a> p = fact0.construct(fact1.construct(fact2.construct()));</div>
<div class="line">p();</div>
</div><!-- fragment --><p>However, this is tedious, and so the pipelining framework provides several helper classes to ease the construction of pipelines, namely the descendants of <code>pipe_base</code> which are called <code>pipe_begin</code>, <code>pipe_middle</code> and <code>pipe_end</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">inline</span> pipe_middle&lt;factory&lt;hello_world_type&gt; &gt;</div>
<div class="line">hello_world() {</div>
<div class="line">    <span class="keywordflow">return</span> factory&lt;hello_world_type&gt;();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">inline</span> pipe_end&lt;termfactory&lt;goodbye_world_type&gt; &gt;</div>
<div class="line">goodbye_world() {</div>
<div class="line">    <span class="keywordflow">return</span> termfactory&lt;goodbye_world_type&gt;();</div>
<div class="line">}</div>
</div><!-- fragment --><p>which we would use as follows: </p><div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacetpie.html">tpie</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacetpie_1_1pipelining.html">tpie::pipelining</a>;</div>
<div class="line"><a class="code" href="classtpie_1_1pipelining_1_1pipeline.html">pipeline</a> p = <a class="code" href="namespacetpie_1_1pipelining.html#aec8021f755b4600d49276267552aa32b">input</a>(inputstream) | hello_world() | goodbye_world();</div>
<div class="line">p();</div>
</div><!-- fragment --><p>The three terms that are piped together have types <code>pipe_begin</code>, <code>pipe_middle</code> and <code>pipe_end</code> respectively. As one might expect, piping together a <code>pipe_begin</code> and a <code>pipe_middle</code> yields a new <code>pipe_begin</code>, and piping together a <code>pipe_begin</code> and a <code>pipe_end</code> yields a pipeline object (actually a <code>pipeline_impl</code> object).</p>
<h1><a class="anchor" id="sec_method_matrix"></a>
Method matrix</h1>
<p>Each row in the following matrix has a method called by the framework on the left, and a checkmark in the row for each method an implementation may call.</p>
<table class="doxtable">
<tr>
<th>Framework<br  />
calls </th><th>set_name</th><th>add_push_destination <br  />
add_pull_source <br  />
add_dependency </th><th>set_memory_fraction <br  />
set_minimum_memory <br  />
set_maximum_memory <br  />
register_datastructure_usage <br  />
set_datastructure_memory_limits </th><th>forward <br  />
can_fetch <br  />
fetch <br  />
get_datastructure_memory <br  />
set_datastructure <br  />
get_datastructure </th><th>push <br  />
can_pull <br  />
pull </th></tr>
<tr>
<td>constructor </td><td>X </td><td>X </td><td>X </td><td></td><td></td></tr>
<tr>
<td>prepare </td><td></td><td></td><td>X </td><td>X </td><td></td></tr>
<tr>
<td>set_available_memory</td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>evacuate </td><td></td><td></td><td></td><td></td><td></td></tr>
<tr>
<td>propagate </td><td></td><td></td><td>X </td><td>X </td><td></td></tr>
<tr>
<td>begin </td><td></td><td></td><td></td><td>X </td><td>X  </td></tr>
<tr>
<td>push/can_pull/pull </td><td></td><td></td><td></td><td>X </td><td>X  </td></tr>
<tr>
<td>end </td><td></td><td></td><td></td><td>X </td><td>X  </td></tr>
</table>
<p>Note that the push, can_pull and pull contracts are those obeyed by the pipelining node implementations in the library; the core framework itself does not enforce these requirements.</p>
<h1><a class="anchor" id="sec_initiators"></a>
Initiator nodes</h1>
<p>You will rarely need to implement initiators. For an initiator, instead of <code>push()</code>, the virtual <code>go()</code> method must be overridden, and this is called once. go() should forward() a piece of stream_size_type data named "items" indicating the expected number of items being pushed.</p>
<h1><a class="anchor" id="sec_library"></a>
Pipelining library</h1>
<p>The pipelining framework comes with a library of node implementations. A full list of nodes can be seen at <a class="el" href="pipelining_nodes.html">Pipelining Nodes</a>. Here's an introduction to some of the nodes.</p>
<h2><a class="anchor" id="ssec_buffer"></a>
Buffer</h2>
<p>To get simple buffering to disk of an item stream, a <code><a class="el" href="namespacetpie_1_1pipelining.html#a877590b7fc6795fe07d7674323bbf92e" title="The buffer node inserts a phase boundary into the pipeline by writing items to disk.">buffer()</a></code> will accept pushed items, store them in a temporary file, and push them to its destination in another phase. This is necessary, for instance, when the item stream is being sorted (which is a buffering operation in itself), but the same item stream is later needed in its original order.</p>
<p>For a buffer that accepts items pushed to it and can be pulled from in another phase, define a local <code>passive_buffer</code>, and get its input and output parts with <code>passive_buffer::input()</code> and <code>passive_buffer::output()</code>, respectively.</p>
<h2><a class="anchor" id="ssec_reverse"></a>
Reverser</h2>
<p>Like the buffer, the reverser exists as an active push input/push output and a passive push input/pull output form. For the passive reverser, define a <code>passive_reverser</code> and use <code>passive_reverser::sink</code> and <code>passive_reverser::source</code>. For the active reverser, simply use <code>reverser()</code>.</p>
<h2><a class="anchor" id="ssec_sorter"></a>
Sorter</h2>
<p>Like the buffer and the reverser, there is an active sorter, <code><a class="el" href="namespacetpie.html#af7bd11f9ca8b3252ee4fd9d7f48c05a2" title="Sort elements of a stream using the given STL-style comparator object.">sort()</a></code>, and a passive sorter with <code>passive_sorter::input()</code> and <code>passive_sorter::output()</code>. Both accept an optional less-than-predicate that defaults to <code>std::less</code>.</p>
<h2><a class="anchor" id="ssec_file_stream"></a>
Input and output files</h2>
<p>To read and entire file_stream and push its contents, define a <code>file_stream</code> variable, for instance <code>file_stream&lt;size_t&gt; foo;</code> and use it in your pipeline as <code>input(foo)</code>. For a pull pipe, use <code>pull_input(foo)</code>. Similarly, for outputting to a file_stream, there are the <code>output(foo)</code> and <code>pull_output(foo)</code> nodes. To write the item stream to a file_stream and push it on to another destination, use <code>tee(foo)</code>.</p>
<h2><a class="anchor" id="ssec_stdio"></a>
scanf and printf</h2>
<p>For reading and writing 32-bit ints using scanf (stdin) and printf (stdout), the pipelining framework provides <code>scanf_ints()</code> and <code>printf_ints()</code>.</p>
<h1><a class="anchor" id="sec_example_code"></a>
Example Code</h1>
<p>The full source code for programs that use the pipelining framework are available in the repository, see <code>apps/unique</code>, <code>pipelining_passive_sorter</code> or <code>apps/pipelining_datastructures</code>. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div class="ttc" id="aclasstpie_1_1resource__manager_html_a0dccdd44fc2b6d68bc3976056900cff9"><div class="ttname"><a href="classtpie_1_1resource__manager.html#a0dccdd44fc2b6d68bc3976056900cff9">tpie::resource_manager::set_limit</a></div><div class="ttdeci">void set_limit(size_t new_limit)</div><div class="ttdoc">Update the resource limit.</div></div>
<div class="ttc" id="aclasstpie_1_1stack_html_ac122df9b890e4c168895999497e38628"><div class="ttname"><a href="classtpie_1_1stack.html#ac122df9b890e4c168895999497e38628">tpie::stack::empty</a></div><div class="ttdeci">bool empty() const</div><div class="ttdoc">Returns whether the stack is empty or not.</div><div class="ttdef"><b>Definition:</b> <a href="stack_8h_source.html#l00139">stack.h:139</a></div></div>
<div class="ttc" id="anamespacetpie_1_1pipelining_html"><div class="ttname"><a href="namespacetpie_1_1pipelining.html">tpie::pipelining</a></div><div class="ttdoc">pipelining/factory_base.h Base class of pipelining factories</div><div class="ttdef"><b>Definition:</b> <a href="ami__glue_8h_source.html#l00023">ami_glue.h:23</a></div></div>
<div class="ttc" id="aclasstpie_1_1stack_html_a185619426cd0c33a3cd0871f4af7d7f7"><div class="ttname"><a href="classtpie_1_1stack.html#a185619426cd0c33a3cd0871f4af7d7f7">tpie::stack::pop</a></div><div class="ttdeci">const T &amp; pop()</div><div class="ttdoc">Pops one item from the stack.</div><div class="ttdef"><b>Definition:</b> <a href="stack_8h_source.html#l00113">stack.h:113</a></div></div>
<div class="ttc" id="anamespacetpie_1_1pipelining_html_aff47d9407963e2e003e86a626b3a2a45"><div class="ttname"><a href="namespacetpie_1_1pipelining.html#aff47d9407963e2e003e86a626b3a2a45">tpie::pipelining::reverser</a></div><div class="ttdeci">pipe_middle&lt; split_factory&lt; bits::reverser_input_t, node, bits::reverser_output_t &gt; &gt; reverser</div><div class="ttdoc">Constructs a reverser node stored in external memory.</div><div class="ttdef"><b>Definition:</b> <a href="reverse_8h_source.html#l00367">reverse.h:367</a></div></div>
<div class="ttc" id="aclasstpie_1_1pipelining_1_1factory_html"><div class="ttname"><a href="classtpie_1_1pipelining_1_1factory.html">tpie::pipelining::factory</a></div><div class="ttdef"><b>Definition:</b> <a href="factory__helpers_8h_source.html#l00035">factory_helpers.h:35</a></div></div>
<div class="ttc" id="aclasstpie_1_1pipelining_1_1factory__base_html_ae933074d0da0ab5f0fc483316a8873f0"><div class="ttname"><a href="classtpie_1_1pipelining_1_1factory__base.html#ae933074d0da0ab5f0fc483316a8873f0">tpie::pipelining::factory_base::init_node</a></div><div class="ttdeci">void init_node(node &amp;r)</div><div class="ttdoc">\Brief Initialize node constructed in a subclass.</div></div>
<div class="ttc" id="anamespacetpie_html_a81742e80132b2ad62ebe12b38b68d1c5"><div class="ttname"><a href="namespacetpie.html#a81742e80132b2ad62ebe12b38b68d1c5">tpie::get_memory_manager</a></div><div class="ttdeci">TPIE_EXPORT memory_manager &amp; get_memory_manager()</div><div class="ttdoc">Return a reference to the memory manager.</div></div>
<div class="ttc" id="aclasstpie_1_1pipelining_1_1node_html_a9baf8ec42c3fe532436b28bc6aa85ea2"><div class="ttname"><a href="classtpie_1_1pipelining_1_1node.html#a9baf8ec42c3fe532436b28bc6aa85ea2">tpie::pipelining::node::push</a></div><div class="ttdeci">void push(const item_type &amp;item)</div><div class="ttdoc">For push nodes, push the next item to this node.</div></div>
<div class="ttc" id="anamespacetpie_1_1pipelining_html_a16a8744ad1f202f05bb32a2f60545ed4abf58a1a989c94ba7db61f23b21309b57"><div class="ttname"><a href="namespacetpie_1_1pipelining.html#a16a8744ad1f202f05bb32a2f60545ed4abf58a1a989c94ba7db61f23b21309b57">tpie::pipelining::arbitrary_order</a></div><div class="ttdeci">@ arbitrary_order</div><div class="ttdoc">Do not maintain order; push items as soon as a worker has processed them.</div><div class="ttdef"><b>Definition:</b> <a href="maintain__order__type_8h_source.html#l00032">maintain_order_type.h:32</a></div></div>
<div class="ttc" id="aclasstpie_1_1stack_html"><div class="ttname"><a href="classtpie_1_1stack.html">tpie::stack</a></div><div class="ttdoc">An implementation of an external-memory stack.</div><div class="ttdef"><b>Definition:</b> <a href="stack_8h_source.html#l00040">stack.h:40</a></div></div>
<div class="ttc" id="anamespacetpie_html_a8086afebcb2cbd02fd7c41a1bfcf4925"><div class="ttname"><a href="namespacetpie.html#a8086afebcb2cbd02fd7c41a1bfcf4925">tpie::tpie_init</a></div><div class="ttdeci">TPIE_EXPORT void tpie_init(flags&lt; subsystem &gt; subsystems=ALL)</div><div class="ttdoc">Initialize the given subsystems of TPIE.</div></div>
<div class="ttc" id="aclasstpie_1_1pipelining_1_1factory__base_html"><div class="ttname"><a href="classtpie_1_1pipelining_1_1factory__base.html">tpie::pipelining::factory_base</a></div><div class="ttdoc">Base class of all pipelining factories.</div><div class="ttdef"><b>Definition:</b> <a href="factory__base_8h_source.html#l00073">factory_base.h:73</a></div></div>
<div class="ttc" id="aclasstpie_1_1pipelining_1_1node_html_ac5dacb7eebae9ddc445b579369ede28e"><div class="ttname"><a href="classtpie_1_1pipelining_1_1node.html#ac5dacb7eebae9ddc445b579369ede28e">tpie::pipelining::node::add_push_destination</a></div><div class="ttdeci">void add_push_destination(const node_token &amp;dest)</div><div class="ttdoc">Called by implementers to declare a push destination.</div></div>
<div class="ttc" id="anamespacetpie_1_1pipelining_html_a877590b7fc6795fe07d7674323bbf92e"><div class="ttname"><a href="namespacetpie_1_1pipelining.html#a877590b7fc6795fe07d7674323bbf92e">tpie::pipelining::buffer</a></div><div class="ttdeci">pipe_middle&lt; split_factory&lt; bits::buffer_input_t, node, bits::buffer_output_t &gt; &gt; buffer</div><div class="ttdoc">The buffer node inserts a phase boundary into the pipeline by writing items to disk.</div><div class="ttdef"><b>Definition:</b> <a href="pipelining_2buffer_8h_source.html#l00205">buffer.h:205</a></div></div>
<div class="ttc" id="aclasstpie_1_1pipelining_1_1node_html_a8d39fac56ea1242d397cb4e7e087f58f"><div class="ttname"><a href="classtpie_1_1pipelining_1_1node.html#a8d39fac56ea1242d397cb4e7e087f58f">tpie::pipelining::node::set_name</a></div><div class="ttdeci">void set_name(const std::string &amp;name, priority_type priority=PRIORITY_USER)</div><div class="ttdoc">Set this node's name.</div></div>
<div class="ttc" id="anamespacetpie_html_aa3ddea8b15e5629039c62b1b5b26e7a9"><div class="ttname"><a href="namespacetpie.html#aa3ddea8b15e5629039c62b1b5b26e7a9">tpie::tpie_delete</a></div><div class="ttdeci">void tpie_delete(T *p)</div><div class="ttdoc">Delete an object allocated with tpie_new.</div><div class="ttdef"><b>Definition:</b> <a href="memory_8h_source.html#l00280">memory.h:280</a></div></div>
<div class="ttc" id="aclasstpie_1_1pipelining_1_1node_html_ad0802b1db95f1d74b49b1a4f9dd9709d"><div class="ttname"><a href="classtpie_1_1pipelining_1_1node.html#ad0802b1db95f1d74b49b1a4f9dd9709d">tpie::pipelining::node::end</a></div><div class="ttdeci">virtual void end()</div><div class="ttdoc">End pipeline processing phase.</div><div class="ttdef"><b>Definition:</b> <a href="pipelining_2node_8h_source.html#l00328">node.h:328</a></div></div>
<div class="ttc" id="anamespacetpie_1_1pipelining_html_a4c894e9fba7cb73afb0a62d2d67d0237"><div class="ttname"><a href="namespacetpie_1_1pipelining.html#a4c894e9fba7cb73afb0a62d2d67d0237">tpie::pipelining::parallel</a></div><div class="ttdeci">pipe_middle&lt; parallel_bits::factory&lt; fact_t &gt; &gt; parallel(pipe_middle&lt; fact_t &gt; &amp;&amp;fact, maintain_order_type maintainOrder, size_t numJobs, size_t bufSize=2048)</div><div class="ttdoc">Runs a pipeline in multiple threads.</div><div class="ttdef"><b>Definition:</b> <a href="pipes_8h_source.html#l00040">pipes.h:40</a></div></div>
<div class="ttc" id="anamespacetpie_1_1pipelining_html_ad8185baaeedfd95e3d9fcfae0461441c"><div class="ttname"><a href="namespacetpie_1_1pipelining.html#ad8185baaeedfd95e3d9fcfae0461441c">tpie::pipelining::printf_ints</a></div><div class="ttdeci">pipe_end&lt; termfactory&lt; bits::printf_ints_t &gt; &gt; printf_ints</div><div class="ttdoc">A pipelining node that prints the items that are pushed to it.</div><div class="ttdef"><b>Definition:</b> <a href="pipelining_2stdio_8h_source.html#l00073">stdio.h:73</a></div></div>
<div class="ttc" id="aclasstpie_1_1stack_html_a3b4e719f585d63d66e2a83f3b36d2a5b"><div class="ttname"><a href="classtpie_1_1stack.html#a3b4e719f585d63d66e2a83f3b36d2a5b">tpie::stack::push</a></div><div class="ttdeci">void push(const T &amp;t)</div><div class="ttdoc">Pushes one item onto the stack.</div><div class="ttdef"><b>Definition:</b> <a href="stack_8h_source.html#l00105">stack.h:105</a></div></div>
<div class="ttc" id="anamespacetpie_1_1pipelining_html_aec8021f755b4600d49276267552aa32b"><div class="ttname"><a href="namespacetpie_1_1pipelining.html#aec8021f755b4600d49276267552aa32b">tpie::pipelining::input</a></div><div class="ttdeci">pipe_begin&lt; factory&lt; bits::input_t, file_stream&lt; T &gt; &amp;, stream_options &gt; &gt; input(file_stream&lt; T &gt; &amp;fs, stream_options options=stream_options())</div><div class="ttdoc">Pipelining nodes that pushes the contents of the given file stream to the next node in the pipeline.</div><div class="ttdef"><b>Definition:</b> <a href="pipelining_2file__stream_8h_source.html#l00378">file_stream.h:378</a></div></div>
<div class="ttc" id="aclasstpie_1_1pipelining_1_1node_html"><div class="ttname"><a href="classtpie_1_1pipelining_1_1node.html">tpie::pipelining::node</a></div><div class="ttdoc">Base class of all nodes.</div><div class="ttdef"><b>Definition:</b> <a href="pipelining_2node_8h_source.html#l00077">node.h:77</a></div></div>
<div class="ttc" id="aclasstpie_1_1pipelining_1_1pipeline_html"><div class="ttname"><a href="classtpie_1_1pipelining_1_1pipeline.html">tpie::pipelining::pipeline</a></div><div class="ttdef"><b>Definition:</b> <a href="pipeline_8h_source.html#l00181">pipeline.h:181</a></div></div>
<div class="ttc" id="anamespacetpie_1_1pipelining_html_a16a8744ad1f202f05bb32a2f60545ed4"><div class="ttname"><a href="namespacetpie_1_1pipelining.html#a16a8744ad1f202f05bb32a2f60545ed4">tpie::pipelining::maintain_order_type</a></div><div class="ttdeci">maintain_order_type</div><div class="ttdoc">Type describing whether to maintain the order of items in parallel.</div><div class="ttdef"><b>Definition:</b> <a href="maintain__order__type_8h_source.html#l00029">maintain_order_type.h:29</a></div></div>
<div class="ttc" id="anamespacetpie_html_acbb913e5f9654a6f0cd7cb226c37bcc0"><div class="ttname"><a href="namespacetpie.html#acbb913e5f9654a6f0cd7cb226c37bcc0">tpie::tpie_finish</a></div><div class="ttdeci">TPIE_EXPORT void tpie_finish(flags&lt; subsystem &gt; subsystems=ALL)</div><div class="ttdoc">Deinitialize the given subsystems of TPIE.</div></div>
<div class="ttc" id="anamespacetpie_1_1pipelining_html_ac08cd229124e38812ddee98a6ad0bb73"><div class="ttname"><a href="namespacetpie_1_1pipelining.html#ac08cd229124e38812ddee98a6ad0bb73">tpie::pipelining::scanf_ints</a></div><div class="ttdeci">pipe_begin&lt; factory&lt; bits::scanf_ints_t &gt; &gt; scanf_ints</div><div class="ttdoc">A pipelining node that pushes the integers it reads using scanf.</div><div class="ttdef"><b>Definition:</b> <a href="pipelining_2stdio_8h_source.html#l00068">stdio.h:68</a></div></div>
<div class="ttc" id="anamespacetpie_1_1pipelining_html_ad25e30e578fb780f9fff601b94fed33b"><div class="ttname"><a href="namespacetpie_1_1pipelining.html#ad25e30e578fb780f9fff601b94fed33b">tpie::pipelining::item_type</a></div><div class="ttdeci">pipe_middle&lt; tfactory&lt; bits::item_type_t, Args&lt; T &gt; &gt; &gt; item_type()</div><div class="ttdoc">Create item type defining identity pipe node.</div><div class="ttdef"><b>Definition:</b> <a href="helpers_8h_source.html#l00654">helpers.h:654</a></div></div>
<div class="ttc" id="anamespacetpie_1_1pipelining_html_aa1ecad88e2e14856799abf63e36abd4b"><div class="ttname"><a href="namespacetpie_1_1pipelining.html#aa1ecad88e2e14856799abf63e36abd4b">tpie::pipelining::output</a></div><div class="ttdeci">pipe_end&lt; termfactory&lt; bits::output_t&lt; T &gt;, file_stream&lt; T &gt; &amp; &gt; &gt; output(file_stream&lt; T &gt; &amp;fs)</div><div class="ttdoc">A pipelining node that writes the pushed items to a file stream.</div><div class="ttdef"><b>Definition:</b> <a href="pipelining_2file__stream_8h_source.html#l00430">file_stream.h:430</a></div></div>
<div class="ttc" id="anamespacetpie_html"><div class="ttname"><a href="namespacetpie.html">tpie</a></div><div class="ttdef"><b>Definition:</b> <a href="access__type_8h_source.html#l00026">access_type.h:26</a></div></div>
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
      <li class="footer">from TPIE 4739728 (<a href="//github.com/thomasmoelhave/tpie/tree/4739728">browse source</a>). Generated on Mon May 23 2022 23:38:36 by
<a href="http://www.doxygen.org/index.html">Doxygen</a> 1.8.17 </li>
    </ul>
  </div>
</body>
</html>
