<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>tpie::pipelining::bits::runtime Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="madalgo-doxygen.css" rel="stylesheet" type="text/css"/>
<link href="printstyle.css" rel="stylesheet" type="text/css" media="print" />
</head>
<body>
<div id="top">
<div id="titlearea">
<h1 id="projectname">TPIE</h1>
<span class="version"><a href="//github.com/thomasmoelhave/tpie/tree/4739728">4739728</a></span>
</div>
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classtpie_1_1pipelining_1_1bits_1_1runtime.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classtpie_1_1pipelining_1_1bits_1_1runtime-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">tpie::pipelining::bits::runtime Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Execute the pipeline contained in a <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1node__map.html">node_map</a>.  
 <a href="classtpie_1_1pipelining_1_1bits_1_1runtime.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="runtime_8h_source.html">tpie/pipelining/runtime.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a889ca16ccf735d4030dbfc0ce093b713"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1pipelining_1_1bits_1_1runtime.html#a889ca16ccf735d4030dbfc0ce093b713">runtime</a> (node_map::ptr nodeMap)</td></tr>
<tr class="memdesc:a889ca16ccf735d4030dbfc0ce093b713"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a runtime object.  <a href="classtpie_1_1pipelining_1_1bits_1_1runtime.html#a889ca16ccf735d4030dbfc0ce093b713">More...</a><br /></td></tr>
<tr class="separator:a889ca16ccf735d4030dbfc0ce093b713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace3915b5170f200e540fd9ba98adca00"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1pipelining_1_1bits_1_1runtime.html#ace3915b5170f200e540fd9ba98adca00">get_node_count</a> ()</td></tr>
<tr class="memdesc:ace3915b5170f200e540fd9ba98adca00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of nodes contained in node map.  <a href="classtpie_1_1pipelining_1_1bits_1_1runtime.html#ace3915b5170f200e540fd9ba98adca00">More...</a><br /></td></tr>
<tr class="separator:ace3915b5170f200e540fd9ba98adca00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a902252128759924aea487986c335b0c5"><td class="memItemLeft" align="right" valign="top"><a id="a902252128759924aea487986c335b0c5"></a>
gocontext_ptr&#160;</td><td class="memItemRight" valign="bottom"><b>go_init</b> (stream_size_type items, <a class="el" href="classtpie_1_1progress__indicator__base.html">progress_indicator_base</a> &amp;progress, memory_size_type files, memory_size_type memory, const char *<a class="el" href="classtpie_1_1file.html">file</a>, const char *function)</td></tr>
<tr class="separator:a902252128759924aea487986c335b0c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e416f98823863deb289d4ad4bcb8c10"><td class="memItemLeft" align="right" valign="top"><a id="a3e416f98823863deb289d4ad4bcb8c10"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>go_until</b> (gocontext *gc, <a class="el" href="classtpie_1_1pipelining_1_1node.html">node</a> *<a class="el" href="classtpie_1_1pipelining_1_1node.html">node</a>=nullptr)</td></tr>
<tr class="separator:a3e416f98823863deb289d4ad4bcb8c10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78a344dcb2d16ceda0522f0757c785e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1pipelining_1_1bits_1_1runtime.html#a78a344dcb2d16ceda0522f0757c785e2">go</a> (stream_size_type items, <a class="el" href="classtpie_1_1progress__indicator__base.html">progress_indicator_base</a> &amp;progress, memory_size_type files, memory_size_type memory, const char *<a class="el" href="classtpie_1_1file.html">file</a>, const char *function)</td></tr>
<tr class="memdesc:a78a344dcb2d16ceda0522f0757c785e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute the pipeline.  <a href="classtpie_1_1pipelining_1_1bits_1_1runtime.html#a78a344dcb2d16ceda0522f0757c785e2">More...</a><br /></td></tr>
<tr class="separator:a78a344dcb2d16ceda0522f0757c785e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a876724013f0db693ab907999ca80a103"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1pipelining_1_1bits_1_1runtime.html#a876724013f0db693ab907999ca80a103">get_item_sources</a> (std::vector&lt; <a class="el" href="classtpie_1_1pipelining_1_1node.html">node</a> * &gt; &amp;itemSources)</td></tr>
<tr class="memdesc:a876724013f0db693ab907999ca80a103"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all sources of the item flow graph.  <a href="classtpie_1_1pipelining_1_1bits_1_1runtime.html#a876724013f0db693ab907999ca80a103">More...</a><br /></td></tr>
<tr class="separator:a876724013f0db693ab907999ca80a103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef167a2f0873916032c121fecbb147bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1pipelining_1_1bits_1_1runtime.html#aef167a2f0873916032c121fecbb147bc">get_item_sinks</a> (std::vector&lt; <a class="el" href="classtpie_1_1pipelining_1_1node.html">node</a> * &gt; &amp;itemSinks)</td></tr>
<tr class="memdesc:aef167a2f0873916032c121fecbb147bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all sinks of the item flow graph.  <a href="classtpie_1_1pipelining_1_1bits_1_1runtime.html#aef167a2f0873916032c121fecbb147bc">More...</a><br /></td></tr>
<tr class="separator:aef167a2f0873916032c121fecbb147bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3d97ca964feaf1511915e92dd8abb64"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1pipelining_1_1bits_1_1runtime.html#ab3d97ca964feaf1511915e92dd8abb64">get_phase_map</a> (std::map&lt; <a class="el" href="classtpie_1_1pipelining_1_1node.html">node</a> *, size_t &gt; &amp;phaseMap)</td></tr>
<tr class="memdesc:ab3d97ca964feaf1511915e92dd8abb64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partition nodes into phases (using union-find).  <a href="classtpie_1_1pipelining_1_1bits_1_1runtime.html#ab3d97ca964feaf1511915e92dd8abb64">More...</a><br /></td></tr>
<tr class="separator:ab3d97ca964feaf1511915e92dd8abb64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a740f2ef1907a029866e75afb08bf176b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1pipelining_1_1bits_1_1runtime.html#a740f2ef1907a029866e75afb08bf176b">get_phase_graph</a> (const std::map&lt; <a class="el" href="classtpie_1_1pipelining_1_1node.html">node</a> *, size_t &gt; &amp;phaseMap, <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1graph.html">graph</a>&lt; size_t &gt; &amp;phaseGraph)</td></tr>
<tr class="memdesc:a740f2ef1907a029866e75afb08bf176b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set up phase graph so we can find a topological order.  <a href="classtpie_1_1pipelining_1_1bits_1_1runtime.html#a740f2ef1907a029866e75afb08bf176b">More...</a><br /></td></tr>
<tr class="separator:a740f2ef1907a029866e75afb08bf176b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca9f45cc9fc7168806710d4732cc6e74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1pipelining_1_1bits_1_1runtime.html#aca9f45cc9fc7168806710d4732cc6e74">get_phases</a> (const std::map&lt; <a class="el" href="classtpie_1_1pipelining_1_1node.html">node</a> *, size_t &gt; &amp;phaseMap, const <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1graph.html">graph</a>&lt; size_t &gt; &amp;phaseGraph, std::unordered_set&lt; node_map::id_t &gt; &amp;evacuateWhenDone, std::vector&lt; std::vector&lt; <a class="el" href="classtpie_1_1pipelining_1_1node.html">node</a> * &gt; &gt; &amp;phases)</td></tr>
<tr class="memdesc:aca9f45cc9fc7168806710d4732cc6e74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute topological phase order.  <a href="classtpie_1_1pipelining_1_1bits_1_1runtime.html#aca9f45cc9fc7168806710d4732cc6e74">More...</a><br /></td></tr>
<tr class="separator:aca9f45cc9fc7168806710d4732cc6e74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ceb650af7de0dbcbdce8a0983aa97cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1pipelining_1_1bits_1_1runtime.html#a6ceb650af7de0dbcbdce8a0983aa97cf">get_item_flow_graphs</a> (std::vector&lt; std::vector&lt; <a class="el" href="classtpie_1_1pipelining_1_1node.html">node</a> * &gt; &gt; &amp;phases, std::vector&lt; <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1graph.html">graph</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1node.html">node</a> * &gt; &gt; &amp;itemFlow)</td></tr>
<tr class="memdesc:a6ceb650af7de0dbcbdce8a0983aa97cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal method used by <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1runtime.html#a78a344dcb2d16ceda0522f0757c785e2" title="Execute the pipeline.">go()</a>.  <a href="classtpie_1_1pipelining_1_1bits_1_1runtime.html#a6ceb650af7de0dbcbdce8a0983aa97cf">More...</a><br /></td></tr>
<tr class="separator:a6ceb650af7de0dbcbdce8a0983aa97cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80cb8cfc48ca5d3eb77e7203a34c6c3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1pipelining_1_1bits_1_1runtime.html#a80cb8cfc48ca5d3eb77e7203a34c6c3a">get_actor_graphs</a> (std::vector&lt; std::vector&lt; <a class="el" href="classtpie_1_1pipelining_1_1node.html">node</a> * &gt; &gt; &amp;phases, std::vector&lt; <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1graph.html">graph</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1node.html">node</a> * &gt; &gt; &amp;actors)</td></tr>
<tr class="memdesc:a80cb8cfc48ca5d3eb77e7203a34c6c3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal method used by <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1runtime.html#a78a344dcb2d16ceda0522f0757c785e2" title="Execute the pipeline.">go()</a>.  <a href="classtpie_1_1pipelining_1_1bits_1_1runtime.html#a80cb8cfc48ca5d3eb77e7203a34c6c3a">More...</a><br /></td></tr>
<tr class="separator:a80cb8cfc48ca5d3eb77e7203a34c6c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a366fea3ad4ae9eda6a9100948c0e3cdb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1pipelining_1_1bits_1_1runtime.html#a366fea3ad4ae9eda6a9100948c0e3cdb">get_graph</a> (std::vector&lt; <a class="el" href="classtpie_1_1pipelining_1_1node.html">node</a> * &gt; &amp;phase, <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1graph.html">graph</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1node.html">node</a> * &gt; &amp;result, bool itemFlow)</td></tr>
<tr class="memdesc:a366fea3ad4ae9eda6a9100948c0e3cdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal method used by get_{actor,item_flow}_graphs().  <a href="classtpie_1_1pipelining_1_1bits_1_1runtime.html#a366fea3ad4ae9eda6a9100948c0e3cdb">More...</a><br /></td></tr>
<tr class="separator:a366fea3ad4ae9eda6a9100948c0e3cdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13f4bdd131abd6338dd74e3216b81823"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1pipelining_1_1bits_1_1runtime.html#a13f4bdd131abd6338dd74e3216b81823">is_initiator</a> (<a class="el" href="classtpie_1_1pipelining_1_1node.html">node</a> *n)</td></tr>
<tr class="memdesc:a13f4bdd131abd6338dd74e3216b81823"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the node is a phase initiator.  <a href="classtpie_1_1pipelining_1_1bits_1_1runtime.html#a13f4bdd131abd6338dd74e3216b81823">More...</a><br /></td></tr>
<tr class="separator:a13f4bdd131abd6338dd74e3216b81823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee47bf1e9ad8e918cb2fcfa7ba20019c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1pipelining_1_1bits_1_1runtime.html#aee47bf1e9ad8e918cb2fcfa7ba20019c">has_initiator</a> (const std::vector&lt; <a class="el" href="classtpie_1_1pipelining_1_1node.html">node</a> * &gt; &amp;phase)</td></tr>
<tr class="memdesc:aee47bf1e9ad8e918cb2fcfa7ba20019c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to any_of(begin(phase), end(phase), is_initiator).  <a href="classtpie_1_1pipelining_1_1bits_1_1runtime.html#aee47bf1e9ad8e918cb2fcfa7ba20019c">More...</a><br /></td></tr>
<tr class="separator:aee47bf1e9ad8e918cb2fcfa7ba20019c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6da522444609333bec4b31c8368b5f95"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1pipelining_1_1bits_1_1runtime.html#a6da522444609333bec4b31c8368b5f95">ensure_initiators</a> (const std::vector&lt; std::vector&lt; <a class="el" href="classtpie_1_1pipelining_1_1node.html">node</a> * &gt; &gt; &amp;phases)</td></tr>
<tr class="memdesc:a6da522444609333bec4b31c8368b5f95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ensure that all phases have at least one initiator.  <a href="classtpie_1_1pipelining_1_1bits_1_1runtime.html#a6da522444609333bec4b31c8368b5f95">More...</a><br /></td></tr>
<tr class="separator:a6da522444609333bec4b31c8368b5f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5ef57b2bb8fb12e1c03cdfde166c0bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1pipelining_1_1bits_1_1runtime.html#ac5ef57b2bb8fb12e1c03cdfde166c0bc">prepare_all</a> (const std::vector&lt; <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1graph.html">graph</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1node.html">node</a> * &gt; &gt; &amp;itemFlow)</td></tr>
<tr class="memdesc:ac5ef57b2bb8fb12e1c03cdfde166c0bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call prepare on all nodes in item source to sink order.  <a href="classtpie_1_1pipelining_1_1bits_1_1runtime.html#ac5ef57b2bb8fb12e1c03cdfde166c0bc">More...</a><br /></td></tr>
<tr class="separator:ac5ef57b2bb8fb12e1c03cdfde166c0bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9928a4f07fef642c8de2ab00625c4761"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1pipelining_1_1bits_1_1runtime.html#a9928a4f07fef642c8de2ab00625c4761">evacuate_all</a> (const std::vector&lt; <a class="el" href="classtpie_1_1pipelining_1_1node.html">node</a> * &gt; &amp;phase, const std::unordered_set&lt; node_map::id_t &gt; &amp;evacuateWhenDone)</td></tr>
<tr class="memdesc:a9928a4f07fef642c8de2ab00625c4761"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call evacuate on all nodes in evacuateWhenDone for which can_evacuate() is true.  <a href="classtpie_1_1pipelining_1_1bits_1_1runtime.html#a9928a4f07fef642c8de2ab00625c4761">More...</a><br /></td></tr>
<tr class="separator:a9928a4f07fef642c8de2ab00625c4761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae5748f7316a8a7088d6dcaf09bd1c6b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1pipelining_1_1bits_1_1runtime.html#aae5748f7316a8a7088d6dcaf09bd1c6b">propagate_all</a> (const <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1graph.html">graph</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1node.html">node</a> * &gt; &amp;itemFlow)</td></tr>
<tr class="memdesc:aae5748f7316a8a7088d6dcaf09bd1c6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call propagate on all nodes in item source to sink order.  <a href="classtpie_1_1pipelining_1_1bits_1_1runtime.html#aae5748f7316a8a7088d6dcaf09bd1c6b">More...</a><br /></td></tr>
<tr class="separator:aae5748f7316a8a7088d6dcaf09bd1c6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1c263fe90122615d8e7da84dd9132dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1pipelining_1_1bits_1_1runtime.html#ad1c263fe90122615d8e7da84dd9132dc">set_progress_indicators</a> (const std::vector&lt; <a class="el" href="classtpie_1_1pipelining_1_1node.html">node</a> * &gt; &amp;phase, <a class="el" href="classtpie_1_1progress__indicator__base.html">progress_indicator_base</a> &amp;pi)</td></tr>
<tr class="memdesc:ad1c263fe90122615d8e7da84dd9132dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call set_progress_indicator on all nodes in the phase.  <a href="classtpie_1_1pipelining_1_1bits_1_1runtime.html#ad1c263fe90122615d8e7da84dd9132dc">More...</a><br /></td></tr>
<tr class="separator:ad1c263fe90122615d8e7da84dd9132dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59a4410d8605366bd3d73b903a673618"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1pipelining_1_1bits_1_1runtime.html#a59a4410d8605366bd3d73b903a673618">go_initiators</a> (const std::vector&lt; <a class="el" href="classtpie_1_1pipelining_1_1node.html">node</a> * &gt; &amp;phase)</td></tr>
<tr class="memdesc:a59a4410d8605366bd3d73b903a673618"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1runtime.html#a78a344dcb2d16ceda0522f0757c785e2" title="Execute the pipeline.">go()</a> on all initiators after setting the given progress indicator.  <a href="classtpie_1_1pipelining_1_1bits_1_1runtime.html#a59a4410d8605366bd3d73b903a673618">More...</a><br /></td></tr>
<tr class="separator:a59a4410d8605366bd3d73b903a673618"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a452da1d2172d6814072621419e7f1d1a"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1pipelining_1_1bits_1_1runtime.html#a452da1d2172d6814072621419e7f1d1a">inverse_permutation</a> (const std::vector&lt; size_t &gt; &amp;f)</td></tr>
<tr class="memdesc:a452da1d2172d6814072621419e7f1d1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the inverse of a permutation.  <a href="classtpie_1_1pipelining_1_1bits_1_1runtime.html#a452da1d2172d6814072621419e7f1d1a">More...</a><br /></td></tr>
<tr class="separator:a452da1d2172d6814072621419e7f1d1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07f4ec53d4dea639dc290ba2b94a1c7b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1pipelining_1_1bits_1_1runtime.html#a07f4ec53d4dea639dc290ba2b94a1c7b">set_resource_being_assigned</a> (const std::vector&lt; <a class="el" href="classtpie_1_1pipelining_1_1node.html">node</a> * &gt; &amp;nodes, resource_type type)</td></tr>
<tr class="memdesc:a07f4ec53d4dea639dc290ba2b94a1c7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal method used by <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1runtime.html#a78a344dcb2d16ceda0522f0757c785e2" title="Execute the pipeline.">go()</a>.  <a href="classtpie_1_1pipelining_1_1bits_1_1runtime.html#a07f4ec53d4dea639dc290ba2b94a1c7b">More...</a><br /></td></tr>
<tr class="separator:a07f4ec53d4dea639dc290ba2b94a1c7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c56512540e6ab41677e1decd68b8c9a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1pipelining_1_1bits_1_1runtime.html#a6c56512540e6ab41677e1decd68b8c9a">assign_files</a> (const std::vector&lt; std::vector&lt; <a class="el" href="classtpie_1_1pipelining_1_1node.html">node</a> * &gt; &gt; &amp;phases, memory_size_type files)</td></tr>
<tr class="memdesc:a6c56512540e6ab41677e1decd68b8c9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal method used by <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1runtime.html#a78a344dcb2d16ceda0522f0757c785e2" title="Execute the pipeline.">go()</a>.  <a href="classtpie_1_1pipelining_1_1bits_1_1runtime.html#a6c56512540e6ab41677e1decd68b8c9a">More...</a><br /></td></tr>
<tr class="separator:a6c56512540e6ab41677e1decd68b8c9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86e75c505562c17dcaf2858a44e912b1"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1pipelining_1_1bits_1_1runtime.html#a86e75c505562c17dcaf2858a44e912b1">reassign_files</a> (const std::vector&lt; std::vector&lt; <a class="el" href="classtpie_1_1pipelining_1_1node.html">node</a> * &gt; &gt; &amp;phases, memory_size_type phase, memory_size_type files)</td></tr>
<tr class="memdesc:a86e75c505562c17dcaf2858a44e912b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal method used by <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1runtime.html#a78a344dcb2d16ceda0522f0757c785e2" title="Execute the pipeline.">go()</a>.  <a href="classtpie_1_1pipelining_1_1bits_1_1runtime.html#a86e75c505562c17dcaf2858a44e912b1">More...</a><br /></td></tr>
<tr class="separator:a86e75c505562c17dcaf2858a44e912b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e08dc986ecc8ec3c0af6d45c4a75801"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1pipelining_1_1bits_1_1runtime.html#a7e08dc986ecc8ec3c0af6d45c4a75801">get_files_factor</a> (memory_size_type files, const file_runtime &amp;frt)</td></tr>
<tr class="memdesc:a7e08dc986ecc8ec3c0af6d45c4a75801"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal method used by <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1runtime.html#a177114bdd42ad129253aeb6299d2c8f5" title="Internal method used by go().">assign_memory()</a>.  <a href="classtpie_1_1pipelining_1_1bits_1_1runtime.html#a7e08dc986ecc8ec3c0af6d45c4a75801">More...</a><br /></td></tr>
<tr class="separator:a7e08dc986ecc8ec3c0af6d45c4a75801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a177114bdd42ad129253aeb6299d2c8f5"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1pipelining_1_1bits_1_1runtime.html#a177114bdd42ad129253aeb6299d2c8f5">assign_memory</a> (const std::vector&lt; std::vector&lt; <a class="el" href="classtpie_1_1pipelining_1_1node.html">node</a> * &gt; &gt; &amp;phases, memory_size_type memory, datastructure_runtime &amp;drt)</td></tr>
<tr class="memdesc:a177114bdd42ad129253aeb6299d2c8f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal method used by <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1runtime.html#a78a344dcb2d16ceda0522f0757c785e2" title="Execute the pipeline.">go()</a>.  <a href="classtpie_1_1pipelining_1_1bits_1_1runtime.html#a177114bdd42ad129253aeb6299d2c8f5">More...</a><br /></td></tr>
<tr class="separator:a177114bdd42ad129253aeb6299d2c8f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65f5feefa6930e893599e8ece3671647"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1pipelining_1_1bits_1_1runtime.html#a65f5feefa6930e893599e8ece3671647">reassign_memory</a> (const std::vector&lt; std::vector&lt; <a class="el" href="classtpie_1_1pipelining_1_1node.html">node</a> * &gt; &gt; &amp;phases, memory_size_type phase, memory_size_type memory, const datastructure_runtime &amp;drt)</td></tr>
<tr class="memdesc:a65f5feefa6930e893599e8ece3671647"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal method used by <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1runtime.html#a78a344dcb2d16ceda0522f0757c785e2" title="Execute the pipeline.">go()</a>.  <a href="classtpie_1_1pipelining_1_1bits_1_1runtime.html#a65f5feefa6930e893599e8ece3671647">More...</a><br /></td></tr>
<tr class="separator:a65f5feefa6930e893599e8ece3671647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dd962daaa0db8f09b2f7597e0fc3810"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1pipelining_1_1bits_1_1runtime.html#a0dd962daaa0db8f09b2f7597e0fc3810">get_memory_factor</a> (memory_size_type memory, memory_size_type phase, const memory_runtime &amp;mrt, const datastructure_runtime &amp;drt, bool datastructures_locked)</td></tr>
<tr class="memdesc:a0dd962daaa0db8f09b2f7597e0fc3810"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal method used by <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1runtime.html#a177114bdd42ad129253aeb6299d2c8f5" title="Internal method used by go().">assign_memory()</a>.  <a href="classtpie_1_1pipelining_1_1bits_1_1runtime.html#a0dd962daaa0db8f09b2f7597e0fc3810">More...</a><br /></td></tr>
<tr class="separator:a0dd962daaa0db8f09b2f7597e0fc3810"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Execute the pipeline contained in a <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1node__map.html">node_map</a>. </p>

<p class="definition">Definition at line <a class="el" href="runtime_8h_source.html#l00047">47</a> of file <a class="el" href="runtime_8h_source.html">runtime.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a889ca16ccf735d4030dbfc0ce093b713"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a889ca16ccf735d4030dbfc0ce093b713">&#9670;&nbsp;</a></span>runtime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tpie::pipelining::bits::runtime::runtime </td>
          <td>(</td>
          <td class="paramtype">node_map::ptr&#160;</td>
          <td class="paramname"><em>nodeMap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a runtime object. </p>
<p>Does nothing other than copy the smart pointer given. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6c56512540e6ab41677e1decd68b8c9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c56512540e6ab41677e1decd68b8c9a">&#9670;&nbsp;</a></span>assign_files()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void tpie::pipelining::bits::runtime::assign_files </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="classtpie_1_1pipelining_1_1node.html">node</a> * &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>phases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">memory_size_type&#160;</td>
          <td class="paramname"><em>files</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal method used by <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1runtime.html#a78a344dcb2d16ceda0522f0757c785e2" title="Execute the pipeline.">go()</a>. </p>

</div>
</div>
<a id="a177114bdd42ad129253aeb6299d2c8f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a177114bdd42ad129253aeb6299d2c8f5">&#9670;&nbsp;</a></span>assign_memory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void tpie::pipelining::bits::runtime::assign_memory </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="classtpie_1_1pipelining_1_1node.html">node</a> * &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>phases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">memory_size_type&#160;</td>
          <td class="paramname"><em>memory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">datastructure_runtime &amp;&#160;</td>
          <td class="paramname"><em>drt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal method used by <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1runtime.html#a78a344dcb2d16ceda0522f0757c785e2" title="Execute the pipeline.">go()</a>. </p>

</div>
</div>
<a id="a6da522444609333bec4b31c8368b5f95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6da522444609333bec4b31c8368b5f95">&#9670;&nbsp;</a></span>ensure_initiators()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tpie::pipelining::bits::runtime::ensure_initiators </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="classtpie_1_1pipelining_1_1node.html">node</a> * &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>phases</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ensure that all phases have at least one initiator. </p>
<p>If a phase has no initiators, throw no_initiator_node(). </p>

</div>
</div>
<a id="a9928a4f07fef642c8de2ab00625c4761"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9928a4f07fef642c8de2ab00625c4761">&#9670;&nbsp;</a></span>evacuate_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tpie::pipelining::bits::runtime::evacuate_all </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classtpie_1_1pipelining_1_1node.html">node</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unordered_set&lt; node_map::id_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>evacuateWhenDone</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call evacuate on all nodes in evacuateWhenDone for which can_evacuate() is true. </p>

</div>
</div>
<a id="a80cb8cfc48ca5d3eb77e7203a34c6c3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80cb8cfc48ca5d3eb77e7203a34c6c3a">&#9670;&nbsp;</a></span>get_actor_graphs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tpie::pipelining::bits::runtime::get_actor_graphs </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="classtpie_1_1pipelining_1_1node.html">node</a> * &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>phases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1graph.html">graph</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1node.html">node</a> * &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>actors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal method used by <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1runtime.html#a78a344dcb2d16ceda0522f0757c785e2" title="Execute the pipeline.">go()</a>. </p>

</div>
</div>
<a id="a7e08dc986ecc8ec3c0af6d45c4a75801"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e08dc986ecc8ec3c0af6d45c4a75801">&#9670;&nbsp;</a></span>get_files_factor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double tpie::pipelining::bits::runtime::get_files_factor </td>
          <td>(</td>
          <td class="paramtype">memory_size_type&#160;</td>
          <td class="paramname"><em>files</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const file_runtime &amp;&#160;</td>
          <td class="paramname"><em>frt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal method used by <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1runtime.html#a177114bdd42ad129253aeb6299d2c8f5" title="Internal method used by go().">assign_memory()</a>. </p>

</div>
</div>
<a id="a366fea3ad4ae9eda6a9100948c0e3cdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a366fea3ad4ae9eda6a9100948c0e3cdb">&#9670;&nbsp;</a></span>get_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tpie::pipelining::bits::runtime::get_graph </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classtpie_1_1pipelining_1_1node.html">node</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtpie_1_1pipelining_1_1bits_1_1graph.html">graph</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1node.html">node</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>itemFlow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal method used by get_{actor,item_flow}_graphs(). </p>

</div>
</div>
<a id="a6ceb650af7de0dbcbdce8a0983aa97cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ceb650af7de0dbcbdce8a0983aa97cf">&#9670;&nbsp;</a></span>get_item_flow_graphs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tpie::pipelining::bits::runtime::get_item_flow_graphs </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="classtpie_1_1pipelining_1_1node.html">node</a> * &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>phases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1graph.html">graph</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1node.html">node</a> * &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>itemFlow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Internal method used by <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1runtime.html#a78a344dcb2d16ceda0522f0757c785e2" title="Execute the pipeline.">go()</a>. </p>

</div>
</div>
<a id="aef167a2f0873916032c121fecbb147bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef167a2f0873916032c121fecbb147bc">&#9670;&nbsp;</a></span>get_item_sinks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tpie::pipelining::bits::runtime::get_item_sinks </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classtpie_1_1pipelining_1_1node.html">node</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>itemSinks</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all sinks of the item flow graph. </p>
<p>An item sink node has no outgoing edges in the item flow graph of its phase, and no phase depends on its phase.</p>
<p>This is the set of nodes used when fetching out-of-band data from the pipeline. </p>

</div>
</div>
<a id="a876724013f0db693ab907999ca80a103"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a876724013f0db693ab907999ca80a103">&#9670;&nbsp;</a></span>get_item_sources()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tpie::pipelining::bits::runtime::get_item_sources </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classtpie_1_1pipelining_1_1node.html">node</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>itemSources</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all sources of the item flow graph. </p>
<p>An item source node has no ingoing edges in the item flow graph of its phase, and its phase does not depend on any phases.</p>
<p>This is the set of nodes used when forwarding out-of-band data into the pipeline. </p>

</div>
</div>
<a id="a0dd962daaa0db8f09b2f7597e0fc3810"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dd962daaa0db8f09b2f7597e0fc3810">&#9670;&nbsp;</a></span>get_memory_factor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double tpie::pipelining::bits::runtime::get_memory_factor </td>
          <td>(</td>
          <td class="paramtype">memory_size_type&#160;</td>
          <td class="paramname"><em>memory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">memory_size_type&#160;</td>
          <td class="paramname"><em>phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const memory_runtime &amp;&#160;</td>
          <td class="paramname"><em>mrt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const datastructure_runtime &amp;&#160;</td>
          <td class="paramname"><em>drt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>datastructures_locked</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal method used by <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1runtime.html#a177114bdd42ad129253aeb6299d2c8f5" title="Internal method used by go().">assign_memory()</a>. </p>

</div>
</div>
<a id="ace3915b5170f200e540fd9ba98adca00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace3915b5170f200e540fd9ba98adca00">&#9670;&nbsp;</a></span>get_node_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t tpie::pipelining::bits::runtime::get_node_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of nodes contained in node map. </p>
<p>Returns m_nodeMap.size(). </p>

</div>
</div>
<a id="a740f2ef1907a029866e75afb08bf176b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a740f2ef1907a029866e75afb08bf176b">&#9670;&nbsp;</a></span>get_phase_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tpie::pipelining::bits::runtime::get_phase_graph </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; <a class="el" href="classtpie_1_1pipelining_1_1node.html">node</a> *, size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>phaseMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtpie_1_1pipelining_1_1bits_1_1graph.html">graph</a>&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>phaseGraph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set up phase graph so we can find a topological order. </p>

</div>
</div>
<a id="ab3d97ca964feaf1511915e92dd8abb64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3d97ca964feaf1511915e92dd8abb64">&#9670;&nbsp;</a></span>get_phase_map()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tpie::pipelining::bits::runtime::get_phase_map </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; <a class="el" href="classtpie_1_1pipelining_1_1node.html">node</a> *, size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>phaseMap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Partition nodes into phases (using union-find). </p>

</div>
</div>
<a id="aca9f45cc9fc7168806710d4732cc6e74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca9f45cc9fc7168806710d4732cc6e74">&#9670;&nbsp;</a></span>get_phases()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tpie::pipelining::bits::runtime::get_phases </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; <a class="el" href="classtpie_1_1pipelining_1_1node.html">node</a> *, size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>phaseMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1graph.html">graph</a>&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>phaseGraph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_set&lt; node_map::id_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>evacuateWhenDone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="classtpie_1_1pipelining_1_1node.html">node</a> * &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>phases</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute topological phase order. </p>
<p>The vector phases[i] will contain the nodes in the ith phase to run. For each node in phase[i], if the node has a memory share dependency to any node not in phases[i-1], the node is contained in evacuateWhenDone. </p>

</div>
</div>
<a id="a78a344dcb2d16ceda0522f0757c785e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78a344dcb2d16ceda0522f0757c785e2">&#9670;&nbsp;</a></span>go()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tpie::pipelining::bits::runtime::go </td>
          <td>(</td>
          <td class="paramtype">stream_size_type&#160;</td>
          <td class="paramname"><em>items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtpie_1_1progress__indicator__base.html">progress_indicator_base</a> &amp;&#160;</td>
          <td class="paramname"><em>progress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">memory_size_type&#160;</td>
          <td class="paramname"><em>files</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">memory_size_type&#160;</td>
          <td class="paramname"><em>memory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Execute the pipeline. </p>
<p>This is the main entry point. The method <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1runtime.html#a78a344dcb2d16ceda0522f0757c785e2" title="Execute the pipeline.">go()</a> sets up all nodes for execution and executes all initiators in turn:</p>
<p>Call <a class="el" href="classtpie_1_1pipelining_1_1node.html#adc1f27b6739c0258b67884cd8c5ffabf" title="Called before memory assignment but after depending phases have executed and ended.">node::prepare</a> in item source to item sink order for each phase.</p>
<p>Assign memory according to memory constraints and memory priorities.</p>
<p>For each phase, call propagate, begin, go and end on nodes as appropriate. We call propagate in item source to item sink order; we call begin in leaf to root actor order; we call end in root to leaf actor order. </p>

</div>
</div>
<a id="a59a4410d8605366bd3d73b903a673618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59a4410d8605366bd3d73b903a673618">&#9670;&nbsp;</a></span>go_initiators()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tpie::pipelining::bits::runtime::go_initiators </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classtpie_1_1pipelining_1_1node.html">node</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>phase</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1runtime.html#a78a344dcb2d16ceda0522f0757c785e2" title="Execute the pipeline.">go()</a> on all initiators after setting the given progress indicator. </p>

</div>
</div>
<a id="aee47bf1e9ad8e918cb2fcfa7ba20019c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee47bf1e9ad8e918cb2fcfa7ba20019c">&#9670;&nbsp;</a></span>has_initiator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tpie::pipelining::bits::runtime::has_initiator </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classtpie_1_1pipelining_1_1node.html">node</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>phase</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Equivalent to any_of(begin(phase), end(phase), is_initiator). </p>

</div>
</div>
<a id="a452da1d2172d6814072621419e7f1d1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a452da1d2172d6814072621419e7f1d1a">&#9670;&nbsp;</a></span>inverse_permutation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt;size_t&gt; tpie::pipelining::bits::runtime::inverse_permutation </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the inverse of a permutation. </p>
<p>A permutation of N elements is given as a std::vector of size N, in which each entry maps to a distinct integer in [0, N). The inverse permutation of f is g if and only if f[g[i]] == g[f[i]] == i for all i in [0,N). </p>

</div>
</div>
<a id="a13f4bdd131abd6338dd74e3216b81823"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13f4bdd131abd6338dd74e3216b81823">&#9670;&nbsp;</a></span>is_initiator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tpie::pipelining::bits::runtime::is_initiator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtpie_1_1pipelining_1_1node.html">node</a> *&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the node is a phase initiator. </p>
<p>A node is a phase initiator if it has no ingoing edges in the actor graph, or in other words if no node pushes to it or pulls from it. </p>

</div>
</div>
<a id="ac5ef57b2bb8fb12e1c03cdfde166c0bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5ef57b2bb8fb12e1c03cdfde166c0bc">&#9670;&nbsp;</a></span>prepare_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tpie::pipelining::bits::runtime::prepare_all </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1graph.html">graph</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1node.html">node</a> * &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>itemFlow</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call prepare on all nodes in item source to sink order. </p>

</div>
</div>
<a id="aae5748f7316a8a7088d6dcaf09bd1c6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae5748f7316a8a7088d6dcaf09bd1c6b">&#9670;&nbsp;</a></span>propagate_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tpie::pipelining::bits::runtime::propagate_all </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1graph.html">graph</a>&lt; <a class="el" href="classtpie_1_1pipelining_1_1node.html">node</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>itemFlow</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call propagate on all nodes in item source to sink order. </p>

</div>
</div>
<a id="a86e75c505562c17dcaf2858a44e912b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86e75c505562c17dcaf2858a44e912b1">&#9670;&nbsp;</a></span>reassign_files()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void tpie::pipelining::bits::runtime::reassign_files </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="classtpie_1_1pipelining_1_1node.html">node</a> * &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>phases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">memory_size_type&#160;</td>
          <td class="paramname"><em>phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">memory_size_type&#160;</td>
          <td class="paramname"><em>files</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal method used by <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1runtime.html#a78a344dcb2d16ceda0522f0757c785e2" title="Execute the pipeline.">go()</a>. </p>

</div>
</div>
<a id="a65f5feefa6930e893599e8ece3671647"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65f5feefa6930e893599e8ece3671647">&#9670;&nbsp;</a></span>reassign_memory()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void tpie::pipelining::bits::runtime::reassign_memory </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="classtpie_1_1pipelining_1_1node.html">node</a> * &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>phases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">memory_size_type&#160;</td>
          <td class="paramname"><em>phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">memory_size_type&#160;</td>
          <td class="paramname"><em>memory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const datastructure_runtime &amp;&#160;</td>
          <td class="paramname"><em>drt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal method used by <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1runtime.html#a78a344dcb2d16ceda0522f0757c785e2" title="Execute the pipeline.">go()</a>. </p>

</div>
</div>
<a id="ad1c263fe90122615d8e7da84dd9132dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1c263fe90122615d8e7da84dd9132dc">&#9670;&nbsp;</a></span>set_progress_indicators()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tpie::pipelining::bits::runtime::set_progress_indicators </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classtpie_1_1pipelining_1_1node.html">node</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>phase</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtpie_1_1progress__indicator__base.html">progress_indicator_base</a> &amp;&#160;</td>
          <td class="paramname"><em>pi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call set_progress_indicator on all nodes in the phase. </p>

</div>
</div>
<a id="a07f4ec53d4dea639dc290ba2b94a1c7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07f4ec53d4dea639dc290ba2b94a1c7b">&#9670;&nbsp;</a></span>set_resource_being_assigned()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void tpie::pipelining::bits::runtime::set_resource_being_assigned </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classtpie_1_1pipelining_1_1node.html">node</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">resource_type&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal method used by <a class="el" href="classtpie_1_1pipelining_1_1bits_1_1runtime.html#a78a344dcb2d16ceda0522f0757c785e2" title="Execute the pipeline.">go()</a>. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>pipelining/<a class="el" href="runtime_8h_source.html">runtime.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
      <li class="footer">from TPIE 4739728 (<a href="//github.com/thomasmoelhave/tpie/tree/4739728">browse source</a>). Generated on Mon May 23 2022 23:38:39 by
<a href="http://www.doxygen.org/index.html">Doxygen</a> 1.8.17 </li>
    </ul>
  </div>
</body>
</html>
