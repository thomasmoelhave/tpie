<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>Overview and basic concepts</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="madalgo-doxygen.css" rel="stylesheet" type="text/css"/>
<link href="printstyle.css" rel="stylesheet" type="text/css" media="print" />
</head>
<body>
<div id="top">
<div id="titlearea">
<h1 id="projectname">TPIE</h1>
<span class="version"><a href="//github.com/thomasmoelhave/tpie/tree/4739728">4739728</a></span>
</div>
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('basicconcepts.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Basic concepts </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The data sets involved in some modern applications are too large to fit in the main memory of even the most powerful computers and must therefore reside on disk. Thus communication between internal and external memory, and not actual computation time, often becomes the bottleneck in the computation. This is due to the huge difference in access time of fast internal memory and slower external memory such as disks. While typical access time of main memory is measured in nanoseconds, a typical access time of a disk is on the order of milliseconds. So roughly speaking there is a factor of a million difference in the access time of internal and external memory.</p>
<p>The goal of theoretical work in the area of <em>external memory (EM) algorithms</em> (also called <em>I/O algorithms</em> or <em>out-of-core algorithms</em>) is to eliminate or minimize the I/O bottleneck through better algorithm design. In order to cope with the high cost of accessing data, efficient EM algorithms exploit locality in their design. They access a large <em>block</em> of <em>B</em> contiguous data elements at a time and perform the necessary algorithmic steps on the elements in the block while in the high-speed memory. The speedup can be considerable. See the surveys by Vitter [<a href="#vitteriosurvey" id="backlink1">1</a>] and Arge [<a href="#argehandbook" id="backlink2">2</a>] for other results, including I/O-efficient algorithms for various geometric and graph problems.</p>
<p>The objectives of the TPIE project include the following:</p>
<ul>
<li><em>Abstract away the details of how I/O is performed</em> so that programmers need only deal with a simple high level interface.</li>
<li><em>Provide a collection of I/O-optimal paradigms</em> for large scale computation that are efficient not only in theory, but also in practice.</li>
<li><em>Be flexible</em>, allowing programmers to specify the functional details of computation taking place within the supported paradigms. This will allow a wide variety of algorithms to be implemented within the system.</li>
<li><em>Be portable</em> across a variety hardware platforms.</li>
<li><em>Be extensible</em>, so that new features can be easily added later.</li>
</ul>
<h1><a class="anchor" id="basicconcepts"></a>
Basic concepts</h1>
<p>TPIE is written in the C++ language, and this manual assumes that the reader is familiar with C++.</p>
<p>Familiarity with the theoretical results on I/O-efficient algorithms is not necessary in order to use TPIE. However, this manual may be easier to follow with some general background information such as how a theoretically optimal external merge sort algorithm works. Some of the basic concepts required for understanding the discussion of I/O issues and external memory algorithms in this manual are outlined below.</p>
<p>Roughly speaking there is a factor of a million difference in the access time of internal and external memory. In order to cope with the high cost of accessing externally-stored data, efficient EM algorithms exploit locality in their design. They access a large <em>block</em> of <em>B</em> contiguous data elements at a time and perform the necessary algorithmic steps on the elements in the block while it is in the high-speed memory. The speedup can be considerable.</p>
<p>The performance of an EM algorithm on a given set of data is affected directly by how much internal memory is available for its use. We use <em>M</em> to denote the number of application data elements that fit into the internal memory available to the algorithm, and <em>m</em> = <em>M</em> / <em>B</em> denotes the number of blocks that fit into the available internal memory. Such a block is more precisely called a <em>logical block</em> because it may be a different size (usually larger) than either the physical block size or the system block size. We will reserve the term <em>physical block</em> size to mean the block size used by a disk controller to communicate with a physical disk, and the <em>system block</em> size will be the size of block used within the operating system for I/O operations on disk devices. In EM algorithms we will assume that the logical block size is a multiple of the system block size.</p>
<p>TPIE is implemented as a set of templated classes and functions in C++, and employs an object-oriented abstraction to EM computation. TPIE provides C++ templates of various optimal EM computation <em>patterns</em> or <em>paradigms</em>. Examples of such paradigms are the EM algorithms for merge sorting, distribution sweeping, time forward processing, etc. In a TPIE program, the application programmer provides application-specific details of the specific computation paradigm used, such as C++ object definitions of the application data records, and code for application-specific sub-computations at critical points in the computation pattern, but TPIE provides the application-independent parts of the pattern.</p>
<p>The definition of an application data element (or record) is provided by the user as a class definition. Such a class definition is typically used as a template parameter in a TPIE code fragment (e.g. a templated function).</p>
<h1><a class="anchor" id="stream"></a>
Streams</h1>
<p>In TPIE, a <em>stream</em> is an ordered collection of objects of a particular type, stored in external memory, and accessed in sequential order. Streams can be thought of as fundamental TPIE objects which map volatile, typed application data elements in internal memory to persistent, untyped data elements in external memory, and vice-versa. See <a class="el" href="classtpie_1_1file__stream.html">tpie::file_stream</a>. Streams are read and written like files in Unix and support a number of primitive file-like operations such as <code>read()</code>, <code>write()</code>, <code>truncate()</code>, etc. TPIE also supports the concept of a <em>substream</em>, see <a class="el" href="classtpie_1_1file.html">tpie::file</a>, which permits a contiguous subset of the elements in a stream to accessed sequentially.</p>
<p>Various paradigms of external memory computation are supported. TPIE reduces the programming effort required to perform an external sort, merge, etc., by providing the high level flow of control within each paradigm, and therefore structuring this part of the computation so that it will be I/O efficient. The programmer is left with the task of providing what amount to event handlers, specifying the application-specific details of the computation. For instance in sorting, the programmer defines a stream of input data, a comparison operator (the event handler for the task of comparing two application data elements), and an output stream for the results. See also <a class="el" href="namespacetpie.html#af7bd11f9ca8b3252ee4fd9d7f48c05a2">tpie::sort</a>.</p>
<p>Creating a stream of objects in TPIE is very much like creating any other object in C++. The only difference is that the data placed in the stream is stored in external memory (on disk).</p>
<h1><a class="anchor" id="introreferences"></a>
References</h1>
<p><a href="#backlink1">^</a> <span id="vitteriosurvey">1: J. S. Vitter: External Memory Algorithms and Data Structures: Dealing with MASSIVE Data, ACM Computing Surveys (2001)</span></p>
<p><a href="#backlink2">^</a> <span id="argehandbook">2: L. Arge: External Memory Data Structures, from Handbook of Massive Data Sets (2002)</span> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
      <li class="footer">from TPIE 4739728 (<a href="//github.com/thomasmoelhave/tpie/tree/4739728">browse source</a>). Generated on Mon May 23 2022 23:38:36 by
<a href="http://www.doxygen.org/index.html">Doxygen</a> 1.8.17 </li>
    </ul>
  </div>
</body>
</html>
