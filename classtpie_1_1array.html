<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.7"/>
<title>tpie::array&lt; T, Allocator &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="madalgo-doxygen.css" rel="stylesheet" type="text/css"/>
<link href="printstyle.css" rel="stylesheet" type="text/css" media="print" />
</head>
<body>
<div id="top">
<div id="titlearea">
<h1 id="projectname">TPIE</h1>
<span class="version"><a href="//github.com/thomasmoelhave/tpie/tree/4739728">4739728</a></span>
</div>
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classtpie_1_1array.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classtpie_1_1array-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">tpie::array&lt; T, Allocator &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A generic array with a fixed size.  
 <a href="classtpie_1_1array.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="array_8h_source.html">tpie/array.h</a>&gt;</code></p>

<p>Inherits <a class="el" href="structtpie_1_1linear__memory__base.html">tpie::linear_memory_base&lt; array&lt; T &gt; &gt;</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ab5e1a08202934b65612af9ccadd9b488"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classtpie_1_1array__iter__base.html">array_iter_base</a>&lt; T const, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1array.html#ab5e1a08202934b65612af9ccadd9b488">const_iterator</a></td></tr>
<tr class="memdesc:ab5e1a08202934b65612af9ccadd9b488"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator over a const array.  <a href="classtpie_1_1array.html#ab5e1a08202934b65612af9ccadd9b488">More...</a><br /></td></tr>
<tr class="separator:ab5e1a08202934b65612af9ccadd9b488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99f9563215998023748073049a9cb511"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classtpie_1_1array__iter__base.html">array_iter_base</a>&lt; T const, false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1array.html#a99f9563215998023748073049a9cb511">const_reverse_iterator</a></td></tr>
<tr class="memdesc:a99f9563215998023748073049a9cb511"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse iterator over a const array.  <a href="classtpie_1_1array.html#a99f9563215998023748073049a9cb511">More...</a><br /></td></tr>
<tr class="separator:a99f9563215998023748073049a9cb511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b04586c0b86cbba5a9703c97b1f205d"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classtpie_1_1array__iter__base.html">array_iter_base</a>&lt; T, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1array.html#a7b04586c0b86cbba5a9703c97b1f205d">iterator</a></td></tr>
<tr class="memdesc:a7b04586c0b86cbba5a9703c97b1f205d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterator over an array.  <a href="classtpie_1_1array.html#a7b04586c0b86cbba5a9703c97b1f205d">More...</a><br /></td></tr>
<tr class="separator:a7b04586c0b86cbba5a9703c97b1f205d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69b6f5387cd00bdcdc6f0266630281d9"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classtpie_1_1array__iter__base.html">array_iter_base</a>&lt; T, false &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1array.html#a69b6f5387cd00bdcdc6f0266630281d9">reverse_iterator</a></td></tr>
<tr class="memdesc:a69b6f5387cd00bdcdc6f0266630281d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse iterator over an array.  <a href="classtpie_1_1array.html#a69b6f5387cd00bdcdc6f0266630281d9">More...</a><br /></td></tr>
<tr class="separator:a69b6f5387cd00bdcdc6f0266630281d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af706ead111ae5e158610993433ab68d0"><td class="memItemLeft" align="right" valign="top">typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1array.html#af706ead111ae5e158610993433ab68d0">value_type</a></td></tr>
<tr class="memdesc:af706ead111ae5e158610993433ab68d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of values containd in the array.  <a href="classtpie_1_1array.html#af706ead111ae5e158610993433ab68d0">More...</a><br /></td></tr>
<tr class="separator:af706ead111ae5e158610993433ab68d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2d6891eeb4c1e37678e681fb0ee55f3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1array.html#a7b04586c0b86cbba5a9703c97b1f205d">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1array.html#a2d6891eeb4c1e37678e681fb0ee55f3d">find</a> (size_t idx)  throw ()</td></tr>
<tr class="memdesc:a2d6891eeb4c1e37678e681fb0ee55f3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterator to the i'th element of the array.  <a href="classtpie_1_1array.html#a2d6891eeb4c1e37678e681fb0ee55f3d">More...</a><br /></td></tr>
<tr class="separator:a2d6891eeb4c1e37678e681fb0ee55f3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b9f17a53da53f0cb5bc85d0a8558196"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1array.html#ab5e1a08202934b65612af9ccadd9b488">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1array.html#a4b9f17a53da53f0cb5bc85d0a8558196">find</a> (size_t idx) const  throw ()</td></tr>
<tr class="memdesc:a4b9f17a53da53f0cb5bc85d0a8558196"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const iterator to the i'th element of the array.  <a href="classtpie_1_1array.html#a4b9f17a53da53f0cb5bc85d0a8558196">More...</a><br /></td></tr>
<tr class="separator:a4b9f17a53da53f0cb5bc85d0a8558196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41970720ee4d82c796e18fae52f8df17"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1array.html#a41970720ee4d82c796e18fae52f8df17">at</a> (size_t i)  throw ()</td></tr>
<tr class="memdesc:a41970720ee4d82c796e18fae52f8df17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the element located at the given index.  <a href="classtpie_1_1array.html#a41970720ee4d82c796e18fae52f8df17">More...</a><br /></td></tr>
<tr class="separator:a41970720ee4d82c796e18fae52f8df17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5791e3e81d96074acd17bfc98b27309b"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1array.html#a5791e3e81d96074acd17bfc98b27309b">at</a> (size_t i) const  throw ()</td></tr>
<tr class="memdesc:a5791e3e81d96074acd17bfc98b27309b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the element located at the given index.  <a href="classtpie_1_1array.html#a5791e3e81d96074acd17bfc98b27309b">More...</a><br /></td></tr>
<tr class="separator:a5791e3e81d96074acd17bfc98b27309b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab215b343b17b2d7f5735fd5e9b7735fb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1array.html">array</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1array.html#ab215b343b17b2d7f5735fd5e9b7735fb">operator=</a> (const <a class="el" href="classtpie_1_1array.html">array</a> &amp;other)</td></tr>
<tr class="memdesc:ab215b343b17b2d7f5735fd5e9b7735fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy elements from another array into this.  <a href="classtpie_1_1array.html#ab215b343b17b2d7f5735fd5e9b7735fb">More...</a><br /></td></tr>
<tr class="separator:ab215b343b17b2d7f5735fd5e9b7735fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b8e24bc55c68acb939c12eb5866cc3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1array.html">array</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1array.html#a4b8e24bc55c68acb939c12eb5866cc3a">operator=</a> (<a class="el" href="classtpie_1_1array.html">array</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:a4b8e24bc55c68acb939c12eb5866cc3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move elements from another array into this.  <a href="classtpie_1_1array.html#a4b8e24bc55c68acb939c12eb5866cc3a">More...</a><br /></td></tr>
<tr class="separator:a4b8e24bc55c68acb939c12eb5866cc3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af74a0ea20473c276697c75660612ee54"><td class="memTemplParams" colspan="2">template&lt;typename OtherAllocator &gt; </td></tr>
<tr class="memitem:af74a0ea20473c276697c75660612ee54"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1array.html">array</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtpie_1_1array.html#af74a0ea20473c276697c75660612ee54">operator=</a> (const <a class="el" href="classtpie_1_1array.html">array</a>&lt; T, OtherAllocator &gt; &amp;other)</td></tr>
<tr class="memdesc:af74a0ea20473c276697c75660612ee54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy elements from another array with any allocator into this.  <a href="classtpie_1_1array.html#af74a0ea20473c276697c75660612ee54">More...</a><br /></td></tr>
<tr class="separator:af74a0ea20473c276697c75660612ee54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a749b21f2611816c04a9462b1337bd27d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1array.html#a749b21f2611816c04a9462b1337bd27d">empty</a> () const</td></tr>
<tr class="memdesc:a749b21f2611816c04a9462b1337bd27d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the array is empty.  <a href="classtpie_1_1array.html#a749b21f2611816c04a9462b1337bd27d">More...</a><br /></td></tr>
<tr class="separator:a749b21f2611816c04a9462b1337bd27d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50350751e6465d5bbb6d7eee932ee58a"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1array.html#a50350751e6465d5bbb6d7eee932ee58a">operator[]</a> (size_t i) const</td></tr>
<tr class="memdesc:a50350751e6465d5bbb6d7eee932ee58a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const reference to an array entry.  <a href="classtpie_1_1array.html#a50350751e6465d5bbb6d7eee932ee58a">More...</a><br /></td></tr>
<tr class="separator:a50350751e6465d5bbb6d7eee932ee58a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41bb47cb27ffe30a08d56133268b2ac1"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1array.html#a41bb47cb27ffe30a08d56133268b2ac1">operator[]</a> (size_t i)</td></tr>
<tr class="memdesc:a41bb47cb27ffe30a08d56133268b2ac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a reference to an array entry.  <a href="classtpie_1_1array.html#a41bb47cb27ffe30a08d56133268b2ac1">More...</a><br /></td></tr>
<tr class="separator:a41bb47cb27ffe30a08d56133268b2ac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af62d3144110943e4d1a15ed7265fcacf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1array.html#af62d3144110943e4d1a15ed7265fcacf">operator==</a> (const <a class="el" href="classtpie_1_1array.html">array</a> &amp;other) const</td></tr>
<tr class="memdesc:af62d3144110943e4d1a15ed7265fcacf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare if the other array has the same elements in the same order as this.  <a href="classtpie_1_1array.html#af62d3144110943e4d1a15ed7265fcacf">More...</a><br /></td></tr>
<tr class="separator:af62d3144110943e4d1a15ed7265fcacf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1247c3c80954079b625860f96c10734c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1array.html#a1247c3c80954079b625860f96c10734c">operator!=</a> (const <a class="el" href="classtpie_1_1array.html">array</a> &amp;other) const</td></tr>
<tr class="memdesc:a1247c3c80954079b625860f96c10734c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if two arrays differ.  <a href="classtpie_1_1array.html#a1247c3c80954079b625860f96c10734c">More...</a><br /></td></tr>
<tr class="separator:a1247c3c80954079b625860f96c10734c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ce6320438ae73b208b4a51fd0eee22e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1array.html#a7b04586c0b86cbba5a9703c97b1f205d">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1array.html#a2ce6320438ae73b208b4a51fd0eee22e">begin</a> ()</td></tr>
<tr class="memdesc:a2ce6320438ae73b208b4a51fd0eee22e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterator to the beginning of the array.  <a href="classtpie_1_1array.html#a2ce6320438ae73b208b4a51fd0eee22e">More...</a><br /></td></tr>
<tr class="separator:a2ce6320438ae73b208b4a51fd0eee22e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f5c04d69504209c7cd5963245112ace"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1array.html#ab5e1a08202934b65612af9ccadd9b488">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1array.html#a5f5c04d69504209c7cd5963245112ace">begin</a> () const</td></tr>
<tr class="memdesc:a5f5c04d69504209c7cd5963245112ace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const iterator to the beginning of the array.  <a href="classtpie_1_1array.html#a5f5c04d69504209c7cd5963245112ace">More...</a><br /></td></tr>
<tr class="separator:a5f5c04d69504209c7cd5963245112ace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cd10fa88715b8552d9a25b4cc0ed21a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1array.html#a7b04586c0b86cbba5a9703c97b1f205d">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1array.html#a9cd10fa88715b8552d9a25b4cc0ed21a">end</a> ()</td></tr>
<tr class="memdesc:a9cd10fa88715b8552d9a25b4cc0ed21a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an iterator to the end of the array.  <a href="classtpie_1_1array.html#a9cd10fa88715b8552d9a25b4cc0ed21a">More...</a><br /></td></tr>
<tr class="separator:a9cd10fa88715b8552d9a25b4cc0ed21a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34afe3cfbb09d1ca87113c712c6419e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1array.html#ab5e1a08202934b65612af9ccadd9b488">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1array.html#a34afe3cfbb09d1ca87113c712c6419e8">end</a> () const</td></tr>
<tr class="memdesc:a34afe3cfbb09d1ca87113c712c6419e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const iterator to the end of the array.  <a href="classtpie_1_1array.html#a34afe3cfbb09d1ca87113c712c6419e8">More...</a><br /></td></tr>
<tr class="separator:a34afe3cfbb09d1ca87113c712c6419e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a79806a3f0ddd0b02ae918064264bef"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1array.html#a8a79806a3f0ddd0b02ae918064264bef">front</a> () const</td></tr>
<tr class="memdesc:a8a79806a3f0ddd0b02ae918064264bef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first element in the array.  <a href="classtpie_1_1array.html#a8a79806a3f0ddd0b02ae918064264bef">More...</a><br /></td></tr>
<tr class="separator:a8a79806a3f0ddd0b02ae918064264bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4940f60b93b2c6a1a3c9a7c4d3d1bae6"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1array.html#a4940f60b93b2c6a1a3c9a7c4d3d1bae6">front</a> ()</td></tr>
<tr class="memdesc:a4940f60b93b2c6a1a3c9a7c4d3d1bae6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first element in the array.  <a href="classtpie_1_1array.html#a4940f60b93b2c6a1a3c9a7c4d3d1bae6">More...</a><br /></td></tr>
<tr class="separator:a4940f60b93b2c6a1a3c9a7c4d3d1bae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8a149566cc3ec211bf9a8918b4db61b"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1array.html#ad8a149566cc3ec211bf9a8918b4db61b">back</a> () const</td></tr>
<tr class="memdesc:ad8a149566cc3ec211bf9a8918b4db61b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the last element in the array.  <a href="classtpie_1_1array.html#ad8a149566cc3ec211bf9a8918b4db61b">More...</a><br /></td></tr>
<tr class="separator:ad8a149566cc3ec211bf9a8918b4db61b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09d47a74d21e8b29389194afec2f4780"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1array.html#a09d47a74d21e8b29389194afec2f4780">back</a> ()</td></tr>
<tr class="memdesc:a09d47a74d21e8b29389194afec2f4780"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the last element in the array.  <a href="classtpie_1_1array.html#a09d47a74d21e8b29389194afec2f4780">More...</a><br /></td></tr>
<tr class="separator:a09d47a74d21e8b29389194afec2f4780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82555ac6891558fe31efc6aaa38ff765"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1array.html#a69b6f5387cd00bdcdc6f0266630281d9">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1array.html#a82555ac6891558fe31efc6aaa38ff765">rbegin</a> ()</td></tr>
<tr class="memdesc:a82555ac6891558fe31efc6aaa38ff765"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse iterator to beginning of reverse sequence.  <a href="classtpie_1_1array.html#a82555ac6891558fe31efc6aaa38ff765">More...</a><br /></td></tr>
<tr class="separator:a82555ac6891558fe31efc6aaa38ff765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eb190056e9f8ba6df0d0da4c93cb927"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1array.html#a99f9563215998023748073049a9cb511">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1array.html#a0eb190056e9f8ba6df0d0da4c93cb927">rbegin</a> () const</td></tr>
<tr class="memdesc:a0eb190056e9f8ba6df0d0da4c93cb927"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const reverse iterator to beginning of reverse sequence.  <a href="classtpie_1_1array.html#a0eb190056e9f8ba6df0d0da4c93cb927">More...</a><br /></td></tr>
<tr class="separator:a0eb190056e9f8ba6df0d0da4c93cb927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4787d5836e29a34ad0cbe3bc8b68063d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1array.html#a69b6f5387cd00bdcdc6f0266630281d9">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1array.html#a4787d5836e29a34ad0cbe3bc8b68063d">rend</a> ()</td></tr>
<tr class="memdesc:a4787d5836e29a34ad0cbe3bc8b68063d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse iterator to end of reverse sequence.  <a href="classtpie_1_1array.html#a4787d5836e29a34ad0cbe3bc8b68063d">More...</a><br /></td></tr>
<tr class="separator:a4787d5836e29a34ad0cbe3bc8b68063d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdd5ab659e19d124af6c18803f88371d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtpie_1_1array.html#a99f9563215998023748073049a9cb511">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1array.html#acdd5ab659e19d124af6c18803f88371d">rend</a> () const</td></tr>
<tr class="memdesc:acdd5ab659e19d124af6c18803f88371d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Const reverse iterator to end of reverse sequence.  <a href="classtpie_1_1array.html#acdd5ab659e19d124af6c18803f88371d">More...</a><br /></td></tr>
<tr class="separator:acdd5ab659e19d124af6c18803f88371d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ddcc40ef6171c0ae5770e37e9cc5900"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1array.html#a7ddcc40ef6171c0ae5770e37e9cc5900">array</a> (size_type s, const T &amp;value, const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="memdesc:a7ddcc40ef6171c0ae5770e37e9cc5900"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct array of given size.  <a href="classtpie_1_1array.html#a7ddcc40ef6171c0ae5770e37e9cc5900">More...</a><br /></td></tr>
<tr class="separator:a7ddcc40ef6171c0ae5770e37e9cc5900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bf1ba08a0d55a2f1bb3837ec3e8fab1"><td class="memItemLeft" align="right" valign="top"><a id="a7bf1ba08a0d55a2f1bb3837ec3e8fab1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>array</b> (size_type s, <a class="el" href="classtpie_1_1memory__bucket__ref.html">memory_bucket_ref</a> bucket)</td></tr>
<tr class="separator:a7bf1ba08a0d55a2f1bb3837ec3e8fab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3ce4a2665920d86c59b390301dd1fd8"><td class="memItemLeft" align="right" valign="top"><a id="aa3ce4a2665920d86c59b390301dd1fd8"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>array</b> (<a class="el" href="classtpie_1_1memory__bucket__ref.html">memory_bucket_ref</a> bucket)</td></tr>
<tr class="separator:aa3ce4a2665920d86c59b390301dd1fd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c26088472faf92f345e2eae2fe32431"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1array.html#a1c26088472faf92f345e2eae2fe32431">array</a> (size_type s=0, const Allocator &amp;alloc=Allocator())</td></tr>
<tr class="memdesc:a1c26088472faf92f345e2eae2fe32431"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct array of given size.  <a href="classtpie_1_1array.html#a1c26088472faf92f345e2eae2fe32431">More...</a><br /></td></tr>
<tr class="separator:a1c26088472faf92f345e2eae2fe32431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a133e4b4e9d9594e8f5a09c1b33b78f2f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1array.html#a133e4b4e9d9594e8f5a09c1b33b78f2f">array</a> (const <a class="el" href="classtpie_1_1array.html">array</a> &amp;other)</td></tr>
<tr class="memdesc:a133e4b4e9d9594e8f5a09c1b33b78f2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a copy of another array.  <a href="classtpie_1_1array.html#a133e4b4e9d9594e8f5a09c1b33b78f2f">More...</a><br /></td></tr>
<tr class="separator:a133e4b4e9d9594e8f5a09c1b33b78f2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4156b9dd11dd86db1b100750688a9be"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1array.html#af4156b9dd11dd86db1b100750688a9be">array</a> (<a class="el" href="classtpie_1_1array.html">array</a> &amp;&amp;other)</td></tr>
<tr class="memdesc:af4156b9dd11dd86db1b100750688a9be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move construct from another array.  <a href="classtpie_1_1array.html#af4156b9dd11dd86db1b100750688a9be">More...</a><br /></td></tr>
<tr class="separator:af4156b9dd11dd86db1b100750688a9be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad548ae895f3dc0c38d891a5c7db123c"><td class="memItemLeft" align="right" valign="top"><a id="aad548ae895f3dc0c38d891a5c7db123c"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>array</b> (const <a class="el" href="classtpie_1_1array__view__base.html">array_view_base</a>&lt; T &gt; &amp;view)</td></tr>
<tr class="separator:aad548ae895f3dc0c38d891a5c7db123c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1eb3848672a01872c53e9fafbf296cc"><td class="memItemLeft" align="right" valign="top"><a id="aa1eb3848672a01872c53e9fafbf296cc"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>array</b> (const <a class="el" href="classtpie_1_1array__view__base.html">array_view_base</a>&lt; const T &gt; &amp;view)</td></tr>
<tr class="separator:aa1eb3848672a01872c53e9fafbf296cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32953d3bdb5280e6c352753c6c9db679"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1array.html#a32953d3bdb5280e6c352753c6c9db679">~array</a> ()</td></tr>
<tr class="memdesc:a32953d3bdb5280e6c352753c6c9db679"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free up all memory used by the array.  <a href="classtpie_1_1array.html#a32953d3bdb5280e6c352753c6c9db679">More...</a><br /></td></tr>
<tr class="separator:a32953d3bdb5280e6c352753c6c9db679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a326b7bd44430e7d850f098a5a84162e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1array.html#a326b7bd44430e7d850f098a5a84162e8">resize</a> (size_t <a class="el" href="classtpie_1_1array.html#a051a33a538aea7d4bd1f8a20f677e8fe">size</a>, const T &amp;elm)</td></tr>
<tr class="memdesc:a326b7bd44430e7d850f098a5a84162e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the size of the array.  <a href="classtpie_1_1array.html#a326b7bd44430e7d850f098a5a84162e8">More...</a><br /></td></tr>
<tr class="separator:a326b7bd44430e7d850f098a5a84162e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0952a8561648801ba927724073eafa8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1array.html#aa0952a8561648801ba927724073eafa8">swap</a> (<a class="el" href="classtpie_1_1array.html">array</a> &amp;other)</td></tr>
<tr class="memdesc:aa0952a8561648801ba927724073eafa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap two arrays.  <a href="classtpie_1_1array.html#aa0952a8561648801ba927724073eafa8">More...</a><br /></td></tr>
<tr class="separator:aa0952a8561648801ba927724073eafa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4225866638e443784216ae89cb30599b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1array.html#a4225866638e443784216ae89cb30599b">resize</a> (size_t s)</td></tr>
<tr class="memdesc:a4225866638e443784216ae89cb30599b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the size of the array.  <a href="classtpie_1_1array.html#a4225866638e443784216ae89cb30599b">More...</a><br /></td></tr>
<tr class="separator:a4225866638e443784216ae89cb30599b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a051a33a538aea7d4bd1f8a20f677e8fe"><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1array.html#a051a33a538aea7d4bd1f8a20f677e8fe">size</a> () const</td></tr>
<tr class="memdesc:a051a33a538aea7d4bd1f8a20f677e8fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the size of the array.  <a href="classtpie_1_1array.html#a051a33a538aea7d4bd1f8a20f677e8fe">More...</a><br /></td></tr>
<tr class="separator:a051a33a538aea7d4bd1f8a20f677e8fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c30ca9df6f7892d5f5f9bfbd79ace8"><td class="memItemLeft" align="right" valign="top">T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1array.html#a09c30ca9df6f7892d5f5f9bfbd79ace8">get</a> ()</td></tr>
<tr class="memdesc:a09c30ca9df6f7892d5f5f9bfbd79ace8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a raw pointer to the array content.  <a href="classtpie_1_1array.html#a09c30ca9df6f7892d5f5f9bfbd79ace8">More...</a><br /></td></tr>
<tr class="separator:a09c30ca9df6f7892d5f5f9bfbd79ace8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6df5cfbbe98155974086a231ca55659"><td class="memItemLeft" align="right" valign="top">const T *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1array.html#ac6df5cfbbe98155974086a231ca55659">get</a> () const</td></tr>
<tr class="memdesc:ac6df5cfbbe98155974086a231ca55659"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a raw pointer to the array content.  <a href="classtpie_1_1array.html#ac6df5cfbbe98155974086a231ca55659">More...</a><br /></td></tr>
<tr class="separator:ac6df5cfbbe98155974086a231ca55659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a327b4cf1317362637cd3302cee0238fe"><td class="memItemLeft" align="right" valign="top">Allocator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1array.html#a327b4cf1317362637cd3302cee0238fe">get_allocator</a> () const</td></tr>
<tr class="memdesc:a327b4cf1317362637cd3302cee0238fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return copy of the allocator.  <a href="classtpie_1_1array.html#a327b4cf1317362637cd3302cee0238fe">More...</a><br /></td></tr>
<tr class="separator:a327b4cf1317362637cd3302cee0238fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ab3203d15269f1b993d939dbe51b8e70b"><td class="memItemLeft" align="right" valign="top">static constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1array.html#ab3203d15269f1b993d939dbe51b8e70b">memory_coefficient</a> () noexcept</td></tr>
<tr class="memdesc:ab3203d15269f1b993d939dbe51b8e70b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the memory coefficient of the structure.  <a href="classtpie_1_1array.html#ab3203d15269f1b993d939dbe51b8e70b">More...</a><br /></td></tr>
<tr class="separator:ab3203d15269f1b993d939dbe51b8e70b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83114b26a19fc3d9755f0a348b71ba80"><td class="memItemLeft" align="right" valign="top">static constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtpie_1_1array.html#a83114b26a19fc3d9755f0a348b71ba80">memory_overhead</a> () noexcept</td></tr>
<tr class="memdesc:a83114b26a19fc3d9755f0a348b71ba80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the memory overhead of the structure.  <a href="classtpie_1_1array.html#a83114b26a19fc3d9755f0a348b71ba80">More...</a><br /></td></tr>
<tr class="separator:a83114b26a19fc3d9755f0a348b71ba80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56727e1e8df791a58bc95e013825a3ab"><td class="memItemLeft" align="right" valign="top">static constexpr memory_size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtpie_1_1linear__memory__base.html#a56727e1e8df791a58bc95e013825a3ab">memory_usage</a> (memory_size_type <a class="el" href="classtpie_1_1array.html#a051a33a538aea7d4bd1f8a20f677e8fe">size</a>) noexcept</td></tr>
<tr class="memdesc:a56727e1e8df791a58bc95e013825a3ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of bytes required to create a data structure supporting a given number of elements.  <a href="structtpie_1_1linear__memory__base.html#a56727e1e8df791a58bc95e013825a3ab">More...</a><br /></td></tr>
<tr class="separator:a56727e1e8df791a58bc95e013825a3ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02851b1dce51011fac41e93544982a71"><td class="memItemLeft" align="right" valign="top"><a id="a02851b1dce51011fac41e93544982a71"></a>
static constexpr <a class="el" href="structtpie_1_1linear__memory__usage.html">linear_memory_usage</a>&#160;</td><td class="memItemRight" valign="bottom"><b>memory_usage</b> () noexcept</td></tr>
<tr class="separator:a02851b1dce51011fac41e93544982a71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a289a5ec41ab5a2f0cc3de34b5ad76179"><td class="memItemLeft" align="right" valign="top">static constexpr memory_size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtpie_1_1linear__memory__base.html#a289a5ec41ab5a2f0cc3de34b5ad76179">memory_fits</a> (memory_size_type memory) noexcept</td></tr>
<tr class="memdesc:a289a5ec41ab5a2f0cc3de34b5ad76179"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the maximum number of elements that can be contained in in the structure when it is allowed to fill a given number of bytes.  <a href="structtpie_1_1linear__memory__base.html#a289a5ec41ab5a2f0cc3de34b5ad76179">More...</a><br /></td></tr>
<tr class="separator:a289a5ec41ab5a2f0cc3de34b5ad76179"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a6ab2455d3b9eedf52ced84729c156964"><td class="memItemLeft" align="right" valign="top"><a id="a6ab2455d3b9eedf52ced84729c156964"></a>
struct&#160;</td><td class="memItemRight" valign="bottom"><b>bits::allocator_usage&lt; T, Allocator &gt;</b></td></tr>
<tr class="separator:a6ab2455d3b9eedf52ced84729c156964"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, typename Allocator = allocator&lt;T&gt;&gt;<br />
class tpie::array&lt; T, Allocator &gt;</h3>

<p>A generic array with a fixed size. </p>
<p>This is almost the same as a real C-style T array but the memory management is better.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>The type of element to contain. </td></tr>
    <tr><td class="paramname">alloc_t</td><td>Allocator. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="array_8h_source.html#l00149">149</a> of file <a class="el" href="array_8h_source.html">array.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ab5e1a08202934b65612af9ccadd9b488"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5e1a08202934b65612af9ccadd9b488">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classtpie_1_1array__iter__base.html">array_iter_base</a>&lt;T const, true&gt; <a class="el" href="classtpie_1_1array.html">tpie::array</a>&lt; T, Allocator &gt;::<a class="el" href="classtpie_1_1array.html#ab5e1a08202934b65612af9ccadd9b488">const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator over a const array. </p>

<p class="definition">Definition at line <a class="el" href="array_8h_source.html#l00152">152</a> of file <a class="el" href="array_8h_source.html">array.h</a>.</p>

</div>
</div>
<a id="a99f9563215998023748073049a9cb511"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99f9563215998023748073049a9cb511">&#9670;&nbsp;</a></span>const_reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classtpie_1_1array__iter__base.html">array_iter_base</a>&lt;T const, false&gt; <a class="el" href="classtpie_1_1array.html">tpie::array</a>&lt; T, Allocator &gt;::<a class="el" href="classtpie_1_1array.html#a99f9563215998023748073049a9cb511">const_reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverse iterator over a const array. </p>

<p class="definition">Definition at line <a class="el" href="array_8h_source.html#l00155">155</a> of file <a class="el" href="array_8h_source.html">array.h</a>.</p>

</div>
</div>
<a id="a7b04586c0b86cbba5a9703c97b1f205d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b04586c0b86cbba5a9703c97b1f205d">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classtpie_1_1array__iter__base.html">array_iter_base</a>&lt;T, true&gt; <a class="el" href="classtpie_1_1array.html">tpie::array</a>&lt; T, Allocator &gt;::<a class="el" href="classtpie_1_1array.html#a7b04586c0b86cbba5a9703c97b1f205d">iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterator over an array. </p>

<p class="definition">Definition at line <a class="el" href="array_8h_source.html#l00158">158</a> of file <a class="el" href="array_8h_source.html">array.h</a>.</p>

</div>
</div>
<a id="a69b6f5387cd00bdcdc6f0266630281d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69b6f5387cd00bdcdc6f0266630281d9">&#9670;&nbsp;</a></span>reverse_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classtpie_1_1array__iter__base.html">array_iter_base</a>&lt;T, false&gt; <a class="el" href="classtpie_1_1array.html">tpie::array</a>&lt; T, Allocator &gt;::<a class="el" href="classtpie_1_1array.html#a69b6f5387cd00bdcdc6f0266630281d9">reverse_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reverse iterator over an array. </p>

<p class="definition">Definition at line <a class="el" href="array_8h_source.html#l00161">161</a> of file <a class="el" href="array_8h_source.html">array.h</a>.</p>

</div>
</div>
<a id="af706ead111ae5e158610993433ab68d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af706ead111ae5e158610993433ab68d0">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = allocator&lt;T&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T <a class="el" href="classtpie_1_1array.html">tpie::array</a>&lt; T, Allocator &gt;::<a class="el" href="classtpie_1_1array.html#af706ead111ae5e158610993433ab68d0">value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of values containd in the array. </p>

<p class="definition">Definition at line <a class="el" href="array_8h_source.html#l00164">164</a> of file <a class="el" href="array_8h_source.html">array.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a7ddcc40ef6171c0ae5770e37e9cc5900"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ddcc40ef6171c0ae5770e37e9cc5900">&#9670;&nbsp;</a></span>array() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtpie_1_1array.html">tpie::array</a>&lt; T, Allocator &gt;::<a class="el" href="classtpie_1_1array.html">array</a> </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct array of given size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The number of elements in the array. </td></tr>
    <tr><td class="paramname">value</td><td>Each entry of the array is initialized with this value. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="array_8h_source.html#l00413">413</a> of file <a class="el" href="array_8h_source.html">array.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;         : m_elements(0), m_size(0), m_tss_used(<span class="keyword">false</span>), m_allocator(alloc)</div>
<div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;        {<a class="code" href="classtpie_1_1array.html#a326b7bd44430e7d850f098a5a84162e8">resize</a>(s, value);}</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="array_8h_source.html#l00405">tpie::array&lt; tpie::file_stream&lt; element_type &gt; &gt;::memory_overhead()</a>.</p>

</div>
</div>
<a id="a1c26088472faf92f345e2eae2fe32431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c26088472faf92f345e2eae2fe32431">&#9670;&nbsp;</a></span>array() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtpie_1_1array.html">tpie::array</a>&lt; T, Allocator &gt;::<a class="el" href="classtpie_1_1array.html">array</a> </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>s</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Allocator &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code>Allocator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct array of given size. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The number of elements in the array. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="array_8h_source.html#l00430">430</a> of file <a class="el" href="array_8h_source.html">array.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;                      : m_elements(0), m_size(0), m_tss_used(<span class="keyword">false</span>),</div>
<div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;                        m_allocator(alloc) {<a class="code" href="classtpie_1_1array.html#a326b7bd44430e7d850f098a5a84162e8">resize</a>(s);}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a133e4b4e9d9594e8f5a09c1b33b78f2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a133e4b4e9d9594e8f5a09c1b33b78f2f">&#9670;&nbsp;</a></span>array() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtpie_1_1array.html">tpie::array</a>&lt; T, Allocator &gt;::<a class="el" href="classtpie_1_1array.html">array</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtpie_1_1array.html">array</a>&lt; T, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a copy of another array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The array to copy. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="array_8h_source.html#l00438">438</a> of file <a class="el" href="array_8h_source.html">array.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;                              : m_elements(0), m_size(other.m_size), m_tss_used(<span class="keyword">false</span>), m_allocator(other.m_allocator) {</div>
<div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;        <span class="keywordflow">if</span> (other.size() == 0) <span class="keywordflow">return</span>;</div>
<div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;        alloc_copy(other.m_elements);</div>
<div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="af4156b9dd11dd86db1b100750688a9be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4156b9dd11dd86db1b100750688a9be">&#9670;&nbsp;</a></span>array() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtpie_1_1array.html">tpie::array</a>&lt; T, Allocator &gt;::<a class="el" href="classtpie_1_1array.html">array</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtpie_1_1array.html">array</a>&lt; T, Allocator &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move construct from another array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The array to move. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="array_8h_source.html#l00447">447</a> of file <a class="el" href="array_8h_source.html">array.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;        : m_elements(other.m_elements)</div>
<div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;        , m_size(other.m_size)</div>
<div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;        , m_tss_used(other.m_tss_used)</div>
<div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;        , m_allocator(other.m_allocator) {</div>
<div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;        other.m_elements = <span class="keyword">nullptr</span>;</div>
<div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;        other.m_size = 0;</div>
<div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;        other.m_tss_used = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a32953d3bdb5280e6c352753c6c9db679"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32953d3bdb5280e6c352753c6c9db679">&#9670;&nbsp;</a></span>~array()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtpie_1_1array.html">tpie::array</a>&lt; T, Allocator &gt;::~<a class="el" href="classtpie_1_1array.html">array</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Free up all memory used by the array. </p>

<p class="definition">Definition at line <a class="el" href="array_8h_source.html#l00478">478</a> of file <a class="el" href="array_8h_source.html">array.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;{<a class="code" href="classtpie_1_1array.html#a326b7bd44430e7d850f098a5a84162e8">resize</a>(0);}</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a41970720ee4d82c796e18fae52f8df17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41970720ee4d82c796e18fae52f8df17">&#9670;&nbsp;</a></span>at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classtpie_1_1array.html">tpie::array</a>&lt; T, Allocator &gt;::at </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
        <tr>
          <td align="right">throw </td><td>(</td><td colspan="2"></td>
        </tr>
        <tr>
          <td align="right"></td><td>)</td><td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the element located at the given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The index of the element returned. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="array_8h_source.html#l00193">193</a> of file <a class="el" href="array_8h_source.html">array.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;                             {</div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;        assert(i &lt; <a class="code" href="classtpie_1_1array.html#a051a33a538aea7d4bd1f8a20f677e8fe">size</a>());</div>
<div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;        <span class="keywordflow">return</span> m_elements[i];</div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;    }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="array_8h_source.html#l00348">tpie::array&lt; tpie::file_stream&lt; element_type &gt; &gt;::back()</a>, <a class="el" href="array_8h_source.html#l00338">tpie::array&lt; tpie::file_stream&lt; element_type &gt; &gt;::front()</a>, and <a class="el" href="array_8h_source.html#l00266">tpie::array&lt; tpie::file_stream&lt; element_type &gt; &gt;::operator[]()</a>.</p>

</div>
</div>
<a id="a5791e3e81d96074acd17bfc98b27309b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5791e3e81d96074acd17bfc98b27309b">&#9670;&nbsp;</a></span>at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classtpie_1_1array.html">tpie::array</a>&lt; T, Allocator &gt;::at </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
        <tr>
          <td align="right">throw </td><td>(</td><td colspan="2"></td>
        </tr>
        <tr>
          <td align="right"></td><td>)</td><td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the element located at the given index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The index of the element returned. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="array_8h_source.html#l00201">201</a> of file <a class="el" href="array_8h_source.html">array.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;                                         {</div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;        assert(i &lt; <a class="code" href="classtpie_1_1array.html#a051a33a538aea7d4bd1f8a20f677e8fe">size</a>());</div>
<div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;        <span class="keywordflow">return</span> m_elements[i];</div>
<div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a09d47a74d21e8b29389194afec2f4780"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09d47a74d21e8b29389194afec2f4780">&#9670;&nbsp;</a></span>back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classtpie_1_1array.html">tpie::array</a>&lt; T, Allocator &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the last element in the array. </p>

<p class="definition">Definition at line <a class="el" href="array_8h_source.html#l00353">353</a> of file <a class="el" href="array_8h_source.html">array.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;{<span class="keywordflow">return</span> <a class="code" href="classtpie_1_1array.html#a41970720ee4d82c796e18fae52f8df17">at</a>(<a class="code" href="classtpie_1_1array.html#a051a33a538aea7d4bd1f8a20f677e8fe">size</a>()-1);}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ad8a149566cc3ec211bf9a8918b4db61b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8a149566cc3ec211bf9a8918b4db61b">&#9670;&nbsp;</a></span>back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classtpie_1_1array.html">tpie::array</a>&lt; T, Allocator &gt;::back </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the last element in the array. </p>

<p class="definition">Definition at line <a class="el" href="array_8h_source.html#l00348">348</a> of file <a class="el" href="array_8h_source.html">array.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;{<span class="keywordflow">return</span> <a class="code" href="classtpie_1_1array.html#a41970720ee4d82c796e18fae52f8df17">at</a>(<a class="code" href="classtpie_1_1array.html#a051a33a538aea7d4bd1f8a20f677e8fe">size</a>()-1);}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a2ce6320438ae73b208b4a51fd0eee22e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ce6320438ae73b208b4a51fd0eee22e">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtpie_1_1array.html#a7b04586c0b86cbba5a9703c97b1f205d">iterator</a> <a class="el" href="classtpie_1_1array.html">tpie::array</a>&lt; T, Allocator &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an iterator to the beginning of the array. </p>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the beginning of the array. </dd></dl>

<p class="definition">Definition at line <a class="el" href="array_8h_source.html#l00312">312</a> of file <a class="el" href="array_8h_source.html">array.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;{<span class="keywordflow">return</span> get_iter(0);}</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="internal__vector_8h_source.html#l00115">tpie::internal_vector&lt; T &gt;::begin()</a>, <a class="el" href="disjoint__sets_8h_source.html#l00164">tpie::disjoint_sets&lt; value_t &gt;::clear()</a>, <a class="el" href="internal__priority__queue_8h_source.html#l00088">tpie::internal_priority_queue&lt; tpie::ami::heap_ptr&lt; REC &gt;, comp &gt;::make_safe()</a>, <a class="el" href="internal__priority__queue_8h_source.html#l00124">tpie::internal_priority_queue&lt; tpie::ami::heap_ptr&lt; REC &gt;, comp &gt;::pop()</a>, <a class="el" href="internal__priority__queue_8h_source.html#l00133">tpie::internal_priority_queue&lt; tpie::ami::heap_ptr&lt; REC &gt;, comp &gt;::pop_and_push()</a>, <a class="el" href="internal__priority__queue_8h_source.html#l00109">tpie::internal_priority_queue&lt; tpie::ami::heap_ptr&lt; REC &gt;, comp &gt;::push()</a>, <a class="el" href="serialization2_8h_source.html#l00266">tpie::serialize()</a>, and <a class="el" href="serialization2_8h_source.html#l00276">tpie::unserialize()</a>.</p>

</div>
</div>
<a id="a5f5c04d69504209c7cd5963245112ace"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f5c04d69504209c7cd5963245112ace">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtpie_1_1array.html#ab5e1a08202934b65612af9ccadd9b488">const_iterator</a> <a class="el" href="classtpie_1_1array.html">tpie::array</a>&lt; T, Allocator &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const iterator to the beginning of the array. </p>
<dl class="section return"><dt>Returns</dt><dd>A const iterator to the beginning of the array. </dd></dl>

<p class="definition">Definition at line <a class="el" href="array_8h_source.html#l00319">319</a> of file <a class="el" href="array_8h_source.html">array.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;{<span class="keywordflow">return</span> get_iter(0);}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a749b21f2611816c04a9462b1337bd27d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a749b21f2611816c04a9462b1337bd27d">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtpie_1_1array.html">tpie::array</a>&lt; T, Allocator &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if the array is empty. </p>
<dl class="section return"><dt>Returns</dt><dd>True if and only if size is 0. </dd></dl>

<p class="definition">Definition at line <a class="el" href="array_8h_source.html#l00258">258</a> of file <a class="el" href="array_8h_source.html">array.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;{<span class="keywordflow">return</span> <a class="code" href="classtpie_1_1array.html#a051a33a538aea7d4bd1f8a20f677e8fe">size</a>() == 0;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a9cd10fa88715b8552d9a25b4cc0ed21a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cd10fa88715b8552d9a25b4cc0ed21a">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtpie_1_1array.html#a7b04586c0b86cbba5a9703c97b1f205d">iterator</a> <a class="el" href="classtpie_1_1array.html">tpie::array</a>&lt; T, Allocator &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an iterator to the end of the array. </p>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the end of the array. </dd></dl>

<p class="definition">Definition at line <a class="el" href="array_8h_source.html#l00326">326</a> of file <a class="el" href="array_8h_source.html">array.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;{<span class="keywordflow">return</span> get_iter(<a class="code" href="classtpie_1_1array.html#a051a33a538aea7d4bd1f8a20f677e8fe">size</a>());}</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="disjoint__sets_8h_source.html#l00164">tpie::disjoint_sets&lt; value_t &gt;::clear()</a>, <a class="el" href="serialization2_8h_source.html#l00266">tpie::serialize()</a>, and <a class="el" href="serialization2_8h_source.html#l00276">tpie::unserialize()</a>.</p>

</div>
</div>
<a id="a34afe3cfbb09d1ca87113c712c6419e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34afe3cfbb09d1ca87113c712c6419e8">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtpie_1_1array.html#ab5e1a08202934b65612af9ccadd9b488">const_iterator</a> <a class="el" href="classtpie_1_1array.html">tpie::array</a>&lt; T, Allocator &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const iterator to the end of the array. </p>
<dl class="section return"><dt>Returns</dt><dd>A const iterator to the end of the array. </dd></dl>

<p class="definition">Definition at line <a class="el" href="array_8h_source.html#l00333">333</a> of file <a class="el" href="array_8h_source.html">array.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;{<span class="keywordflow">return</span> get_iter(<a class="code" href="classtpie_1_1array.html#a051a33a538aea7d4bd1f8a20f677e8fe">size</a>());}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a2d6891eeb4c1e37678e681fb0ee55f3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d6891eeb4c1e37678e681fb0ee55f3d">&#9670;&nbsp;</a></span>find() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtpie_1_1array.html#a7b04586c0b86cbba5a9703c97b1f205d">iterator</a> <a class="el" href="classtpie_1_1array.html">tpie::array</a>&lt; T, Allocator &gt;::find </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
        <tr>
          <td align="right">throw </td><td>(</td><td colspan="2"></td>
        </tr>
        <tr>
          <td align="right"></td><td>)</td><td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an iterator to the i'th element of the array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The index of the element we want an iterator to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator to the i'th element. </dd></dl>

<p class="definition">Definition at line <a class="el" href="array_8h_source.html#l00172">172</a> of file <a class="el" href="array_8h_source.html">array.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;                                       {</div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;        assert(idx &lt;= <a class="code" href="classtpie_1_1array.html#a051a33a538aea7d4bd1f8a20f677e8fe">size</a>());</div>
<div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;        <span class="keywordflow">return</span> get_iter(idx);</div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;    }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="internal__vector_8h_source.html#l00125">tpie::internal_vector&lt; T &gt;::end()</a>, <a class="el" href="internal__priority__queue_8h_source.html#l00064">tpie::internal_priority_queue&lt; tpie::ami::heap_ptr&lt; REC &gt;, comp &gt;::insert()</a>, <a class="el" href="internal__priority__queue_8h_source.html#l00088">tpie::internal_priority_queue&lt; tpie::ami::heap_ptr&lt; REC &gt;, comp &gt;::make_safe()</a>, <a class="el" href="internal__priority__queue_8h_source.html#l00124">tpie::internal_priority_queue&lt; tpie::ami::heap_ptr&lt; REC &gt;, comp &gt;::pop()</a>, <a class="el" href="internal__priority__queue_8h_source.html#l00133">tpie::internal_priority_queue&lt; tpie::ami::heap_ptr&lt; REC &gt;, comp &gt;::pop_and_push()</a>, and <a class="el" href="internal__priority__queue_8h_source.html#l00109">tpie::internal_priority_queue&lt; tpie::ami::heap_ptr&lt; REC &gt;, comp &gt;::push()</a>.</p>

</div>
</div>
<a id="a4b9f17a53da53f0cb5bc85d0a8558196"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b9f17a53da53f0cb5bc85d0a8558196">&#9670;&nbsp;</a></span>find() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtpie_1_1array.html#ab5e1a08202934b65612af9ccadd9b488">const_iterator</a> <a class="el" href="classtpie_1_1array.html">tpie::array</a>&lt; T, Allocator &gt;::find </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
        <tr>
          <td align="right">throw </td><td>(</td><td colspan="2"></td>
        </tr>
        <tr>
          <td align="right"></td><td>)</td><td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const iterator to the i'th element of the array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The index of the element we want an iterator to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A const iterator to the i'th element. </dd></dl>

<p class="definition">Definition at line <a class="el" href="array_8h_source.html#l00183">183</a> of file <a class="el" href="array_8h_source.html">array.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;                                                   {</div>
<div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;        assert(idx &lt;= <a class="code" href="classtpie_1_1array.html#a051a33a538aea7d4bd1f8a20f677e8fe">size</a>());</div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;        <span class="keywordflow">return</span> get_iter(idx);</div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a4940f60b93b2c6a1a3c9a7c4d3d1bae6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4940f60b93b2c6a1a3c9a7c4d3d1bae6">&#9670;&nbsp;</a></span>front() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classtpie_1_1array.html">tpie::array</a>&lt; T, Allocator &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the first element in the array. </p>

<p class="definition">Definition at line <a class="el" href="array_8h_source.html#l00343">343</a> of file <a class="el" href="array_8h_source.html">array.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;{<span class="keywordflow">return</span> <a class="code" href="classtpie_1_1array.html#a41970720ee4d82c796e18fae52f8df17">at</a>(0);}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a8a79806a3f0ddd0b02ae918064264bef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a79806a3f0ddd0b02ae918064264bef">&#9670;&nbsp;</a></span>front() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classtpie_1_1array.html">tpie::array</a>&lt; T, Allocator &gt;::front </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the first element in the array. </p>

<p class="definition">Definition at line <a class="el" href="array_8h_source.html#l00338">338</a> of file <a class="el" href="array_8h_source.html">array.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;{<span class="keywordflow">return</span> <a class="code" href="classtpie_1_1array.html#a41970720ee4d82c796e18fae52f8df17">at</a>(0);}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a09c30ca9df6f7892d5f5f9bfbd79ace8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c30ca9df6f7892d5f5f9bfbd79ace8">&#9670;&nbsp;</a></span>get() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* <a class="el" href="classtpie_1_1array.html">tpie::array</a>&lt; T, Allocator &gt;::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a raw pointer to the array content. </p>

<p class="definition">Definition at line <a class="el" href="array_8h_source.html#l00536">536</a> of file <a class="el" href="array_8h_source.html">array.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;{<span class="keywordflow">return</span> m_elements;}</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="compressed_2buffer_8h_source.html#l00138">tpie::compressor_buffer::get()</a>, and <a class="el" href="serialization__stream_8h_source.html#l00287">tpie::bits::serialization_reader_base::read()</a>.</p>

</div>
</div>
<a id="ac6df5cfbbe98155974086a231ca55659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6df5cfbbe98155974086a231ca55659">&#9670;&nbsp;</a></span>get() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T* <a class="el" href="classtpie_1_1array.html">tpie::array</a>&lt; T, Allocator &gt;::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a raw pointer to the array content. </p>

<p class="definition">Definition at line <a class="el" href="array_8h_source.html#l00541">541</a> of file <a class="el" href="array_8h_source.html">array.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;{<span class="keywordflow">return</span> m_elements;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a327b4cf1317362637cd3302cee0238fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a327b4cf1317362637cd3302cee0238fe">&#9670;&nbsp;</a></span>get_allocator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Allocator <a class="el" href="classtpie_1_1array.html">tpie::array</a>&lt; T, Allocator &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return copy of the allocator. </p>

<p class="definition">Definition at line <a class="el" href="array_8h_source.html#l00546">546</a> of file <a class="el" href="array_8h_source.html">array.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;{<span class="keywordflow">return</span> m_allocator;}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab3203d15269f1b993d939dbe51b8e70b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3203d15269f1b993d939dbe51b8e70b">&#9670;&nbsp;</a></span>memory_coefficient()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr double <a class="el" href="classtpie_1_1array.html">tpie::array</a>&lt; T, Allocator &gt;::memory_coefficient </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the memory coefficient of the structure. </p>
<p>Allocating a structure with n elements will use at most \( \lfloor \mathrm{memory\_coefficient} \cdot n + \mathrm{memory\_overhead} \rfloor \) bytes. This does not include memory overhead incurred if the structure is allocated using new. </p><dl class="section return"><dt>Returns</dt><dd>The memory coefficient of the structure. </dd></dl>

<p class="definition">Definition at line <a class="el" href="array_8h_source.html#l00398">398</a> of file <a class="el" href="array_8h_source.html">array.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;                                                          {</div>
<div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;        <span class="keywordflow">return</span> (<span class="keywordtype">double</span>)<span class="keyword">sizeof</span>(T);</div>
<div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;    }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="internal__queue_8h_source.html#l00050">tpie::internal_queue&lt; item_type &gt;::memory_coefficient()</a>, <a class="el" href="internal__stack__vector__base_8h_source.html#l00051">tpie::internal_stack_vector_base&lt; T, internal_stack&lt; T &gt; &gt;::memory_coefficient()</a>, <a class="el" href="disjoint__sets_8h_source.html#l00053">tpie::disjoint_sets&lt; value_t &gt;::memory_coefficient()</a>, and <a class="el" href="internal__priority__queue_8h_source.html#l00158">tpie::internal_priority_queue&lt; tpie::ami::heap_ptr&lt; REC &gt;, comp &gt;::memory_coefficient()</a>.</p>

</div>
</div>
<a id="a289a5ec41ab5a2f0cc3de34b5ad76179"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a289a5ec41ab5a2f0cc3de34b5ad76179">&#9670;&nbsp;</a></span>memory_fits()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr memory_size_type <a class="el" href="structtpie_1_1linear__memory__base.html">tpie::linear_memory_base</a>&lt; <a class="el" href="classtpie_1_1array.html">array</a>&lt; T &gt;  &gt;::memory_fits </td>
          <td>(</td>
          <td class="paramtype">memory_size_type&#160;</td>
          <td class="paramname"><em>memory</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the maximum number of elements that can be contained in in the structure when it is allowed to fill a given number of bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">memory</td><td>The number of bytes the structure is allowed to occupy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of elements that will fit in the structure </dd></dl>

<p class="definition">Definition at line <a class="el" href="util_8h_source.html#l00118">118</a> of file <a class="el" href="util_8h_source.html">util.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;                                                                                    {</div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>memory_size_type<span class="keyword">&gt;</span>(</div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;            floor((memory - child_t::memory_overhead()) / child_t::memory_coefficient()));</div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a83114b26a19fc3d9755f0a348b71ba80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83114b26a19fc3d9755f0a348b71ba80">&#9670;&nbsp;</a></span>memory_overhead()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr double <a class="el" href="classtpie_1_1array.html">tpie::array</a>&lt; T, Allocator &gt;::memory_overhead </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the memory overhead of the structure. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classtpie_1_1array.html#ab3203d15269f1b993d939dbe51b8e70b" title="Return the memory coefficient of the structure.">memory_coefficient()</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The memory overhead. </dd></dl>

<p class="definition">Definition at line <a class="el" href="array_8h_source.html#l00405">405</a> of file <a class="el" href="array_8h_source.html">array.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;{<span class="keywordflow">return</span> <span class="keyword">sizeof</span>(<a class="code" href="classtpie_1_1array.html#a7ddcc40ef6171c0ae5770e37e9cc5900">array</a>);}</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="internal__queue_8h_source.html#l00056">tpie::internal_queue&lt; item_type &gt;::memory_overhead()</a>, <a class="el" href="internal__stack__vector__base_8h_source.html#l00056">tpie::internal_stack_vector_base&lt; T, internal_stack&lt; T &gt; &gt;::memory_overhead()</a>, <a class="el" href="disjoint__sets_8h_source.html#l00061">tpie::disjoint_sets&lt; value_t &gt;::memory_overhead()</a>, and <a class="el" href="internal__priority__queue_8h_source.html#l00166">tpie::internal_priority_queue&lt; tpie::ami::heap_ptr&lt; REC &gt;, comp &gt;::memory_overhead()</a>.</p>

</div>
</div>
<a id="a56727e1e8df791a58bc95e013825a3ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56727e1e8df791a58bc95e013825a3ab">&#9670;&nbsp;</a></span>memory_usage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr memory_size_type <a class="el" href="structtpie_1_1linear__memory__base.html">tpie::linear_memory_base</a>&lt; <a class="el" href="classtpie_1_1array.html">array</a>&lt; T &gt;  &gt;::memory_usage </td>
          <td>(</td>
          <td class="paramtype">memory_size_type&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of bytes required to create a data structure supporting a given number of elements. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The number of elements to support </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The amount of memory required in bytes </dd></dl>

<p class="definition">Definition at line <a class="el" href="util_8h_source.html#l00106">106</a> of file <a class="el" href="util_8h_source.html">util.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;                                                                                   {</div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>memory_size_type<span class="keyword">&gt;</span>(</div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;            floor(<span class="keyword">static_cast&lt;</span><span class="keywordtype">double</span><span class="keyword">&gt;</span>(size) * child_t::memory_coefficient() + child_t::memory_overhead()));</div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a1247c3c80954079b625860f96c10734c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1247c3c80954079b625860f96c10734c">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtpie_1_1array.html">tpie::array</a>&lt; T, Allocator &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtpie_1_1array.html">array</a>&lt; T, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if two arrays differ. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The array to compare against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if they are equal; otherwise true. </dd></dl>

<p class="definition">Definition at line <a class="el" href="array_8h_source.html#l00301">301</a> of file <a class="el" href="array_8h_source.html">array.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;                                               {</div>
<div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="classtpie_1_1array.html#a051a33a538aea7d4bd1f8a20f677e8fe">size</a>() != other.size()) <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i&lt;<a class="code" href="classtpie_1_1array.html#a051a33a538aea7d4bd1f8a20f677e8fe">size</a>(); ++i) <span class="keywordflow">if</span> (*get_iter(i) != *other.get_iter(i)) <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a4b8e24bc55c68acb939c12eb5866cc3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b8e24bc55c68acb939c12eb5866cc3a">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtpie_1_1array.html">array</a>&amp; <a class="el" href="classtpie_1_1array.html">tpie::array</a>&lt; T, Allocator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtpie_1_1array.html">array</a>&lt; T, Allocator &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move elements from another array into this. </p>
<p>Note: This array is resized to the size of other.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The array to copy from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this array. </dd></dl>

<p class="definition">Definition at line <a class="el" href="array_8h_source.html#l00228">228</a> of file <a class="el" href="array_8h_source.html">array.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;                                      {</div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;        <a class="code" href="classtpie_1_1array.html#a326b7bd44430e7d850f098a5a84162e8">resize</a>(0);</div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;        <a class="code" href="uncompressed__stream_8h.html#a0f6f3a3238be8084ae8f16ae2658bb10">std::swap</a>(m_allocator, other.m_allocator);</div>
<div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;        <a class="code" href="uncompressed__stream_8h.html#a0f6f3a3238be8084ae8f16ae2658bb10">std::swap</a>(m_elements, other.m_elements);</div>
<div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;        <a class="code" href="uncompressed__stream_8h.html#a0f6f3a3238be8084ae8f16ae2658bb10">std::swap</a>(m_size, other.m_size);</div>
<div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;        <a class="code" href="uncompressed__stream_8h.html#a0f6f3a3238be8084ae8f16ae2658bb10">std::swap</a>(m_tss_used, other.m_tss_used);</div>
<div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;        <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="ab215b343b17b2d7f5735fd5e9b7735fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab215b343b17b2d7f5735fd5e9b7735fb">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtpie_1_1array.html">array</a>&amp; <a class="el" href="classtpie_1_1array.html">tpie::array</a>&lt; T, Allocator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtpie_1_1array.html">array</a>&lt; T, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy elements from another array into this. </p>
<p>Note: This array is resized to the size of other.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The array to copy from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this array. </dd></dl>

<p class="definition">Definition at line <a class="el" href="array_8h_source.html#l00214">214</a> of file <a class="el" href="array_8h_source.html">array.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;                                           {</div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;        <a class="code" href="classtpie_1_1array.html#a326b7bd44430e7d850f098a5a84162e8">resize</a>(other.size());</div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i &lt; <a class="code" href="classtpie_1_1array.html#a051a33a538aea7d4bd1f8a20f677e8fe">size</a>(); ++i) m_elements[i] = other[i];</div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;        <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="af74a0ea20473c276697c75660612ee54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af74a0ea20473c276697c75660612ee54">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = allocator&lt;T&gt;&gt; </div>
<div class="memtemplate">
template&lt;typename OtherAllocator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtpie_1_1array.html">array</a>&amp; <a class="el" href="classtpie_1_1array.html">tpie::array</a>&lt; T, Allocator &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtpie_1_1array.html">array</a>&lt; T, OtherAllocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy elements from another array with any allocator into this. </p>
<p>Note: This array is resized to the size of other.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The array to copy from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OtherAllocator</td><td>The allocator used by the other array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A reference to this array. </dd></dl>

<p class="definition">Definition at line <a class="el" href="array_8h_source.html#l00247">247</a> of file <a class="el" href="array_8h_source.html">array.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;                                                              {</div>
<div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;        <a class="code" href="classtpie_1_1array.html#a326b7bd44430e7d850f098a5a84162e8">resize</a>(other.size());</div>
<div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0; i &lt; <a class="code" href="classtpie_1_1array.html#a051a33a538aea7d4bd1f8a20f677e8fe">size</a>(); ++i) m_elements[i] = other[i];</div>
<div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;        <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="af62d3144110943e4d1a15ed7265fcacf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af62d3144110943e4d1a15ed7265fcacf">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classtpie_1_1array.html">tpie::array</a>&lt; T, Allocator &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtpie_1_1array.html">array</a>&lt; T, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare if the other array has the same elements in the same order as this. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The array to compare against. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if they are equal otherwise false. </dd></dl>

<p class="definition">Definition at line <a class="el" href="array_8h_source.html#l00289">289</a> of file <a class="el" href="array_8h_source.html">array.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;                                               {</div>
<div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="classtpie_1_1array.html#a051a33a538aea7d4bd1f8a20f677e8fe">size</a>() != other.size()) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i=0;i&lt;<a class="code" href="classtpie_1_1array.html#a051a33a538aea7d4bd1f8a20f677e8fe">size</a>();++i) <span class="keywordflow">if</span> (*get_iter(i) != *other.get_iter(i)) <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;        <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a41bb47cb27ffe30a08d56133268b2ac1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41bb47cb27ffe30a08d56133268b2ac1">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classtpie_1_1array.html">tpie::array</a>&lt; T, Allocator &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a reference to an array entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The index of the entry to return. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the entry. </dd></dl>

<p class="definition">Definition at line <a class="el" href="array_8h_source.html#l00277">277</a> of file <a class="el" href="array_8h_source.html">array.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;                             {</div>
<div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;        assert(i &lt; <a class="code" href="classtpie_1_1array.html#a051a33a538aea7d4bd1f8a20f677e8fe">size</a>());</div>
<div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="classtpie_1_1array.html#a41970720ee4d82c796e18fae52f8df17">at</a>(i);</div>
<div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a50350751e6465d5bbb6d7eee932ee58a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50350751e6465d5bbb6d7eee932ee58a">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classtpie_1_1array.html">tpie::array</a>&lt; T, Allocator &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const reference to an array entry. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The index of the entry to return. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Const reference to the entry. </dd></dl>

<p class="definition">Definition at line <a class="el" href="array_8h_source.html#l00266">266</a> of file <a class="el" href="array_8h_source.html">array.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;                                         {</div>
<div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;        assert(i &lt; <a class="code" href="classtpie_1_1array.html#a051a33a538aea7d4bd1f8a20f677e8fe">size</a>());</div>
<div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;        <span class="keywordflow">return</span> <a class="code" href="classtpie_1_1array.html#a41970720ee4d82c796e18fae52f8df17">at</a>(i);</div>
<div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a82555ac6891558fe31efc6aaa38ff765"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82555ac6891558fe31efc6aaa38ff765">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtpie_1_1array.html#a69b6f5387cd00bdcdc6f0266630281d9">reverse_iterator</a> <a class="el" href="classtpie_1_1array.html">tpie::array</a>&lt; T, Allocator &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverse iterator to beginning of reverse sequence. </p>

<p class="definition">Definition at line <a class="el" href="array_8h_source.html#l00358">358</a> of file <a class="el" href="array_8h_source.html">array.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;{<span class="keywordflow">return</span> get_rev_iter(0);}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a0eb190056e9f8ba6df0d0da4c93cb927"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eb190056e9f8ba6df0d0da4c93cb927">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtpie_1_1array.html#a99f9563215998023748073049a9cb511">const_reverse_iterator</a> <a class="el" href="classtpie_1_1array.html">tpie::array</a>&lt; T, Allocator &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Const reverse iterator to beginning of reverse sequence. </p>

<p class="definition">Definition at line <a class="el" href="array_8h_source.html#l00363">363</a> of file <a class="el" href="array_8h_source.html">array.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;{<span class="keywordflow">return</span> get_rev_iter(0);}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a4787d5836e29a34ad0cbe3bc8b68063d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4787d5836e29a34ad0cbe3bc8b68063d">&#9670;&nbsp;</a></span>rend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtpie_1_1array.html#a69b6f5387cd00bdcdc6f0266630281d9">reverse_iterator</a> <a class="el" href="classtpie_1_1array.html">tpie::array</a>&lt; T, Allocator &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverse iterator to end of reverse sequence. </p>

<p class="definition">Definition at line <a class="el" href="array_8h_source.html#l00368">368</a> of file <a class="el" href="array_8h_source.html">array.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;{<span class="keywordflow">return</span> get_rev_iter(<a class="code" href="classtpie_1_1array.html#a051a33a538aea7d4bd1f8a20f677e8fe">size</a>());}</div>
</div><!-- fragment -->
</div>
</div>
<a id="acdd5ab659e19d124af6c18803f88371d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdd5ab659e19d124af6c18803f88371d">&#9670;&nbsp;</a></span>rend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtpie_1_1array.html#a99f9563215998023748073049a9cb511">const_reverse_iterator</a> <a class="el" href="classtpie_1_1array.html">tpie::array</a>&lt; T, Allocator &gt;::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Const reverse iterator to end of reverse sequence. </p>

<p class="definition">Definition at line <a class="el" href="array_8h_source.html#l00373">373</a> of file <a class="el" href="array_8h_source.html">array.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;{<span class="keywordflow">return</span> get_rev_iter(<a class="code" href="classtpie_1_1array.html#a051a33a538aea7d4bd1f8a20f677e8fe">size</a>());}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a4225866638e443784216ae89cb30599b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4225866638e443784216ae89cb30599b">&#9670;&nbsp;</a></span>resize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtpie_1_1array.html">tpie::array</a>&lt; T, Allocator &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the size of the array. </p>
<p>All elements are lost.</p>
<p>Memory manager MUST be initialized at this point unless s == 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The new size of the array. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="array_8h_source.html#l00520">520</a> of file <a class="el" href="array_8h_source.html">array.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160;                          {</div>
<div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;        destruct_and_dealloc();</div>
<div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;        m_size = s;</div>
<div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;        alloc_dfl();</div>
<div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;    }</div>
</div><!-- fragment -->
</div>
</div>
<a id="a326b7bd44430e7d850f098a5a84162e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a326b7bd44430e7d850f098a5a84162e8">&#9670;&nbsp;</a></span>resize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtpie_1_1array.html">tpie::array</a>&lt; T, Allocator &gt;::resize </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>elm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the size of the array. </p>
<p>All elements are lost.</p>
<p>Memory manager MUST be initialized at this point unless s == 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>The new size of the array. </td></tr>
    <tr><td class="paramname">elm</td><td>The initialization element. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="array_8h_source.html#l00490">490</a> of file <a class="el" href="array_8h_source.html">array.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;                                            {</div>
<div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;        <span class="keywordflow">if</span> (<a class="code" href="classtpie_1_1array.html#a051a33a538aea7d4bd1f8a20f677e8fe">size</a> != m_size) {</div>
<div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;            destruct_and_dealloc();</div>
<div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;            m_size = <a class="code" href="classtpie_1_1array.html#a051a33a538aea7d4bd1f8a20f677e8fe">size</a>;</div>
<div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160; </div>
<div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;            alloc_fill(elm);</div>
<div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;        } <span class="keywordflow">else</span> {</div>
<div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;            std::fill(m_elements+0, m_elements+m_size, elm);</div>
<div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;        }</div>
<div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;    }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="array_8h_source.html#l00413">tpie::array&lt; tpie::file_stream&lt; element_type &gt; &gt;::array()</a>, <a class="el" href="merge__sorter_8h_source.html#l00423">tpie::merge_sorter&lt; T, UseProgress, pred_t, store_t &gt;::begin()</a>, <a class="el" href="pipelining_2parallel_2base_8h_source.html#l01029">tpie::pipelining::parallel_bits::producer&lt; T1, T2 &gt;::begin()</a>, <a class="el" href="merge__sorter_8h_source.html#l00464">tpie::merge_sorter&lt; T, UseProgress, pred_t, store_t &gt;::end()</a>, <a class="el" href="pipelining_2parallel_2base_8h_source.html#l01123">tpie::pipelining::parallel_bits::producer&lt; T1, T2 &gt;::end()</a>, <a class="el" href="serialization__sorter_8h_source.html#l00207">tpie::serialization_bits::internal_sort&lt; T, std::less&lt; T &gt; &gt;::free()</a>, <a class="el" href="internal__queue_8h_source.html#l00064">tpie::internal_queue&lt; item_type &gt;::internal_queue()</a>, <a class="el" href="array_8h_source.html#l00214">tpie::array&lt; tpie::file_stream&lt; element_type &gt; &gt;::operator=()</a>, <a class="el" href="merge__sorter_8h_source.html#l00717">tpie::merge_sorter&lt; T, UseProgress, pred_t, store_t &gt;::pull()</a>, <a class="el" href="internal__queue_8h_source.html#l00071">tpie::internal_queue&lt; item_type &gt;::resize()</a>, <a class="el" href="internal__stack__vector__base_8h_source.html#l00077">tpie::internal_stack_vector_base&lt; T, internal_stack&lt; T &gt; &gt;::resize()</a>, <a class="el" href="disjoint__sets_8h_source.html#l00173">tpie::disjoint_sets&lt; value_t &gt;::resize()</a>, <a class="el" href="internal__priority__queue_8h_source.html#l00188">tpie::internal_priority_queue&lt; tpie::ami::heap_ptr&lt; REC &gt;, comp &gt;::resize()</a>, <a class="el" href="compressed_2buffer_8h_source.html#l00173">tpie::compressor_buffer::set_capacity()</a>, <a class="el" href="serialization2_8h_source.html#l00276">tpie::unserialize()</a>, and <a class="el" href="array_8h_source.html#l00478">tpie::array&lt; tpie::file_stream&lt; element_type &gt; &gt;::~array()</a>.</p>

</div>
</div>
<a id="a051a33a538aea7d4bd1f8a20f677e8fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a051a33a538aea7d4bd1f8a20f677e8fe">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classtpie_1_1array.html">tpie::array</a>&lt; T, Allocator &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the size of the array. </p>
<dl class="section return"><dt>Returns</dt><dd>The size of the array. </dd></dl>

<p class="definition">Definition at line <a class="el" href="array_8h_source.html#l00531">531</a> of file <a class="el" href="array_8h_source.html">array.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;{<span class="keywordflow">return</span> m_size;}</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="array_8h_source.html#l00438">tpie::array&lt; tpie::file_stream&lt; element_type &gt; &gt;::array()</a>, <a class="el" href="array_8h_source.html#l00193">tpie::array&lt; tpie::file_stream&lt; element_type &gt; &gt;::at()</a>, <a class="el" href="internal__queue_8h_source.html#l00081">tpie::internal_queue&lt; item_type &gt;::back()</a>, <a class="el" href="array_8h_source.html#l00348">tpie::array&lt; tpie::file_stream&lt; element_type &gt; &gt;::back()</a>, <a class="el" href="compressed_2buffer_8h_source.html#l00159">tpie::compressor_buffer::capacity()</a>, <a class="el" href="array_8h_source.html#l00258">tpie::array&lt; tpie::file_stream&lt; element_type &gt; &gt;::empty()</a>, <a class="el" href="array_8h_source.html#l00326">tpie::array&lt; tpie::file_stream&lt; element_type &gt; &gt;::end()</a>, <a class="el" href="merge__sorter_8h_source.html#l00464">tpie::merge_sorter&lt; T, UseProgress, pred_t, store_t &gt;::end()</a>, <a class="el" href="array_8h_source.html#l00172">tpie::array&lt; tpie::file_stream&lt; element_type &gt; &gt;::find()</a>, <a class="el" href="internal__queue_8h_source.html#l00076">tpie::internal_queue&lt; item_type &gt;::front()</a>, <a class="el" href="internal__queue_8h_source.html#l00105">tpie::internal_queue&lt; item_type &gt;::full()</a>, <a class="el" href="array_8h_source.html#l00301">tpie::array&lt; tpie::file_stream&lt; element_type &gt; &gt;::operator!=()</a>, <a class="el" href="array_8h_source.html#l00214">tpie::array&lt; tpie::file_stream&lt; element_type &gt; &gt;::operator=()</a>, <a class="el" href="array_8h_source.html#l00289">tpie::array&lt; tpie::file_stream&lt; element_type &gt; &gt;::operator==()</a>, <a class="el" href="array_8h_source.html#l00266">tpie::array&lt; tpie::file_stream&lt; element_type &gt; &gt;::operator[]()</a>, <a class="el" href="internal__queue_8h_source.html#l00088">tpie::internal_queue&lt; item_type &gt;::push()</a>, <a class="el" href="stack_8h_source.html#l00105">tpie::stack&lt; item_type &gt;::push()</a>, <a class="el" href="internal__priority__queue_8h_source.html#l00109">tpie::internal_priority_queue&lt; tpie::ami::heap_ptr&lt; REC &gt;, comp &gt;::push()</a>, <a class="el" href="serialization__sorter_8h_source.html#l00131">tpie::serialization_bits::internal_sort&lt; T, std::less&lt; T &gt; &gt;::push()</a>, <a class="el" href="array_8h_source.html#l00368">tpie::array&lt; tpie::file_stream&lt; element_type &gt; &gt;::rend()</a>, <a class="el" href="array_8h_source.html#l00490">tpie::array&lt; tpie::file_stream&lt; element_type &gt; &gt;::resize()</a>, and <a class="el" href="serialization2_8h_source.html#l00266">tpie::serialize()</a>.</p>

</div>
</div>
<a id="aa0952a8561648801ba927724073eafa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0952a8561648801ba927724073eafa8">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Allocator  = allocator&lt;T&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classtpie_1_1array.html">tpie::array</a>&lt; T, Allocator &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtpie_1_1array.html">array</a>&lt; T, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swap two arrays. </p>

<p class="definition">Definition at line <a class="el" href="array_8h_source.html#l00504">504</a> of file <a class="el" href="array_8h_source.html">array.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;                             {</div>
<div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;        <a class="code" href="uncompressed__stream_8h.html#a0f6f3a3238be8084ae8f16ae2658bb10">std::swap</a>(m_allocator, other.m_allocator);</div>
<div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;        <a class="code" href="uncompressed__stream_8h.html#a0f6f3a3238be8084ae8f16ae2658bb10">std::swap</a>(m_elements, other.m_elements);</div>
<div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;        <a class="code" href="uncompressed__stream_8h.html#a0f6f3a3238be8084ae8f16ae2658bb10">std::swap</a>(m_size, other.m_size);</div>
<div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;        <a class="code" href="uncompressed__stream_8h.html#a0f6f3a3238be8084ae8f16ae2658bb10">std::swap</a>(m_tss_used, other.m_tss_used);</div>
<div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;    }</div>
</div><!-- fragment -->
<p class="reference">Referenced by <a class="el" href="merge__sorter_8h_source.html#l00464">tpie::merge_sorter&lt; T, UseProgress, pred_t, store_t &gt;::end()</a>, and <a class="el" href="array_8h_source.html#l00709">std::swap()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="array_8h_source.html">array.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="aclasstpie_1_1array_html_a7ddcc40ef6171c0ae5770e37e9cc5900"><div class="ttname"><a href="classtpie_1_1array.html#a7ddcc40ef6171c0ae5770e37e9cc5900">tpie::array::array</a></div><div class="ttdeci">array(size_type s, const T &amp;value, const Allocator &amp;alloc=Allocator())</div><div class="ttdoc">Construct array of given size.</div><div class="ttdef"><b>Definition:</b> <a href="array_8h_source.html#l00413">array.h:413</a></div></div>
<div class="ttc" id="aclasstpie_1_1array_html_a41970720ee4d82c796e18fae52f8df17"><div class="ttname"><a href="classtpie_1_1array.html#a41970720ee4d82c796e18fae52f8df17">tpie::array::at</a></div><div class="ttdeci">T &amp; at(size_t i)</div><div class="ttdoc">Return the element located at the given index.</div><div class="ttdef"><b>Definition:</b> <a href="array_8h_source.html#l00193">array.h:193</a></div></div>
<div class="ttc" id="aclasstpie_1_1array_html_a326b7bd44430e7d850f098a5a84162e8"><div class="ttname"><a href="classtpie_1_1array.html#a326b7bd44430e7d850f098a5a84162e8">tpie::array::resize</a></div><div class="ttdeci">void resize(size_t size, const T &amp;elm)</div><div class="ttdoc">Change the size of the array.</div><div class="ttdef"><b>Definition:</b> <a href="array_8h_source.html#l00490">array.h:490</a></div></div>
<div class="ttc" id="auncompressed__stream_8h_html_a0f6f3a3238be8084ae8f16ae2658bb10"><div class="ttname"><a href="uncompressed__stream_8h.html#a0f6f3a3238be8084ae8f16ae2658bb10">std::swap</a></div><div class="ttdeci">void swap(tpie::uncompressed_stream&lt; T &gt; &amp;a, tpie::uncompressed_stream&lt; T &gt; &amp;b)</div><div class="ttdoc">Enable std::swapping two tpie::file_streams.</div><div class="ttdef"><b>Definition:</b> <a href="uncompressed__stream_8h_source.html#l00182">uncompressed_stream.h:182</a></div></div>
<div class="ttc" id="aclasstpie_1_1array_html_a051a33a538aea7d4bd1f8a20f677e8fe"><div class="ttname"><a href="classtpie_1_1array.html#a051a33a538aea7d4bd1f8a20f677e8fe">tpie::array::size</a></div><div class="ttdeci">size_type size() const</div><div class="ttdoc">Return the size of the array.</div><div class="ttdef"><b>Definition:</b> <a href="array_8h_source.html#l00531">array.h:531</a></div></div>
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
      <li class="footer">from TPIE 4739728 (<a href="//github.com/thomasmoelhave/tpie/tree/4739728">browse source</a>). Generated on Mon May 23 2022 23:38:36 by
<a href="http://www.doxygen.org/index.html">Doxygen</a> 1.8.17 </li>
    </ul>
  </div>
</body>
</html>
